<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/128x128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.ico">
  <link rel="mask-icon" href="/images/mmz.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":400,"width_dual_column":300,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="动态规划练习题      题目1：300. 最长递增子序列1.题目描述给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增">
<meta property="og:type" content="article">
<meta property="og:title" content="组合总和IV | LeetCode-377 | 动态规划">
<meta property="og:url" content="http://example.com/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/index.html">
<meta property="og:site_name" content="神马都会亿点点的毛毛张">
<meta property="og:description" content="动态规划练习题      题目1：300. 最长递增子序列1.题目描述给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/04/26/142.png">
<meta property="og:image" content="http://example.com/assets/image-20241020120035127.png">
<meta property="og:image" content="http://example.com/assets/image-20241020120051444.png">
<meta property="article:published_time" content="2024-10-07T13:48:59.000Z">
<meta property="article:modified_time" content="2024-11-12T16:32:50.000Z">
<meta property="article:author" content="毛毛张">
<meta property="article:tag" content="中等">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2019/04/26/142.png">


<link rel="canonical" href="http://example.com/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","path":"2024/10/07/algorithm/leetcode/动态规划/LeetCode-300-最长上升子序列/","title":"组合总和IV | LeetCode-377 | 动态规划"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>组合总和IV | LeetCode-377 | 动态规划 | 神马都会亿点点的毛毛张</title>
  







<link rel="dns-prefetch" href="blogcomments-eta.vercel.app"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="神马都会亿点点的毛毛张" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">神马都会亿点点的毛毛张</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一万次悲伤，依然会有Dream</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">19</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">37</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">88</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">题目1：300. 最长递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%94%99%E8%A7%A3"><span class="nav-text">2.1 动态规划-错解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%AD%A3%E8%A7%A3"><span class="nav-text">2.2 动态规划-正解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">2.3 贪心 + 二分查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="nav-text">题目2：674. 最长连续递增序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-1"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">2.1 动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">2.2 贪心算法 &amp; 双指针 &amp; 滑动窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">题目3：718. 最长重复子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-2"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-text">2.1 暴力解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">2.2 动态规划-二维数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">题目4：1143. 最长公共子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-3"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">2.1 动态规划-二维数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="nav-text">题目5：1035. 不相交的线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-4"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-text">2.1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8F%98%E4%BD%93%EF%BC%9A"><span class="nav-text">题目变体：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%99%90%E5%88%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="nav-text">1. 限制连接的距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%80%E5%B0%8F%E5%8C%96%E4%BA%A4%E5%8F%89%E7%BA%BF%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-text">2. 最小化交叉线的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BB%99%E5%AE%9A%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E4%B8%8D%E5%90%8C%E6%9D%83%E9%87%8D"><span class="nav-text">3. 给定匹配值的不同权重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%B8%8D%E5%85%81%E8%AE%B8%E6%9F%90%E4%BA%9B%E7%89%B9%E5%AE%9A%E5%8C%B9%E9%85%8D"><span class="nav-text">4. 不允许某些特定匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B1%82%E8%A7%A3%E4%B8%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF"><span class="nav-text">5. 求解两数组中部分元素的最大不相交线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text">题目6：53. 最大子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-5"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-1"><span class="nav-text">2.1 暴力解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">2.2 贪心算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">2.3 动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">题目7：392. 判断子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-6"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">2.1 双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">2.2 动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE8%EF%BC%9A115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">题目8：115. 不同的子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-7"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-text">2.1 动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92"><span class="nav-text">2.2 记忆化递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE8%EF%BC%9A583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">题目8：583. 两个字符串的删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-8"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922"><span class="nav-text">2.1 动态规划2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922"><span class="nav-text">2.2 动态规划2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE9%EF%BC%9A72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-text">题目9：72. 编辑距离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-9"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-text">2.1 动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE10%EF%BC%9A647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">题目10：647. 回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-10"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-text">2.1 动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">2.2 双指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE11%EF%BC%9A5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">题目11：5. 最长回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-11"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="nav-text">2.1 动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE12%EF%BC%9A516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">题目12：516. 最长回文子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-12"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A2%98%E8%A7%A3-12"><span class="nav-text">2.题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-1"><span class="nav-text">2.1 动态规划-二维数组</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="毛毛张"
      src="/images/mmz.png">
  <p class="site-author-name" itemprop="name">毛毛张</p>
  <div class="site-description" itemprop="description">分享毛毛张毕生所学</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_48235955" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_48235955" rel="noopener me" target="_blank"><i class="fa fa-solid fa-newspaper fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/456166717" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;456166717" rel="noopener me" target="_blank"><i class="fa fa-solid fa-video fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/zzxrepository" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zzxrepository" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zzxkingdom@163.com" title="E-Mail → mailto:zzxkingdom@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>
        </div>
        <div class="">
          <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
            <span class="label">RSS</span>
          </a>
        </div>


      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

      


      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1475596788&auto=1&height=66"></iframe>
      
    </div>

    

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mmz.png">
      <meta itemprop="name" content="毛毛张">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神马都会亿点点的毛毛张">
      <meta itemprop="description" content="分享毛毛张毕生所学">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="组合总和IV | LeetCode-377 | 动态规划 | 神马都会亿点点的毛毛张">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          组合总和IV | LeetCode-377 | 动态规划
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-07 21:48:59" itemprop="dateCreated datePublished" datetime="2024-10-07T21:48:59+08:00">2024-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-13 00:32:50" itemprop="dateModified" datetime="2024-11-13T00:32:50+08:00">2024-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">动态规划</span></a>
        </span>
    </span>

  
    <span id="/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="post-meta-item leancloud_visitors" data-flag-title="组合总和IV | LeetCode-377 | 动态规划" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>40 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><center><b>动态规划练习题</b></center>





<h1 id="题目1：300-最长递增子序列"><a href="#题目1：300-最长递增子序列" class="headerlink" title="题目1：300. 最长递增子序列"></a>题目1：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10,9,2,5</span>,<span class="number">3,7,101,18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2,3,7,101</span>]，因此长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[0,1,0,3,2,3]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[7,7,7,7,7,7,7]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li>$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-错解"><a href="#2-1-动态规划-错解" class="headerlink" title="2.1 动态规划-错解"></a>2.1 动态规划-错解</h3><ul>
<li>这样求解的是<strong>以nums[nums.length-1]结尾的最长递增子序列的长度</strong>，题目要求的是全局的，最后一个不一定是全局最长递增子序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-动态规划-正解"><a href="#2-2-动态规划-正解" class="headerlink" title="2.2 动态规划-正解"></a>2.2 动态规划-正解</h3><ul>
<li>思路：<ul>
<li><strong>初始化</strong>：创建一个长度与输入数组相同的动态规划数组 <code>dp</code>，每个元素初始化为1。这表示每个元素至少可以构成长度为1的递增子序列（即它自身）。</li>
<li><strong>遍历</strong>：从数组的第二个元素开始，对每个元素进行遍历。</li>
<li><strong>比较</strong>：对于当前遍历到的元素，与它之前的所有元素进行比较。</li>
<li><strong>更新</strong>：如果当前元素比前面的元素大，说明有潜力构成更长的递增子序列。更新 <code>dp</code> 数组，<code>dp[i]</code> 表示以第 <code>i</code> 个元素结尾的最长递增子序列的长度。</li>
<li><strong>记录</strong>：在更新 <code>dp</code> 数组的同时，记录下遍历过程中找到的最长递增子序列的长度。</li>
<li><strong>返回结果</strong>：遍历结束后，<code>dp</code> 数组中的最大值即为整个数组的最长递增子序列的长度。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 创建一个长度与nums相同的数组，用于动态规划</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化dp数组，每个元素的值都设为1</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 初始化结果变量，用于记录最长递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 对于每个元素nums[i]，遍历其之前的所有元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">// 如果当前元素大于之前的元素nums[j]，则更新dp[i]的值</span></span><br><span class="line">                <span class="comment">// dp[i]表示以nums[i]结尾的最长递增子序列的长度</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果变量，记录遍历过程中找到的最长递增子序列的长度</span></span><br><span class="line">            result = Math.max(dp[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果变量，即整个数组的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-贪心-二分查找"><a href="#2-3-贪心-二分查找" class="headerlink" title="2.3 贪心 + 二分查找"></a>2.3 贪心 + 二分查找</h3><ul>
<li>核心逻辑：<ol>
<li>使用 <code>dp</code> 数组来存储递增子序列的最小结尾元素，以此动态更新递增子序列的长度。</li>
<li>每次遍历新元素时，如果新元素比当前最长递增子序列的末尾元素大，直接将其追加在 <code>dp</code> 的末尾；否则通过二分查找找到一个可以替换的元素，保持 <code>dp</code> 中递增子序列的最小性。</li>
<li>最终，<code>result</code> 记录了最长递增子序列的长度。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 用于记录最长递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 动态规划数组，dp[i] 表示长度为 i 的递增子序列的末尾元素的最小值</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化 dp 数组的第一个元素为 nums[0]</span></span><br><span class="line">        dp[result] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素大于 dp 中已知的最长递增子序列的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; dp[result]) &#123;</span><br><span class="line">                <span class="comment">// 递增子序列的长度加 1</span></span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 更新 dp 数组，记录新的最长递增子序列的最后一个元素</span></span><br><span class="line">                dp[result] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素小于或等于 dp 中已知的最长递增子序列的最后一个元素，</span></span><br><span class="line">                <span class="comment">// 我们需要找到 dp 中大于等于 nums[i] 的最小元素进行替换，以维持 dp 的有序性</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = result, pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进行二分查找，找到第一个大于等于 nums[i] 的位置</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 找到 dp 中大于等于 nums[i] 的最靠左的元素的索引</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &lt;= dp[mid]) &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用 nums[i] 更新 dp 数组中第一个大于等于它的位置</span></span><br><span class="line">                dp[left] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例打印：</p>
<ul>
<li><p>输入：<code>&#123;1, 2, 3, 5, 6, 4&#125;</code></p>
</li>
<li><p>输出dp数组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 0, 0, 0, 0]</span><br><span class="line">[0, 1, 2, 3, 0, 0, 0]</span><br><span class="line">[0, 1, 2, 3, 5, 0, 0]</span><br><span class="line">[0, 1, 2, 3, 5, 6, 0]</span><br><span class="line">[0, 1, 2, 3, 4, 6, 0]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="题目2：674-最长连续递增序列"><a href="#题目2：674-最长连续递增序列" class="headerlink" title="题目2：674. 最长连续递增序列"></a>题目2：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,3,5,4,7]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 <span class="comment">[1,3,5]</span>, 长度为3。</span><br><span class="line">尽管 <span class="comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,2,2,2,2]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 <span class="comment">[2]</span>, 长度为1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4$</li>
<li>$-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9$</li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><ul>
<li>思路：<ul>
<li><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长连续递增子序列长度。</li>
<li>遍历数组，每次遇到比前一个元素大的数时，将当前 <code>dp[i]</code> 更新为 <code>dp[i-1] + 1</code>，否则保持不变。</li>
<li>最终返回 <code>result</code>，即数组中的最长连续递增子序列长度。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 动态规划数组 dp，dp[i] 表示以 nums[i] 结尾的最长连续递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 结果变量 result 用于存储最长连续递增子序列的长度，初始化为 1，因为最短子序列长度为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化 dp 数组，所有元素的初始值都是 1，因为单个元素也是长度为 1 的递增子序列</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 遍历数组，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素 nums[i] 大于前一个元素 nums[i-1]，说明它可以延续递增子序列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) </span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 将 dp[i] 更新为 dp[i-1] 加 1</span></span><br><span class="line">            <span class="comment">// 更新结果 result，取 result 和 dp[i] 的最大值</span></span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最终结果，即最长连续递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-贪心算法-双指针-滑动窗口"><a href="#2-2-贪心算法-双指针-滑动窗口" class="headerlink" title="2.2 贪心算法 &amp; 双指针 &amp; 滑动窗口"></a>2.2 贪心算法 &amp; 双指针 &amp; 滑动窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心算法 &amp; 双指针 &amp; 滑动窗口方法</span></span><br><span class="line">        <span class="comment">// 左指针初始化为数组的第一个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 结果变量 result，用于存储最长连续递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右指针从数组的第一个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于或等于前一个元素，重置左指针到当前元素位置</span></span><br><span class="line">            <span class="comment">// 这是因为连续递增子序列必须是严格递增的</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; nums[right] &lt;= nums[right - <span class="number">1</span>]) </span><br><span class="line">                left = right;</span><br><span class="line">            <span class="comment">// 更新结果 result，计算当前窗口（从 left 到 right）的长度并取最大值</span></span><br><span class="line">            result = Math.max(result, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长连续递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目3：718-最长重复子数组"><a href="#题目3：718-最长重复子数组" class="headerlink" title="题目3：718. 最长重复子数组"></a>题目3：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h1><h2 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2,3,2,1]</span>, nums2 = <span class="comment">[3,2,1,4,7]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 <span class="comment">[3,2,1]</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[0,0,0,0,0]</span>, nums2 = <span class="string">[0,0,0,0,0]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
<h2 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力解法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i + subLength &lt; n &amp;&amp; j + subLength &lt; m &amp;&amp; nums1[i+ subLength] == nums2[j + subLength])&#123;</span><br><span class="line">                        subLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = Math.max(subLength,result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-动态规划-二维数组"><a href="#2-2-动态规划-二维数组" class="headerlink" title="2.2 动态规划-二维数组"></a>2.2 动态规划-二维数组</h3><ul>
<li>思路：<ul>
<li><strong>二维动态规划</strong>：定义 <code>dp[i][j]</code> 表示以 <code>nums1[i-1]</code> 和 <code>nums2[j-1]</code> 结尾的最长重复子数组的长度。</li>
<li><strong>状态转移方程</strong>：如果 <code>nums1[i-1] == nums2[j-1]</code>，那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，表示当前两个数组的元素相等，长度可以在之前的基础上加 1。</li>
<li><strong>结果维护</strong>：每次更新 <code>dp[i][j]</code> 时，比较当前最长的重复子数组长度 <code>result</code>，并存储最大的长度。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划 - 使用二维数组</span></span><br><span class="line">        <span class="comment">// n 表示 nums1 的长度，m 表示 nums2 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示以 nums1[i-1] 和 nums2[j-1] 结尾的最长重复子数组的长度</span></span><br><span class="line">        <span class="comment">// 使用 n+1 和 m+1 来处理边界情况，即考虑当 i 或 j 为 0 时的状态，dp[0][*] 或 dp[*][0] 默认初始化为 0</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化最长重复子数组的长度为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历 nums1 和 nums2，填充 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1[i-1] 等于 nums2[j-1]，说明可以在前面的基础上继续增加子数组长度</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// dp[i][j] 等于 dp[i-1][j-1] + 1，表示当前元素相同，最长子数组长度加 1</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每次更新 result，保存当前最长的子数组长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长重复子数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="题目4：1143-最长公共子序列"><a href="#题目4：1143-最长公共子序列" class="headerlink" title="题目4：1143. 最长公共子序列"></a>题目4：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><h2 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abcde&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<h2 id="2-题解-3"><a href="#2-题解-3" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-二维数组"><a href="#2-1-动态规划-二维数组" class="headerlink" title="2.1 动态规划-二维数组"></a>2.1 动态规划-二维数组</h3><ul>
<li>思路：<ul>
<li><strong>动态规划二维表</strong>：<code>dp[i][j]</code> 表示 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列长度。</li>
<li>状态转移方程：<ul>
<li>如果当前字符相同（<code>text1[i-1] == text2[j-1]</code>），则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，表示在前一个状态基础上增加一个相同字符。</li>
<li>如果当前字符不同，则 <code>dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])</code>，表示取不相等情况下的最大公共子序列长度。</li>
</ul>
</li>
<li><strong>结果维护</strong>：在遍历过程中，每次计算出 <code>dp[i][j]</code> 后，将其与 <code>result</code> 比较并更新，确保 <code>result</code> 保持为当前最大值。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 text1 和 text2 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 result 变量，用于保存最终最长公共子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 dp 二维数组，dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列长度</span></span><br><span class="line">        <span class="comment">// dp[0][*] 和 dp[*][0] 初始化为 0，表示空字符串与其他字符串的最长公共子序列长度为 0</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双层循环遍历 text1 和 text2 的所有字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 取出当前遍历的字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>); <span class="comment">// text1 的第 i 个字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>); <span class="comment">// text2 的第 j 个字符</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果两个字符相同，则最长公共子序列可以在 dp[i-1][j-1] 的基础上加 1</span></span><br><span class="line">                <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 如果两个字符不相同，则最长公共子序列等于 dp[i-1][j] 和 dp[i][j-1] 的最大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新 result，保存最长的公共子序列长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果，即最长公共子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="题目5：1035-不相交的线"><a href="#题目5：1035-不相交的线" class="headerlink" title="题目5：1035. 不相交的线"></a>题目5：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h1><h2 id="1-题目描述-4"><a href="#1-题目描述-4" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom: 25%;" />

<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 <span class="symbol">nums1</span>[<span class="number">1</span>]=<span class="number">4</span> 到 <span class="symbol">nums2</span>[<span class="number">2</span>]=<span class="number">4</span> 的直线将与从 <span class="symbol">nums1</span>[<span class="number">2</span>]=<span class="number">2</span> 到 <span class="symbol">nums2</span>[<span class="number">1</span>]=<span class="number">2</span> 的直线相交。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[2,5,1,2,5]</span>, nums2 = <span class="string">[10,5,2,1,5,2]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[1,3,7,1,7,5]</span>, nums2 = <span class="string">[1,9,2,5,1]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>
</ul>
<h2 id="2-题解-4"><a href="#2-题解-4" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-1"><a href="#2-1-动态规划-1" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">// 此问题可以转化为经典的最长公共子序列（LCS）问题</span></span><br><span class="line">        <span class="comment">// nums1 和 nums2 分别表示两个数组</span></span><br><span class="line">        <span class="comment">// n 和 m 分别表示 nums1 和 nums2 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个大小为 (n+1) x (m+1) 的二维数组 dp，用于存储中间计算结果</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示在 nums1 的前 i 个元素和 nums2 的前 j 个元素中，最长的公共子序列长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结果变量 result 用于存储最终的最长不相交线的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用动态规划填充 dp 表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1[i-1] 和 nums2[j-1] 相等，则说明它们可以作为一条不相交的线</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// dp[i][j] 等于 dp[i-1][j-1] + 1，即将前一个位置的公共子序列长度加 1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则，dp[i][j] 等于 dp[i-1][j] 和 dp[i][j-1] 中的较大者</span></span><br><span class="line">                    <span class="comment">// 即选择不加入当前元素时的最长子序列长度</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新结果，保持 result 为当前遇到的最大公共子序列长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终的最长不相交线的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题目变体："><a href="#题目变体：" class="headerlink" title="题目变体："></a>题目变体：</h2><h3 id="1-限制连接的距离"><a href="#1-限制连接的距离" class="headerlink" title="1. 限制连接的距离"></a>1. <strong>限制连接的距离</strong></h3><ul>
<li><strong>问题变形</strong>：要求两条线段（元素之间的匹配）之间的距离不能超过 <code>k</code>（即 <code>nums1[i]</code> 和 <code>nums2[j]</code> 匹配时，<code>|i - j| &lt;= k</code>）。</li>
<li><strong>解法</strong>：在原有的动态规划方案基础上，增加对距离的限制。也就是在计算 <code>dp[i][j]</code> 时，只有满足 <code>|i - j| &lt;= k</code> 的情况下，才能更新 <code>dp[i][j]</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, i - k); j &lt;= Math.min(m, i + k); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变动点</strong>：在双重循环里，对 <code>j</code> 进行了限制，使得它只能在 <code>i - k</code> 和 <code>i + k</code> 范围内搜索。</p>
<h3 id="2-最小化交叉线的数量"><a href="#2-最小化交叉线的数量" class="headerlink" title="2. 最小化交叉线的数量"></a>2. <strong>最小化交叉线的数量</strong></h3><ul>
<li><strong>问题变形</strong>：要求不仅要计算不相交的线数，还要求最小化交叉线的数量。</li>
<li><strong>解法</strong>：将问题从最大化不相交线的数量转换为最小化交叉线。可以通过增加一个计数器来记录交叉线的数量，并基于 <code>dp</code> 的方式，在更新 <code>dp[i][j]</code> 时记录那些产生交叉的情况。</li>
</ul>
<p>解法思路：将匹配的路径记录下来，交叉线可以根据路径上的线段是否互相交叉来判断。</p>
<h3 id="3-给定匹配值的不同权重"><a href="#3-给定匹配值的不同权重" class="headerlink" title="3. 给定匹配值的不同权重"></a>3. <strong>给定匹配值的不同权重</strong></h3><ul>
<li><strong>问题变形</strong>：两个数组中的元素匹配时，有不同的权重，要求最大化匹配线段的权重和，而不仅仅是匹配的数量。</li>
<li><strong>解法</strong>：在 <code>dp</code> 数组中存储权重和而不是匹配的数量。当 <code>nums1[i-1] == nums2[j-1]</code> 时，不是简单地加 <code>1</code>，而是加上它们的匹配权重值（可以提前给定的权重函数）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxWeightedUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[][] weights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 使用给定的权重值代替简单的 +1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + weights[nums1[i-<span class="number">1</span>]][nums2[j-<span class="number">1</span>]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变动点</strong>：这里加入了 <code>weights</code> 矩阵，代表不同元素匹配的权重，动态规划时会选择权重和最大的匹配方案。</p>
<h3 id="4-不允许某些特定匹配"><a href="#4-不允许某些特定匹配" class="headerlink" title="4. 不允许某些特定匹配"></a>4. <strong>不允许某些特定匹配</strong></h3><ul>
<li><strong>问题变形</strong>：要求有些元素不能匹配，例如给定一组禁用的匹配对 <code>(x, y)</code>，<code>nums1</code> 中的元素 <code>x</code> 不能和 <code>nums2</code> 中的元素 <code>y</code> 匹配。</li>
<li><strong>解法</strong>：在进行动态规划时，提前将这些禁止的匹配对存入一个哈希表，在判断 <code>nums1[i-1]</code> 和 <code>nums2[j-1]</code> 是否相等时，同时检查它们是否在禁用对中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, Set&lt;Pair&lt;Integer, Integer&gt;&gt; bannedPairs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                Pair&lt;Integer, Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>] &amp;&amp; !bannedPairs.contains(pair)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变动点</strong>：增加一个禁用匹配对的集合，在动态规划时排除不允许的匹配。</p>
<h3 id="5-求解两数组中部分元素的最大不相交线"><a href="#5-求解两数组中部分元素的最大不相交线" class="headerlink" title="5. 求解两数组中部分元素的最大不相交线"></a>5. <strong>求解两数组中部分元素的最大不相交线</strong></h3><ul>
<li><strong>问题变形</strong>：不是要求整个数组，而是要求找出两个子数组（或从原数组中任意挑选的若干元素）之间的最大不相交线数。</li>
<li><strong>解法</strong>：在原有的 <code>dp</code> 方法基础上，可以额外维护一个可以选择的元素集合或对两数组进行部分切割，动态规划求解部分区间的最长公共子序列。</li>
</ul>
<h1 id="题目6：53-最大子数组和"><a href="#题目6：53-最大子数组和" class="headerlink" title="题目6：53. 最大子数组和"></a>题目6：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><h2 id="1-题目描述-5"><a href="#1-题目描述-5" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,<span class="string">-1</span>,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[5,4,-1,7,8]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5$</li>
<li>$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$</li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="2-题解-5"><a href="#2-题解-5" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-暴力解法-1"><a href="#2-1-暴力解法-1" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力解法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                result = Math.max(result,sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-贪心算法"><a href="#2-2-贪心算法" class="headerlink" title="2.2 贪心算法"></a>2.2 贪心算法</h3><ul>
<li>思路：<ul>
<li>在遍历数组的过程中，维护一个当前子数组的和 <code>sum</code>。</li>
<li>每次将当前元素加入到 <code>sum</code> 中，如果 <code>sum</code> 变为负数，则抛弃当前的子数组（即重置 <code>sum</code> 为 0），因为负数只会减少后续子数组的和。</li>
<li>同时在每一步更新记录最大子数组和的变量 <code>result</code>，确保记录遍历到的最大子数组和。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化结果为整数的最小值，表示子数组的最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 初始化当前子数组的和为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素加入当前子数组的和</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">// 更新最大子数组的和，比较当前的和与之前记录的最大值</span></span><br><span class="line">            result = Math.max(result, sum);</span><br><span class="line">            <span class="comment">// 如果当前子数组的和为负数，则将和重置为0（贪心策略：负数会降低后面的和）</span></span><br><span class="line">            sum = Math.max(sum, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大子数组和</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-动态规划"><a href="#2-3-动态规划" class="headerlink" title="2.3 动态规划"></a>2.3 动态规划</h3><ul>
<li>思路：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义 dp 数组，dp[i] 表示以第 i 个元素结尾的子数组的最大和</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 初始化 dp[0]，即以第一个元素结尾的子数组最大和就是该元素本身</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 初始化 result，保存最终结果，初始值为第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程：dp[i] 表示以 nums[i] 结尾的最大子数组和</span></span><br><span class="line">            <span class="comment">// 选择要么将当前元素 nums[i] 加入前面的子数组（即 dp[i-1] + nums[i]），</span></span><br><span class="line">            <span class="comment">// 要么以当前元素 nums[i] 开始一个新的子数组，取两者中的最大值</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="comment">// 更新 result，确保 result 始终存储全局的最大子数组和</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; result) &#123;</span><br><span class="line">                result = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大子数组和</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="题目7：392-判断子序列"><a href="#题目7：392-判断子序列" class="headerlink" title="题目7：392. 判断子序列"></a>题目7：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h1><h2 id="1-题目描述-6"><a href="#1-题目描述-6" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>致谢：</strong></p>
<p>特别感谢 <a target="_blank" rel="noopener" href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;axc&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 100</code></li>
<li>$0 &lt;&#x3D; t.length &lt;&#x3D; 10^4$</li>
<li>两个字符串都只由小写字符组成。</li>
</ul>
<h2 id="2-题解-6"><a href="#2-题解-6" class="headerlink" title="2.题解"></a>2.题解</h2><ul>
<li>这个道题目是最长公共子序列的变体</li>
</ul>
<h3 id="2-1-双指针"><a href="#2-1-双指针" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 s 和 t 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义双指针：left 指向 s，right 指向 t</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当两个指针都没有越界时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; n &amp;&amp; right &lt; m) &#123;</span><br><span class="line">            <span class="comment">// 如果 s[left] 与 t[right] 匹配，left 前进，查找 s 中下一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) == t.charAt(right)) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// right 指针总是前进，用来遍历 t</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 left 达到了 s 的末尾，说明 s 是 t 的子序列</span></span><br><span class="line">        <span class="keyword">return</span> left == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h3><ul>
<li><strong>动态规划表 <code>dp</code> 的定义：</strong><ul>
<li><code>dp[i][j]</code> 表示 <code>t</code> 的前 <code>i</code> 个字符和 <code>s</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。</li>
<li>核心是通过逐步填充 <code>dp</code> 表，来判断 <code>s</code> 是否可以作为 <code>t</code> 的子序列。</li>
</ul>
</li>
<li><strong>状态转移：</strong><ul>
<li>如果 <code>t[i-1] == s[j-1]</code>，那么当前字符相等，最长公共子序列的长度增加 <code>1</code>，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>如果 <code>t[i-1] != s[j-1]</code>，那么最长公共子序列的长度保持不变，即 <code>dp[i][j] = dp[i-1][j]</code>。</li>
</ul>
</li>
<li><strong>结果判断：</strong><ul>
<li>最后判断 <code>dp[n][m] == m</code> 是否成立。如果 <code>dp[n][m]</code> 等于 <code>m</code>，说明 <code>s</code> 的所有字符都可以在 <code>t</code> 中按顺序找到，即 <code>s</code> 是 <code>t</code> 的子序列，返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取字符串 t 和 s 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 t 的前 i 个字符和 s 的前 j 个字符的最长公共子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 t 的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历 s 的每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 获取 t 中的第 i-1 个字符和 s 中的第 j-1 个字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ct</span> <span class="operator">=</span> t.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span> s.charAt(j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果两个字符相等，说明它们可以加入到最长公共子序列</span></span><br><span class="line">                <span class="keyword">if</span> (ct == cs)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 否则最长公共子序列的长度保持不变，丢弃 t 的当前字符</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断最长公共子序列的长度是否等于 s 的长度</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m] == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="题目8：115-不同的子序列"><a href="#题目8：115-不同的子序列" class="headerlink" title="题目8：115. 不同的子序列"></a>题目8：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h1><h2 id="1-题目描述-7"><a href="#1-题目描述-7" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 109 + 7 取模。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/./assets/image-20241020120035127.png" alt="image-20241020120035127"></p>
<p><strong>示例 2：</strong></p>
<p><img src="/./assets/image-20241020120051444.png" alt="image-20241020120051444"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<h2 id="2-题解-7"><a href="#2-题解-7" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-2"><a href="#2-1-动态规划-2" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length(); <span class="comment">// 获取字符串 t 的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s 的前 i 个字符中出现 t 的前 j 个字符的子序列个数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：当 t 为空串时，无论 s 是什么，结果都是 1，因为空串是任何字符串的子序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果 s[i-1] 与 t[j-1] 相等，可以选择匹配它们或者不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// dp[i-1][j-1] 表示匹配 s[i-1] 和 t[j-1]，dp[i-1][j] 表示不匹配</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 s[i-1] 与 t[j-1] 不相等，跳过 s[i-1]，保持 dp[i-1][j]</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果是 dp[n][m]，即 s 的前 n 个字符中出现 t 的前 m 个字符的子序列个数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-记忆化递归"><a href="#2-2-记忆化递归" class="headerlink" title="2.2 记忆化递归"></a>2.2 记忆化递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化一个二维数组来缓存递归结果，-1 表示尚未计算过</span></span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                memo[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用递归函数</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s, t, n, m, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归函数，计算 s 的前 i 个字符中有多少个子序列等于 t 的前 j 个字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(String s, String t, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 t 是空串，空串是任何字符串的子序列，返回 1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 s 是空串且 t 不是空串，不可能匹配，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经计算过，直接返回缓存的结果</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符匹配，既可以匹配当前字符，也可以跳过当前字符</span></span><br><span class="line">            memo[i][j] = dfs(s, t, i - <span class="number">1</span>, j - <span class="number">1</span>, memo) + dfs(s, t, i - <span class="number">1</span>, j, memo);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符不匹配，只能跳过当前字符</span></span><br><span class="line">            memo[i][j] = dfs(s, t, i - <span class="number">1</span>, j, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回计算结果</span></span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="题目8：583-两个字符串的删除操作"><a href="#题目8：583-两个字符串的删除操作" class="headerlink" title="题目8：583. 两个字符串的删除操作"></a>题目8：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><h2 id="1-题目描述-8"><a href="#1-题目描述-8" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">word1</span> = <span class="string">&quot;sea&quot;</span>, <span class="attr">word2</span> = <span class="string">&quot;eat&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 第一步将 <span class="string">&quot;sea&quot;</span> 变为 <span class="string">&quot;ea&quot;</span> ，第二步将 <span class="string">&quot;eat &quot;</span>变为 <span class="string">&quot;ea&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例  2:</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">word2</span> = <span class="string">&quot;etco&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li>
</ul>
<h2 id="2-题解-8"><a href="#2-题解-8" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划2"><a href="#2-1-动态规划2" class="headerlink" title="2.1 动态规划2"></a>2.1 动态规划2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(); <span class="comment">// 获取 word1 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length(); <span class="comment">// 获取 word2 的长度</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作次数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则不需要进行任何操作，dp[i][j] 等于 dp[i-1][j-1]</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不相等，选择三种操作中最小的</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回将 word1 转换为 word2 所需的最少操作次数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-动态规划2"><a href="#2-2-动态规划2" class="headerlink" title="2.2 动态规划2"></a>2.2 动态规划2</h3><ul>
<li>只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(); <span class="comment">// 获取 word1 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length(); <span class="comment">// 获取 word2 的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 word1 的前 i 个字符和 word2 的前 j 个字符之间的最长公共子序列长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来记录最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// 遍历 word1 和 word2 的每个字符，填充 dp 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则最长公共子序列长度可以在前一个基础上 +1</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不相等，最长公共子序列的长度是去掉任一字符后的最大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最长公共子序列的长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最少操作次数 = 两个字符串的长度之和 - 2 * 最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// 原因：最少操作次数等于将不属于最长公共子序列的字符删除，并插入到正确位置上</span></span><br><span class="line">        <span class="keyword">return</span> n + m - result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="题目9：72-编辑距离"><a href="#题目9：72-编辑距离" class="headerlink" title="题目9：72. 编辑距离"></a>题目9：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h1><h2 id="1-题目描述-9"><a href="#1-题目描述-9" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">horse</span> -&gt;</span> rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rorse</span> -&gt;</span> rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rose</span> -&gt;</span> ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">intention</span> -&gt;</span> inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">inention</span> -&gt;</span> enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">enention</span> -&gt;</span> exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">exention</span> -&gt;</span> exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">exection</span> -&gt;</span> execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h2 id="2-题解-9"><a href="#2-题解-9" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-3"><a href="#2-1-动态规划-3" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(); <span class="comment">// 获取 word1 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length(); <span class="comment">// 获取 word2 的长度</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作次数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化：将 word1 的前 i 个字符转换为空字符串，所需的操作次数是 i（全部删除）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="comment">// 初始化：将空字符串转换为 word2 的前 j 个字符，所需的操作次数是 j（全部插入）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则不需要进行任何操作，dp[i][j] 等于 dp[i-1][j-1]</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不相等，选择三种操作中最小的：</span></span><br><span class="line">                    <span class="comment">//dp[i - 1][j] + 1 删除操作</span></span><br><span class="line">                    <span class="comment">//dp[i][j - 1] + 1 增加操作</span></span><br><span class="line">                    <span class="comment">//dp[i-1][j-1] + 1 替换操作</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回将 word1 转换为 word2 所需的最少操作次数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="题目10：647-回文子串"><a href="#题目10：647-回文子串" class="headerlink" title="题目10：647. 回文子串"></a>题目10：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h1><h2 id="1-题目描述-10"><a href="#1-题目描述-10" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：三个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">6</span>个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h2 id="2-题解-10"><a href="#2-题解-10" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-4"><a href="#2-1-动态规划-4" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><ul>
<li>思路解析：</li>
</ul>
<ol>
<li><strong>回文子串的定义</strong>：<ul>
<li>回文子串是一个正读和反读都相同的子字符串。</li>
<li>例如：在字符串 “abcba” 中，”a”、”b”、”c”、”bcb”、”abcba” 都是回文子串。</li>
</ul>
</li>
<li><strong>动态规划的状态定义</strong>：<ul>
<li>创建一个二维数组 <code>dp[i][j]</code>，其中 <code>i</code> 表示子字符串的起始位置，<code>j</code> 表示子字符串的结束位置。<code>dp[i][j]</code> 为 <code>true</code> 表示子字符串 <code>s[i..j]</code> 是一个回文串，<code>false</code> 表示不是回文串。</li>
</ul>
</li>
<li><strong>转移方程</strong>：<ul>
<li>如果<code>s[i] == s[j]</code>，那么：<ul>
<li>如果 <code>j - i &lt;= 1</code>（即子串长度为 1 或 2），则 <code>s[i..j]</code> 肯定是回文串，直接标记 <code>dp[i][j] = true</code>。</li>
<li>如果 <code>j - i &gt; 1</code>，则需要判断内部的子串 <code>s[i+1..j-1]</code> 是否是回文串。如果 <code>dp[i+1][j-1] == true</code>，那么 <code>s[i..j]</code> 也是回文串。</li>
</ul>
</li>
</ul>
</li>
<li><strong>遍历顺序</strong>：<ul>
<li>从右向左遍历字符串 <code>s</code> 的每个字符 <code>i</code>，对于每个 <code>i</code>，遍历其右侧的每个字符 <code>j</code>（<code>j &gt;= i</code>），判断 <code>s[i..j]</code> 是否为回文串。</li>
<li>这种遍历顺序保证了在判断 <code>s[i..j]</code> 是否为回文串时，子串 <code>s[i+1..j-1]</code> 的状态已经被计算出来。</li>
</ul>
</li>
<li><strong>结果统计</strong>：<ul>
<li>每当找到一个回文子串（即 <code>dp[i][j] == true</code>），结果 <code>result</code> 加 1。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度 n</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n]; <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 存储回文子串的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从字符串末尾向前遍历每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123; <span class="comment">// 遍历以 i 开始、以 j 结束的子字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123; <span class="comment">// 如果 s[i] == s[j]</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 如果子串长度为 1 或 2</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result++; <span class="comment">// 是回文串，计数加 1</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123; <span class="comment">// 否则检查 s[i+1..j-1] 是否为回文</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result++; <span class="comment">// 如果 s[i+1..j-1] 是回文，则 s[i..j] 也是回文</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回回文子串的总个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码优化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度 n</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n]; <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 存储回文子串的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从字符串末尾向前遍历每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123; <span class="comment">// 遍历以 i 开始、以 j 结束的子字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i == <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123; <span class="comment">// 如果 s[i] == s[j]</span></span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    result++; <span class="comment">// 是回文串，计数加 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回回文子串的总个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h3><ul>
<li><strong>中心扩展法</strong>：<ul>
<li>对于一个长度为 <code>n</code> 的字符串，有 <code>2n-1</code> 个可能的中心。对于每个字符，它可以作为单字符中心，此外，两个相邻字符之间也可以作为双字符中心。因此有 <code>n</code> 个单字符中心和 <code>n-1</code> 个双字符中心。</li>
</ul>
</li>
<li><strong>双指针</strong>：<ul>
<li><code>left</code> 和 <code>right</code> 两个指针从中心开始向外扩展，检查左右两侧的字符是否相等。如果相等，则说明找到一个回文子串。</li>
<li><code>i / 2</code> 用于计算左指针，<code>i % 2</code> 用于处理双字符中心的情况。</li>
</ul>
</li>
<li><strong>计数</strong>：<ul>
<li>每当找到一个回文子串，<code>result</code> 计数器就加 1。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用双指针法，通过中心扩展来计算回文子串数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于记录回文子串的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 2 * n - 1 个中心点</span></span><br><span class="line">        <span class="comment">// 对于长度为 n 的字符串，可以有 n 个单字符中心和 n-1 个双字符中心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前中心的左边界和右边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i / <span class="number">2</span>; <span class="comment">// 左指针指向当前中心的左侧字符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + i % <span class="number">2</span>; <span class="comment">// 右指针指向当前中心的右侧字符，取决于是单字符中心还是双字符中心</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩展中心，检查回文</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                result++; <span class="comment">// 找到一个回文子串，计数+1</span></span><br><span class="line">                left--; <span class="comment">// 左指针向左扩展</span></span><br><span class="line">                right++; <span class="comment">// 右指针向右扩展</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回找到的回文子串总数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="题目11：5-最长回文子串"><a href="#题目11：5-最长回文子串" class="headerlink" title="题目11：5. 最长回文子串"></a>题目11：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="1-题目描述-11"><a href="#1-题目描述-11" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h2 id="2-题解-11"><a href="#2-题解-11" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-5"><a href="#2-1-动态规划-5" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;  <span class="comment">// 如果字符串为空或只有一个字符，直接返回</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, maxLength = <span class="number">1</span>;  <span class="comment">// 初始的最长回文长度为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历的顺序：从后往前填充</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;  <span class="comment">// 单个字符本身就是回文</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断当前字符是否相同以及内部子串是否是回文</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i == <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">int</span> <span class="variable">currentLength</span> <span class="operator">=</span> j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (currentLength &gt; maxLength) &#123;</span><br><span class="line">                        maxLength = currentLength;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="题目12：516-最长回文子序列"><a href="#题目12：516-最长回文子序列" class="headerlink" title="题目12：516. 最长回文子序列"></a>题目12：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><h2 id="1-题目描述-12"><a href="#1-题目描述-12" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bbbb&quot;</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bb&quot;</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="2-题解-12"><a href="#2-题解-12" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-二维数组-1"><a href="#2-1-动态规划-二维数组-1" class="headerlink" title="2.1 动态规划-二维数组"></a>2.1 动态规划-二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示从字符串 s 的第 i 个字符到第 j 个字符之间的最长回文子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前遍历字符串的每个字符 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 内部循环从 i 到字符串的末尾 j</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果第 i 和第 j 个字符相同</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">// 如果 i 和 j 是同一个字符，最长回文子序列的长度为 1</span></span><br><span class="line">                    <span class="keyword">if</span> (j == i)</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 否则，最长回文子序列等于 2 加上去掉当前字符后的回文长度</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 i 和 j 字符不同，则取舍去掉 i 或去掉 j 的情况中较大的回文子序列长度</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回从字符串第 0 个字符到最后一个字符之间的最长回文子序列长度</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






    </div>
    

    
    
    

     
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer"><div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="毛毛张 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="毛毛张 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>毛毛张
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" title="组合总和IV | LeetCode-377 | 动态规划">http://example.com/2024/10/07/algorithm/leetcode/动态规划/LeetCode-300-最长上升子序列/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E4%B8%AD%E7%AD%89/" rel="tag"><i class="fa fa-tag"></i> 中等</a>
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/" rel="prev" title="零钱兑换 | LeetCode-322 | 动态规划">
                  <i class="fa fa-angle-left"></i> 零钱兑换 | LeetCode-322 | 动态规划
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-121-%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/" rel="next" title="秒股票的最佳时机系列 | LeetCode-121 | 动态规划">
                  秒股票的最佳时机系列 | LeetCode-121 | 动态规划 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="copyright">
    &copy; 2024 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">毛毛张</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">282k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:51</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("06/06/2024 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "轻舟已过万重山：本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒 ~喵~";
    }
setInterval("createtime()",250);
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"4PhbEkjStVSaf5SVgY17oqhA-MdYXbMMI","app_key":"d2Z7ZT9wrqolX8dJD2iYTt56","server_url":null,"security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"blogcomments-eta.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀!","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
  
  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
  
</body>
</html>
