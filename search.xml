<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网站声明</title>
    <url>/2024/09/08/%E7%BD%91%E7%AB%99%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<p><center><font color="orange">🌈大家好！我是神马都会亿点点的毛毛张👋</font><center></p>
<p><center><font color="green">🍏本站发布的全部博客是毛毛张整理的笔记，内容全部根据互联网上可以检索到的资源整理而来！🍒</font><center></p>
<p><center><font color="green">🥝毛毛张在写博客的过程中尽量标注全部应用的参考文献或者资源！🍓</font><center></p>
<p><center><font color="green">🥑如果在文章中引用的内容涉及到侵权、版权问题、或者应用内容禁止被转载了🍎</font><center></p>
<p><center><font color="red">🍉请通过首页的邮箱📩联系毛毛张，立马修改！🍊</font><center><br><span id="more"></span></p>
]]></content>
      <categories>
        <category>网站公告</category>
      </categories>
      <tags>
        <tag>网站公告</tag>
      </tags>
  </entry>
  <entry>
    <title>携带研究材料 | KamaCoder-46 | 动态规划 | 0-1背包问题</title>
    <url>/2024/09/24/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/KamaCoder-46-%E6%90%BA%E5%B8%A6%E7%A0%94%E7%A9%B6%E6%9D%90%E6%96%99/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://kamacoder.com/problempage.php?pid=1046">46. 携带研究材料<a/></b></p>
<center>


<hr>
<h1 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1.01背包"></a>1.01背包</h1><h2 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h2><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 </p>
<p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p>
<h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。</p>
<p>第二行包含 M 个正整数，代表每种研究材料的所占空间。 </p>
<p>第三行包含 M 个正整数，代表每种研究材料的价值。</p>
<h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表小明能够携带的研究材料的最大价值。</p>
<h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">6 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 </p>
<p>数据范围：<br>1 &lt;= N &lt;= 5000<br>1 &lt;= M &lt;= 5000<br>研究材料占用空间和价值都小于等于 1000</p>
<h2 id="1-2-题解"><a href="#1-2-题解" class="headerlink" title="1.2 题解"></a>1.2 题解</h2><h3 id="1-2-1-动态规划"><a href="#1-2-1-动态规划" class="headerlink" title="1.2.1 动态规划"></a>1.2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象来读取输入数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 材料的种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 行李的空间大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组来存储材料的重量和价值</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每种材料的重量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            weights[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每种材料的价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            values[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化动态规划数组，dp[i][j] 表示前 i 个物品在容量为 j 的背包中可达到的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理第一个物品的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> weights[<span class="number">0</span>]; i &lt;= n; i++) &#123;</span><br><span class="line">        	dp[<span class="number">0</span>][i] = values[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐件处理物品，更新 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weights[i]; j &lt;= n; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">                <span class="comment">// 更新 dp[i][j]，取放入当前物品和不放入当前物品中的最大值</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weights[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出背包容量为 n 时的最大价值</span></span><br><span class="line">        System.out.println(dp[m - <span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-动态规划-滚动数组"><a href="#1-2-2-动态规划-滚动数组" class="headerlink" title="1.2.2 动态规划-滚动数组"></a>1.2.2 动态规划-滚动数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象来读取输入数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 材料的种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 行李的空间大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组来存储材料的重量和价值</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每种材料的重量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            weights[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每种材料的价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            values[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化动态规划数组，dp[j] 表示容量为 j 的背包可以装下的物品的最大价值</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐件处理物品，更新 dp 数组</span></span><br><span class="line">        <span class="comment">// 先处理第一件物品的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> weights[<span class="number">0</span>]; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = values[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐件处理剩下的物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= weights[i]; j--) &#123; <span class="comment">// 从大到小遍历背包容量</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出背包容量为 n 时的最大价值</span></span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-动态规划-滚动数组优化"><a href="#1-2-3-动态规划-滚动数组优化" class="headerlink" title="1.2.3 动态规划-滚动数组优化"></a>1.2.3 动态规划-滚动数组优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象来读取输入数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 材料的种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 行李的空间大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组来存储材料的重量和价值</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每种材料的重量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            weights[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每种材料的价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            values[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化动态规划数组，dp[j] 表示容量为 j 的背包可以装下的物品的最大价值</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐件处理剩下的物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= weights[i]; j--) &#123; <span class="comment">// 从大到小遍历背包容量</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出背包容量为 n 时的最大价值</span></span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 scanner 对象，释放资源</span></span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2.完全背包"></a>2.完全背包</h1><h2 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h2><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。</p>
<p>小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。</p>
<h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 </p>
<p>接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值</p>
<h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示最大价值。</p>
<h6 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h6 id="提示信息-1"><a href="#提示信息-1" class="headerlink" title="提示信息"></a>提示信息</h6><p>第一种材料选择五次，可以达到最大值。</p>
<p>数据范围：</p>
<p>1 &lt;= N &lt;= 10000;<br>1 &lt;= V &lt;= 10000;<br>1 &lt;= wi, vi &lt;= 10^9.</p>
<h2 id="2-2-题解"><a href="#2-2-题解" class="headerlink" title="2.2 题解"></a>2.2 题解</h2><h3 id="2-2-1-滚动数组"><a href="#2-2-1-滚动数组" class="headerlink" title="2.2.1 滚动数组"></a>2.2.1 滚动数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 导入Scanner类，用于读取控制台输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; <span class="comment">// 主类定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 主函数入口</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象用于获取输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取物品的数量n和背包的最大承重v</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化两个数组，分别存储每个物品的重量和价值</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个物品的重量和价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            weights[i] = sc.nextInt(); <span class="comment">// 读取第i个物品的重量</span></span><br><span class="line">            values[i] = sc.nextInt(); <span class="comment">// 读取第i个物品的价值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个一维数组dp，长度为背包承重v加一，用于存储动态规划的状态</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[v + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划求解最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历每个物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v; j &gt;= weights[i]; j--) &#123; <span class="comment">// 对于每个物品，从背包承重最大的位置开始，逆向遍历到物品重量的位置</span></span><br><span class="line">                <span class="comment">// 更新dp数组中的最大价值</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出背包的最大价值</span></span><br><span class="line">        System.out.println(dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3.多重背包"></a>3.多重背包</h1><h2 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h2><p>你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 </p>
<p>给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。</p>
<h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。 </p>
<p>接下来的三行，每行包含 N 个正整数。具体如下： </p>
<p>第二行包含 N 个整数，表示 N 种矿石的重量。 </p>
<p>第三行包含 N 个整数，表示 N 种矿石的价格。 </p>
<p>第四行包含 N 个整数，表示 N 种矿石的可用数量上限。</p>
<h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表获取的最大价值。</p>
<h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">20</span> <span class="number">30</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure>
<h6 id="提示信息-2"><a href="#提示信息-2" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>1 &lt;= C &lt;= 10000;<br>1 &lt;= N &lt;= 10000;<br>1 &lt;= w[i], v[i], k[i] &lt;= 10000;</p>
<h2 id="3-2-题解"><a href="#3-2-题解" class="headerlink" title="3.2 题解"></a>3.2 题解</h2><h3 id="3-2-1-转化成01背包-滚动数组"><a href="#3-2-1-转化成01背包-滚动数组" class="headerlink" title="3.2.1 转化成01背包-滚动数组"></a>3.2.1 转化成01背包-滚动数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 导入Scanner类，用于读取控制台输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; <span class="comment">// 主类定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 主函数入口</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象用于获取输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取背包的最大容量c和物品的数量n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化三个数组，分别存储每个物品的重量、价值和数量上限</span></span><br><span class="line">        <span class="type">int</span>[] w = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] k = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个物品的重量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个物品的价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个物品的数量上限</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            k[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个一维数组dp，长度为背包容量c加一，用于存储动态规划的状态</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[c + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划求解最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历每个物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> c; j &gt;= w[i]; j--) &#123; <span class="comment">// 对于每个物品，从背包容量最大的位置开始，逆向遍历到物品重量的位置</span></span><br><span class="line">                <span class="comment">// 添加一个内层循环来处理数量上限</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; m &lt;= k[i] &amp;&amp; (j - m * w[i]) &gt;= <span class="number">0</span>; m++) &#123; <span class="comment">// 对于每个物品，尝试不同的数量m</span></span><br><span class="line">                    <span class="comment">// 更新dp数组中的最大价值</span></span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j - m * w[i]] + m * v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出背包的最大价值</span></span><br><span class="line">        System.out.println(dp[c]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最后一块石头的重量 II | LeetCode-1049 | 动态规划[. ]()</title>
    <url>/2024/10/02/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量 II<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：stones = <span class="comment">[2,7,4,1,8,1]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 <span class="comment">[2,7,1,8,1]</span>，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 <span class="comment">[2,1,1,1]</span>，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 <span class="comment">[1,1,1]</span>，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 <span class="comment">[1]</span>，这就是最优值。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：stones = <span class="string">[31,26,33,21,40]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li><p>划分两组：</p>
<ul>
<li><p>假设可以把所有的石头分成两组，设两组的重量分别为 <code>S1</code> 和 <code>S2</code>，其中 <code>S1 + S2 = total_weight</code>。目标是使 <code>|S1 - S2|</code> 尽可能小。</p>
</li>
<li><p>因为最后剩下的最小重量即为这两组重量的差值，所以我们希望使 <code>|S1 - S2|</code> 最小。根据公式，<code>|S1 - S2| = total_weight - 2 * S1</code>（假设 <code>S1 &lt;= S2</code>）。因此，我们要让 <code>S1</code> 尽可能接近 <code>total_weight / 2</code>，从而使 <code>|S1 - S2|</code> 最小。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-1-动态规划-滚动数组"><a href="#2-1-动态规划-滚动数组" class="headerlink" title="2.1 动态规划-滚动数组"></a>2.1 动态规划-滚动数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>秒股票的最佳时机系列 | LeetCode-121 | 动态规划</title>
    <url>/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-121-%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<h1 id="题目1：121-买卖股票的最佳时机"><a href="#题目1：121-买卖股票的最佳时机" class="headerlink" title="题目1：121. 买卖股票的最佳时机"></a>题目1：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第<span class="number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="number"> 5 </span>。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= prices.length &lt;= 10^5$</li>
<li>$0 &lt;= prices[i] &lt;= 10^4$</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h1 id="题目2：122-买卖股票的最佳时机-II"><a href="#题目2：122-买卖股票的最佳时机-II" class="headerlink" title="题目2：122. 买卖股票的最佳时机 II"></a>题目2：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第<span class="number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 5 </span>-<span class="number"> 1 </span>= 4。</span><br><span class="line">随后，在第<span class="number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 6 </span>-<span class="number"> 3 </span>= 3。</span><br><span class="line">最大总利润为<span class="number"> 4 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第<span class="number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 5 </span>-<span class="number"> 1 </span>= 4。</span><br><span class="line">最大总利润为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= prices.length &lt;= 3 * 10^4$</li>
<li>$0 &lt;= prices[i] &lt;= 10^4$</li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h1 id="题目3：123-买卖股票的最佳时机-III"><a href="#题目3：123-买卖股票的最佳时机-III" class="headerlink" title="题目3：123. 买卖股票的最佳时机 III"></a>题目3：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h1><h2 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第<span class="number"> 4 </span>天（股票价格 = 0）的时候买入，在第<span class="number"> 6 </span>天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 =<span class="number"> 3 </span>。</span><br><span class="line">     随后，在第<span class="number"> 7 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 8 </span>天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 =<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第<span class="number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="number"> 4 </span>。   </span><br><span class="line">     注意你不能在第<span class="number"> 1 </span>天和第<span class="number"> 2 </span>天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span> </span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：prices <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= prices.length &lt;= 10^5$</li>
<li>$0 &lt;= prices[i] &lt;= 10^5$</li>
</ul>
<h2 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h2><h1 id="题目4：188-买卖股票的最佳时机-IV"><a href="#题目4：188-买卖股票的最佳时机-IV" class="headerlink" title="题目4：188. 买卖股票的最佳时机 IV"></a>题目4：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h1><h2 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><h2 id="2-题解-3"><a href="#2-题解-3" class="headerlink" title="2.题解"></a>2.题解</h2><h1 id="题目5：309-买卖股票的最佳时机含冷冻期"><a href="#题目5：309-买卖股票的最佳时机含冷冻期" class="headerlink" title="题目5：309. 买卖股票的最佳时机含冷冻期"></a>题目5：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></h1><h2 id="1-题目描述-4"><a href="#1-题目描述-4" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: prices = [1,2,3,0,2]</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: prices = [1]</span></span><br><span class="line"><span class="section">输出: 0</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 5000</code></li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<h2 id="2-题解-4"><a href="#2-题解-4" class="headerlink" title="2.题解"></a>2.题解</h2><ul>
<li>图解：</li>
</ul>
<p><img src="./assets/image-20241015190852283.png" alt="image-20241015190852283"></p>
<h3 id="2-1-动态规划-二维数组"><a href="#2-1-动态规划-二维数组" class="headerlink" title="2.1 动态规划-二维数组"></a>2.1 动态规划-二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// dp数组，用于记录在不同状态下的最大利润</span></span><br><span class="line">        <span class="comment">// dp[i][0] 表示第i天结束时，持有股票的状态</span></span><br><span class="line">        <span class="comment">// dp[i][1] 表示第i天结束时，未持有股票，且未卖出股票的状态</span></span><br><span class="line">        <span class="comment">// dp[i][2] 表示第i天结束时，今天卖出股票的状态</span></span><br><span class="line">        <span class="comment">// dp[i][3] 表示第i天结束时，处于冷冻期的状态（即今天不能买股票的状态）</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第1天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 买入股票，成本是prices[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 第一天未持有股票，且未进行任何操作，所以利润为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;          <span class="comment">// 第一天无法卖出，所以利润为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;          <span class="comment">// 第一天不可能处于冷冻期，利润为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第2天开始更新dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 第i天结束时持有股票，可能是前一天已经持有股票（dp[i-1][0]），</span></span><br><span class="line">            <span class="comment">// 或者今天买入股票（从dp[i-1][1]或dp[i-1][3]减去今天的股价）。</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i-<span class="number">1</span>][<span class="number">3</span>] - prices[i]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天结束时未持有股票，且未卖出股票的状态，可能是前一天未持有股票（dp[i-1][1]），</span></span><br><span class="line">            <span class="comment">// 或者前一天处于冷冻期（dp[i-1][3]）。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天卖出股票，利润等于前一天持有股票的状态加上今天的股价</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天结束时处于冷冻期的状态，意味着前一天卖出了股票（dp[i-1][2]）。</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一天的最大利润，可以是未持有股票的状态（dp[prices.length-1][1]），</span></span><br><span class="line">        <span class="comment">// 或者今天卖出股票的状态（dp[prices.length-1][2]），</span></span><br><span class="line">        <span class="comment">// 也可以是处于冷冻期的状态（dp[prices.length-1][3]）。</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">1</span>], Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">2</span>], dp[prices.length-<span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划-二维数组优化"><a href="#2-2-动态规划-二维数组优化" class="headerlink" title="2.2 动态规划-二维数组优化"></a>2.2 动态规划-二维数组优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// 使用滚动数组优化空间复杂度，将原本的dp数组简化为只有2行</span></span><br><span class="line">        <span class="comment">// dp[i % 2][0] 表示第i天结束时，持有股票的状态</span></span><br><span class="line">        <span class="comment">// dp[i % 2][1] 表示第i天结束时，未持有股票，且未卖出股票的状态</span></span><br><span class="line">        <span class="comment">// dp[i % 2][2] 表示第i天结束时，今天卖出股票的状态</span></span><br><span class="line">        <span class="comment">// dp[i % 2][3] 表示第i天结束时，处于冷冻期的状态</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第1天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 买入股票，成本是prices[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 第一天未持有股票，且未进行任何操作，所以利润为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;          <span class="comment">// 第一天无法卖出股票，利润为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;          <span class="comment">// 第一天不可能处于冷冻期，利润为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第2天开始更新dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用滚动数组，dp[i % 2] 表示第i天的状态，dp[(i - 1) % 2] 表示第i-1天的状态</span></span><br><span class="line">            <span class="comment">// 第i天结束时持有股票，可能是前一天已经持有股票（dp[(i - 1) % 2][0]），</span></span><br><span class="line">            <span class="comment">// 或者今天买入股票（从dp[(i - 1) % 2][1]或dp[(i - 1) % 2][3]减去今天的股价）。</span></span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>],</span><br><span class="line">                    Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] - prices[i], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">3</span>] - prices[i]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天结束时未持有股票，且未卖出股票，可能是前一天未持有股票（dp[(i - 1) % 2][1]），</span></span><br><span class="line">            <span class="comment">// 或者前一天处于冷冻期（dp[(i - 1) % 2][3]）。</span></span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天卖出股票，利润等于前一天持有股票的状态加上今天的股价。</span></span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">2</span>] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天处于冷冻期，意味着前一天卖出了股票（dp[(i - 1) % 2][2]）。</span></span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">3</span>] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一天的最大利润，可以是未持有股票的状态（dp[(n - 1) % 2][1]），</span></span><br><span class="line">        <span class="comment">// 或者今天卖出股票的状态（dp[(n - 1) % 2][2]），</span></span><br><span class="line">        <span class="comment">// 也可以是处于冷冻期的状态（dp[(n - 1) % 2][3]）。</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], Math.max(dp[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">2</span>], dp[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-动态规划-一维数组"><a href="#2-3-动态规划-一维数组" class="headerlink" title="2.3 动态规划-一维数组"></a>2.3 动态规划-一维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// dp数组用来记录四种状态下的最大利润</span></span><br><span class="line">        <span class="comment">// dp[0] 表示持有股票的状态</span></span><br><span class="line">        <span class="comment">// dp[1] 表示未持有股票且未卖出股票的状态</span></span><br><span class="line">        <span class="comment">// dp[2] 表示今天卖出股票的状态</span></span><br><span class="line">        <span class="comment">// dp[3] 表示处于冷冻期的状态</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第1天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 买入股票，成本是prices[0]</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 第一天未持有股票，且未进行任何操作，利润为0</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">0</span>;          <span class="comment">// 第一天不能卖出股票，利润为0</span></span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">0</span>;          <span class="comment">// 第一天不可能处于冷冻期，利润为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第2天开始更新dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 临时保存上一天的dp[0]和dp[2]的值，用于计算新的状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> dp[<span class="number">0</span>]; <span class="comment">// 昨天持有股票的状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> dp[<span class="number">2</span>]; <span class="comment">// 昨天卖出股票的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算今天持有股票的状态，可能是昨天已经持有股票(dp[0])，</span></span><br><span class="line">            <span class="comment">// 或者今天买入股票（从未持有状态dp[1]或冷冻期dp[3]减去今天的股价）。</span></span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], Math.max(dp[<span class="number">1</span>] - prices[i], dp[<span class="number">3</span>] - prices[i]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算今天未持有股票且未卖出的状态，可能是昨天未持有股票(dp[1])，</span></span><br><span class="line">            <span class="comment">// 或者昨天处于冷冻期(dp[3])。</span></span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算今天卖出股票的状态，等于昨天持有股票的状态加上今天的股价。</span></span><br><span class="line">            dp[<span class="number">2</span>] = temp1 + prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算今天处于冷冻期的状态，等于昨天卖出股票的状态。</span></span><br><span class="line">            dp[<span class="number">3</span>] = temp2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一天的最大利润，可能是未持有股票的状态(dp[1])，</span></span><br><span class="line">        <span class="comment">// 或者今天卖出股票的状态(dp[2])，或者处于冷冻期的状态(dp[3])。</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">1</span>], Math.max(dp[<span class="number">2</span>], dp[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目6：714-买卖股票的最佳时机含手续费"><a href="#题目6：714-买卖股票的最佳时机含手续费" class="headerlink" title="题目6：714. 买卖股票的最佳时机含手续费"></a>题目6：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h1><h2 id="1-题目描述-5"><a href="#1-题目描述-5" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="comment">[1, 3, 2, 8, 4, 9]</span>, fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices<span class="comment">[0]</span> = 1</span><br><span class="line">在此处卖出 prices<span class="comment">[3]</span> = 8</span><br><span class="line">在此处买入 prices<span class="comment">[4]</span> = 4</span><br><span class="line">在此处卖出 prices<span class="comment">[5]</span> = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：prices = <span class="string">[1,3,7,5,10,3]</span>, fee = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= prices.length &lt;= 5 * 10^4$</li>
<li>$1 &lt;= prices[i] &lt; 5 * 10^4$</li>
<li>$0 &lt;= fee &lt; 5 * 10^4$</li>
</ul>
<h2 id="2-题解-5"><a href="#2-题解-5" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-二维数组-1"><a href="#2-1-动态规划-二维数组-1" class="headerlink" title="2.1 动态规划-二维数组"></a>2.1 动态规划-二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义dp数组，其中dp[i][0]表示第i天持有股票的状态下的最大利润</span></span><br><span class="line">        <span class="comment">// dp[i][1]表示第i天未持有股票的状态下的最大利润</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第1天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第一天买入股票，初始利润为 -prices[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 第一天没有卖出股票，利润为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第2天开始计算每一天的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 第i天持有股票的最大利润：</span></span><br><span class="line">            <span class="comment">// 1. 可以选择不买入，保持前一天持有股票的状态（dp[i-1][0]）</span></span><br><span class="line">            <span class="comment">// 2. 也可以选择今天买入股票（前一天未持有股票的利润减去今天的股价：dp[i-1][1] - prices[i]）</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天未持有股票的最大利润：</span></span><br><span class="line">            <span class="comment">// 1. 可以选择不卖出，保持前一天未持有股票的状态（dp[i-1][1]）</span></span><br><span class="line">            <span class="comment">// 2. 也可以选择今天卖出股票（前一天持有股票的利润加上今天的股价，减去交易费：dp[i-1][0] + prices[i] - fee）</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终返回的是最后一天未持有股票的最大利润，即dp[prices.length - 1][1]</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划-二维数组优化-1"><a href="#2-2-动态规划-二维数组优化-1" class="headerlink" title="2.2 动态规划-二维数组优化"></a>2.2 动态规划-二维数组优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第1天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第一天买入股票，初始利润为 -prices[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 第一天没有卖出股票，利润为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第2天开始计算每一天的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-动态规划-一维数组-1"><a href="#2-3-动态规划-一维数组-1" class="headerlink" title="2.3 动态规划-一维数组"></a>2.3 动态规划-一维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义dp数组，其中dp[0]表示持有股票时的最大利润</span></span><br><span class="line">        <span class="comment">// dp[1]表示未持有股票时的最大利润</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第1天的状态</span></span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第一天买入股票，初始利润为 -prices[0]</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;          <span class="comment">// 第一天没有卖出股票，利润为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第2天开始计算每一天的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 第i天持有股票的最大利润：</span></span><br><span class="line">            <span class="comment">// 1. 可以选择不买入，保持前一天持有股票的状态（dp[0]）</span></span><br><span class="line">            <span class="comment">// 2. 也可以选择今天买入股票，前一天未持有股票的利润减去今天的股价（dp[1] - prices[i]）</span></span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天未持有股票的最大利润：</span></span><br><span class="line">            <span class="comment">// 1. 可以选择不卖出，保持前一天未持有股票的状态（dp[1]）</span></span><br><span class="line">            <span class="comment">// 2. 也可以选择今天卖出股票，前一天持有股票的利润加上今天的股价，减去交易费（dp[0] + prices[i] - fee）</span></span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终返回的是最后一天未持有股票的最大利润，即dp[1]</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和IV | LeetCode-377 | 动态规划</title>
    <url>/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>





<h1 id="题目1：198-打家劫舍"><a href="#题目1：198-打家劫舍" class="headerlink" title="题目1：198. 打家劫舍"></a>题目1：<a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃<span class="number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="number"> 3 </span>号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 =<span class="number"> 1 </span>+<span class="number"> 3 </span>=<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃<span class="number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="number"> 5 </span>号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 =<span class="number"> 2 </span>+<span class="number"> 9 </span>+<span class="number"> 1 </span>=<span class="number"> 12 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个公共方法rob，用来计算打劫非相邻房屋可以获得的最大金额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个动态规划数组dp，长度等于输入数组nums的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果只有一个房屋，那么最大金额就是这个房屋里的金额</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有两个房屋，选择金额较大的那个房屋</span></span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第三个房屋开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 对于每个房屋i，有两种选择：</span></span><br><span class="line">            <span class="comment">// 1. 不打劫房屋i，那么前一步的最大金额保持不变，即dp[i-1]</span></span><br><span class="line">            <span class="comment">// 2. 打劫房屋i，那么当前的最大金额为前两步的最大金额加上当前房屋的金额，即dp[i-2] + nums[i]</span></span><br><span class="line">            <span class="comment">// 取两种情况下的最大值作为dp[i]的值</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最后一个房屋的最大金额</span></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：213-打家劫舍-II"><a href="#题目2：213-打家劫舍-II" class="headerlink" title="题目2：213. 打家劫舍 II"></a>题目2：<a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃<span class="number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃<span class="number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="number"> 3 </span>号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 =<span class="number"> 1 </span>+<span class="number"> 3 </span>=<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,3]</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 Solution 的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主方法，用于计算能够偷窃的最大金额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果输入数组为空或长度为0，则表示没有房子可以偷，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果只有一个房子，直接返回该房子的金额</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别计算两种情况下的最大可偷金额：</span></span><br><span class="line">        <span class="comment">// 第一种情况：不偷最后一个房子，从第一个到最后第二个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> robRange(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 第二种情况：不偷第一个房子，从第二个到最后一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> robRange(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回两种情况下较大的金额</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法，用于计算从 start 到 end 范围内房间的最大可偷金额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果开始和结束位置相同，表示只有一个房子，直接返回该房子的金额</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="comment">// 初始化动态规划数组，长度与输入数组相同</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 填充初始条件</span></span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从第三个房子开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态规划状态转移方程：当前房子的收益等于前天（i-2）的最大收益加上当前房子的价值，</span></span><br><span class="line">            <span class="comment">// 或者昨天（i-1）的最大收益（即不偷当前房子）</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后一个房子位置处的最大可偷金额</span></span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目3：337-打家劫舍-III"><a href="#题目3：337-打家劫舍-III" class="headerlink" title="题目3：337. 打家劫舍 III"></a>题目3：<a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h1><h2 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <strong>*在不触动警报的情况下</strong> ，小偷能够盗取的最高金额* 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="img"></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: root = [3,2,3,null,3,null,1]</span><br><span class="line">输出:<span class="number"> 7 </span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额<span class="number"> 3 </span>+<span class="number"> 3 </span>+<span class="number"> 1 </span>= 7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt="img"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: root = [3,4,5,1,3,null,1]</span></span><br><span class="line"><span class="section">输出: 9</span></span><br><span class="line"><span class="section">解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树的节点数在 $[1, 10^4]$ 范围内</li>
<li>$0 &lt;= Node.val &lt;= 10^4$</li>
</ul>
<h2 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-递归-超时"><a href="#2-1-递归-超时" class="headerlink" title="2.1 递归-超时"></a>2.1 递归-超时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            money += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            money += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(money,rob(root.left)+rob(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-记忆化递归"><a href="#2-2-记忆化递归" class="headerlink" title="2.2 记忆化递归"></a>2.2 记忆化递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归优化</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root)) <span class="keyword">return</span> map.get(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money1</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            money1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            money1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money2</span> <span class="operator">=</span> rob(root.left)+rob(root.right);</span><br><span class="line"></span><br><span class="line">        map.put(root,Math.max(money1,money2));</span><br><span class="line">        <span class="keyword">return</span> Math.max(money1,money2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-动态规划"><a href="#2-3-动态规划" class="headerlink" title="2.3 动态规划"></a>2.3 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主方法，计算以 root 为根的二叉树能抢劫的最大金额。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 树的根节点。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回能抢劫的最大金额。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算从根节点开始的子树抢劫策略</span></span><br><span class="line">        <span class="type">int</span>[] result = robTree(root);</span><br><span class="line">        <span class="comment">// 返回偷或不偷根节点时的最大金额</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 辅助递归方法，计算从 cur 节点开始的子树的最佳抢劫策略。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur 当前节点。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个数组，其中 result[0] 是不偷当前节点的最大金额，result[1] 是偷当前节点的最大金额。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] robTree(TreeNode cur) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，直接返回不偷也不抢的情况</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树的抢劫策略</span></span><br><span class="line">        <span class="type">int</span>[] left = robTree(cur.left);</span><br><span class="line">        <span class="type">int</span>[] right = robTree(cur.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷当前节点，那么它的左右子节点都不能偷</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money1</span> <span class="operator">=</span> cur.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不偷当前节点，那么其左右子节点可以选择偷或不偷</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money2</span> <span class="operator">=</span> Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前节点的最优策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;money2, money1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单词拆分 | LeetCode-139 | 动态规划</title>
    <url>/2024/10/08/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/word-break/">139. 单词拆分<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以由 <span class="string">&quot;leet&quot;</span> 和 <span class="string">&quot;code&quot;</span> 拼接成。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;applepenapple&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;applepenapple&quot;</span> 可以由 <span class="string">&quot;apple&quot;</span> <span class="string">&quot;pen&quot;</span> <span class="string">&quot;apple&quot;</span> 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;catsandog&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;cats&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;sand&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;cat&quot;</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li>
<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划-滚动数组"><a href="#2-1-动态规划-滚动数组" class="headerlink" title="2.1 动态规划-滚动数组"></a>2.1 动态规划-滚动数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个公共的方法wordBreak，接收两个参数：一个字符串s和一个字符串列表wordDict</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个布尔类型的数组dp，长度为s的长度+1</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将dp的第一个元素设置为true，表示空字符串可以被构造</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层循环从1开始到s的长度，代表字符串的可能结尾位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 内层循环遍历wordDict中的所有单词</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wordDict.size(); j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取当前字典中的单词</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> wordDict.get(j);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取当前单词的长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查当前单词是否可以从字符串s的子串中找到</span></span><br><span class="line">                <span class="comment">// 条件：i必须大于等于当前单词的长度，前缀部分可以被构造，且当前单词与相应位置的子串相等</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= len &amp;&amp; dp[i - len] &amp;&amp; str.equals(s.substring(i - len, i))) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果条件满足，将dp[i]设置为true，并跳出内层循环</span></span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回dp[s.length()]，表示整个字符串s是否可以由wordDict中的单词构成</span></span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数 | LeetCode-279 | 动态规划</title>
    <url>/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 =<span class="number"> 4 </span>+<span class="number"> 4 </span>+ 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">13</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划-滚动数组"><a href="#2-1-动态规划-滚动数组" class="headerlink" title="2.1 动态规划-滚动数组"></a>2.1 动态规划-滚动数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度为 n + 1 的动态规划数组 dp，dp[i] 表示组成数字 i 的最小完全平方数数量</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 dp 数组，dp[0] = 0，其他位置初始为最大值，表示初始时无法组成这些值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历从 0 到 n 的每个数 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 对于每个数 i，尝试减去一个完全平方数 j * j (j 从 1 开始)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp[i]，取最小的完全平方数数量</span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回组成数字 n 的最小完全平方数数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和IV | LeetCode-377 | 动态规划</title>
    <url>/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>





<h1 id="题目1：300-最长递增子序列"><a href="#题目1：300-最长递增子序列" class="headerlink" title="题目1：300. 最长递增子序列"></a>题目1：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10,9,2,5</span>,<span class="number">3,7,101,18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2,3,7,101</span>]，因此长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[0,1,0,3,2,3]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[7,7,7,7,7,7,7]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-错解"><a href="#2-1-动态规划-错解" class="headerlink" title="2.1 动态规划-错解"></a>2.1 动态规划-错解</h3><ul>
<li>这样求解的是<strong>以nums[nums.length-1]结尾的最长递增子序列的长度</strong>，题目要求的是全局的，最后一个不一定是全局最长递增子序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划-正解"><a href="#2-2-动态规划-正解" class="headerlink" title="2.2 动态规划-正解"></a>2.2 动态规划-正解</h3><ul>
<li>思路：<ul>
<li><strong>初始化</strong>：创建一个长度与输入数组相同的动态规划数组 <code>dp</code>，每个元素初始化为1。这表示每个元素至少可以构成长度为1的递增子序列（即它自身）。</li>
<li><strong>遍历</strong>：从数组的第二个元素开始，对每个元素进行遍历。</li>
<li><strong>比较</strong>：对于当前遍历到的元素，与它之前的所有元素进行比较。</li>
<li><strong>更新</strong>：如果当前元素比前面的元素大，说明有潜力构成更长的递增子序列。更新 <code>dp</code> 数组，<code>dp[i]</code> 表示以第 <code>i</code> 个元素结尾的最长递增子序列的长度。</li>
<li><strong>记录</strong>：在更新 <code>dp</code> 数组的同时，记录下遍历过程中找到的最长递增子序列的长度。</li>
<li><strong>返回结果</strong>：遍历结束后，<code>dp</code> 数组中的最大值即为整个数组的最长递增子序列的长度。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 创建一个长度与nums相同的数组，用于动态规划</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化dp数组，每个元素的值都设为1</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 初始化结果变量，用于记录最长递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 对于每个元素nums[i]，遍历其之前的所有元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">// 如果当前元素大于之前的元素nums[j]，则更新dp[i]的值</span></span><br><span class="line">                <span class="comment">// dp[i]表示以nums[i]结尾的最长递增子序列的长度</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果变量，记录遍历过程中找到的最长递增子序列的长度</span></span><br><span class="line">            result = Math.max(dp[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果变量，即整个数组的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-贪心-二分查找"><a href="#2-3-贪心-二分查找" class="headerlink" title="2.3 贪心 + 二分查找"></a>2.3 贪心 + 二分查找</h3><ul>
<li>核心逻辑：<ol>
<li>使用 <code>dp</code> 数组来存储递增子序列的最小结尾元素，以此动态更新递增子序列的长度。</li>
<li>每次遍历新元素时，如果新元素比当前最长递增子序列的末尾元素大，直接将其追加在 <code>dp</code> 的末尾；否则通过二分查找找到一个可以替换的元素，保持 <code>dp</code> 中递增子序列的最小性。</li>
<li>最终，<code>result</code> 记录了最长递增子序列的长度。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 用于记录最长递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 动态规划数组，dp[i] 表示长度为 i 的递增子序列的末尾元素的最小值</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化 dp 数组的第一个元素为 nums[0]</span></span><br><span class="line">        dp[result] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素大于 dp 中已知的最长递增子序列的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; dp[result]) &#123;</span><br><span class="line">                <span class="comment">// 递增子序列的长度加 1</span></span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 更新 dp 数组，记录新的最长递增子序列的最后一个元素</span></span><br><span class="line">                dp[result] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素小于或等于 dp 中已知的最长递增子序列的最后一个元素，</span></span><br><span class="line">                <span class="comment">// 我们需要找到 dp 中大于等于 nums[i] 的最小元素进行替换，以维持 dp 的有序性</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = result, pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进行二分查找，找到第一个大于等于 nums[i] 的位置</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 找到 dp 中大于等于 nums[i] 的最靠左的元素的索引</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &lt;= dp[mid]) &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用 nums[i] 更新 dp 数组中第一个大于等于它的位置</span></span><br><span class="line">                dp[left] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>实例打印：</p>
<ul>
<li><p>输入：<code>&#123;1, 2, 3, 5, 6, 4&#125;</code></p>
</li>
<li><p>输出dp数组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 0, 0, 0, 0]</span><br><span class="line">[0, 1, 2, 3, 0, 0, 0]</span><br><span class="line">[0, 1, 2, 3, 5, 0, 0]</span><br><span class="line">[0, 1, 2, 3, 5, 6, 0]</span><br><span class="line">[0, 1, 2, 3, 4, 6, 0]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="题目2：674-最长连续递增序列"><a href="#题目2：674-最长连续递增序列" class="headerlink" title="题目2：674. 最长连续递增序列"></a>题目2：<a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,3,5,4,7]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 <span class="comment">[1,3,5]</span>, 长度为3。</span><br><span class="line">尽管 <span class="comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,2,2,2,2]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 <span class="comment">[2]</span>, 长度为1。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><ul>
<li>思路：<ul>
<li><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长连续递增子序列长度。</li>
<li>遍历数组，每次遇到比前一个元素大的数时，将当前 <code>dp[i]</code> 更新为 <code>dp[i-1] + 1</code>，否则保持不变。</li>
<li>最终返回 <code>result</code>，即数组中的最长连续递增子序列长度。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 动态规划数组 dp，dp[i] 表示以 nums[i] 结尾的最长连续递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 结果变量 result 用于存储最长连续递增子序列的长度，初始化为 1，因为最短子序列长度为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化 dp 数组，所有元素的初始值都是 1，因为单个元素也是长度为 1 的递增子序列</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 遍历数组，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素 nums[i] 大于前一个元素 nums[i-1]，说明它可以延续递增子序列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) </span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 将 dp[i] 更新为 dp[i-1] 加 1</span></span><br><span class="line">            <span class="comment">// 更新结果 result，取 result 和 dp[i] 的最大值</span></span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最终结果，即最长连续递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-贪心算法-amp-双指针-amp-滑动窗口"><a href="#2-2-贪心算法-amp-双指针-amp-滑动窗口" class="headerlink" title="2.2 贪心算法 &amp; 双指针 &amp; 滑动窗口"></a>2.2 贪心算法 &amp; 双指针 &amp; 滑动窗口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心算法 &amp; 双指针 &amp; 滑动窗口方法</span></span><br><span class="line">        <span class="comment">// 左指针初始化为数组的第一个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 结果变量 result，用于存储最长连续递增子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右指针从数组的第一个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于或等于前一个元素，重置左指针到当前元素位置</span></span><br><span class="line">            <span class="comment">// 这是因为连续递增子序列必须是严格递增的</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; nums[right] &lt;= nums[right - <span class="number">1</span>]) </span><br><span class="line">                left = right;</span><br><span class="line">            <span class="comment">// 更新结果 result，计算当前窗口（从 left 到 right）的长度并取最大值</span></span><br><span class="line">            result = Math.max(result, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长连续递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目3：718-最长重复子数组"><a href="#题目3：718-最长重复子数组" class="headerlink" title="题目3：718. 最长重复子数组"></a>题目3：<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h1><h2 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2,3,2,1]</span>, nums2 = <span class="comment">[3,2,1,4,7]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 <span class="comment">[3,2,1]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[0,0,0,0,0]</span>, nums2 = <span class="string">[0,0,0,0,0]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
<h2 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力解法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i + subLength &lt; n &amp;&amp; j + subLength &lt; m &amp;&amp; nums1[i+ subLength] == nums2[j + subLength])&#123;</span><br><span class="line">                        subLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = Math.max(subLength,result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划-二维数组"><a href="#2-2-动态规划-二维数组" class="headerlink" title="2.2 动态规划-二维数组"></a>2.2 动态规划-二维数组</h3><ul>
<li>思路：<ul>
<li><strong>二维动态规划</strong>：定义 <code>dp[i][j]</code> 表示以 <code>nums1[i-1]</code> 和 <code>nums2[j-1]</code> 结尾的最长重复子数组的长度。</li>
<li><strong>状态转移方程</strong>：如果 <code>nums1[i-1] == nums2[j-1]</code>，那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，表示当前两个数组的元素相等，长度可以在之前的基础上加 1。</li>
<li><strong>结果维护</strong>：每次更新 <code>dp[i][j]</code> 时，比较当前最长的重复子数组长度 <code>result</code>，并存储最大的长度。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划 - 使用二维数组</span></span><br><span class="line">        <span class="comment">// n 表示 nums1 的长度，m 表示 nums2 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示以 nums1[i-1] 和 nums2[j-1] 结尾的最长重复子数组的长度</span></span><br><span class="line">        <span class="comment">// 使用 n+1 和 m+1 来处理边界情况，即考虑当 i 或 j 为 0 时的状态，dp[0][*] 或 dp[*][0] 默认初始化为 0</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化最长重复子数组的长度为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历 nums1 和 nums2，填充 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1[i-1] 等于 nums2[j-1]，说明可以在前面的基础上继续增加子数组长度</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// dp[i][j] 等于 dp[i-1][j-1] + 1，表示当前元素相同，最长子数组长度加 1</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每次更新 result，保存当前最长的子数组长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长重复子数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目4：1143-最长公共子序列"><a href="#题目4：1143-最长公共子序列" class="headerlink" title="题目4：1143. 最长公共子序列"></a>题目4：<a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><h2 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abcde&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">text1</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">text2</span> = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<h2 id="2-题解-3"><a href="#2-题解-3" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-二维数组"><a href="#2-1-动态规划-二维数组" class="headerlink" title="2.1 动态规划-二维数组"></a>2.1 动态规划-二维数组</h3><ul>
<li>思路：<ul>
<li><strong>动态规划二维表</strong>：<code>dp[i][j]</code> 表示 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列长度。</li>
<li>状态转移方程：<ul>
<li>如果当前字符相同（<code>text1[i-1] == text2[j-1]</code>），则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，表示在前一个状态基础上增加一个相同字符。</li>
<li>如果当前字符不同，则 <code>dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])</code>，表示取不相等情况下的最大公共子序列长度。</li>
</ul>
</li>
<li><strong>结果维护</strong>：在遍历过程中，每次计算出 <code>dp[i][j]</code> 后，将其与 <code>result</code> 比较并更新，确保 <code>result</code> 保持为当前最大值。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 text1 和 text2 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 result 变量，用于保存最终最长公共子序列的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 dp 二维数组，dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列长度</span></span><br><span class="line">        <span class="comment">// dp[0][*] 和 dp[*][0] 初始化为 0，表示空字符串与其他字符串的最长公共子序列长度为 0</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双层循环遍历 text1 和 text2 的所有字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 取出当前遍历的字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>); <span class="comment">// text1 的第 i 个字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>); <span class="comment">// text2 的第 j 个字符</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果两个字符相同，则最长公共子序列可以在 dp[i-1][j-1] 的基础上加 1</span></span><br><span class="line">                <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 如果两个字符不相同，则最长公共子序列等于 dp[i-1][j] 和 dp[i][j-1] 的最大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新 result，保存最长的公共子序列长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果，即最长公共子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="题目5：1035-不相交的线"><a href="#题目5：1035-不相交的线" class="headerlink" title="题目5：1035. 不相交的线"></a>题目5：<a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h1><h2 id="1-题目描述-4"><a href="#1-题目描述-4" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom: 25%;" /></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 <span class="symbol">nums1</span>[<span class="number">1</span>]=<span class="number">4</span> 到 <span class="symbol">nums2</span>[<span class="number">2</span>]=<span class="number">4</span> 的直线将与从 <span class="symbol">nums1</span>[<span class="number">2</span>]=<span class="number">2</span> 到 <span class="symbol">nums2</span>[<span class="number">1</span>]=<span class="number">2</span> 的直线相交。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[2,5,1,2,5]</span>, nums2 = <span class="string">[10,5,2,1,5,2]</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[1,3,7,1,7,5]</span>, nums2 = <span class="string">[1,9,2,5,1]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>
</ul>
<h2 id="2-题解-4"><a href="#2-题解-4" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-1"><a href="#2-1-动态规划-1" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">// 此问题可以转化为经典的最长公共子序列（LCS）问题</span></span><br><span class="line">        <span class="comment">// nums1 和 nums2 分别表示两个数组</span></span><br><span class="line">        <span class="comment">// n 和 m 分别表示 nums1 和 nums2 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个大小为 (n+1) x (m+1) 的二维数组 dp，用于存储中间计算结果</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示在 nums1 的前 i 个元素和 nums2 的前 j 个元素中，最长的公共子序列长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结果变量 result 用于存储最终的最长不相交线的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用动态规划填充 dp 表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1[i-1] 和 nums2[j-1] 相等，则说明它们可以作为一条不相交的线</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// dp[i][j] 等于 dp[i-1][j-1] + 1，即将前一个位置的公共子序列长度加 1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则，dp[i][j] 等于 dp[i-1][j] 和 dp[i][j-1] 中的较大者</span></span><br><span class="line">                    <span class="comment">// 即选择不加入当前元素时的最长子序列长度</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新结果，保持 result 为当前遇到的最大公共子序列长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终的最长不相交线的长度</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目变体："><a href="#题目变体：" class="headerlink" title="题目变体："></a>题目变体：</h2><h3 id="1-限制连接的距离"><a href="#1-限制连接的距离" class="headerlink" title="1. 限制连接的距离"></a>1. <strong>限制连接的距离</strong></h3><ul>
<li><strong>问题变形</strong>：要求两条线段（元素之间的匹配）之间的距离不能超过 <code>k</code>（即 <code>nums1[i]</code> 和 <code>nums2[j]</code> 匹配时，<code>|i - j| &lt;= k</code>）。</li>
<li><strong>解法</strong>：在原有的动态规划方案基础上，增加对距离的限制。也就是在计算 <code>dp[i][j]</code> 时，只有满足 <code>|i - j| &lt;= k</code> 的情况下，才能更新 <code>dp[i][j]</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, i - k); j &lt;= Math.min(m, i + k); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变动点</strong>：在双重循环里，对 <code>j</code> 进行了限制，使得它只能在 <code>i - k</code> 和 <code>i + k</code> 范围内搜索。</p>
<h3 id="2-最小化交叉线的数量"><a href="#2-最小化交叉线的数量" class="headerlink" title="2. 最小化交叉线的数量"></a>2. <strong>最小化交叉线的数量</strong></h3><ul>
<li><strong>问题变形</strong>：要求不仅要计算不相交的线数，还要求最小化交叉线的数量。</li>
<li><strong>解法</strong>：将问题从最大化不相交线的数量转换为最小化交叉线。可以通过增加一个计数器来记录交叉线的数量，并基于 <code>dp</code> 的方式，在更新 <code>dp[i][j]</code> 时记录那些产生交叉的情况。</li>
</ul>
<p>解法思路：将匹配的路径记录下来，交叉线可以根据路径上的线段是否互相交叉来判断。</p>
<h3 id="3-给定匹配值的不同权重"><a href="#3-给定匹配值的不同权重" class="headerlink" title="3. 给定匹配值的不同权重"></a>3. <strong>给定匹配值的不同权重</strong></h3><ul>
<li><strong>问题变形</strong>：两个数组中的元素匹配时，有不同的权重，要求最大化匹配线段的权重和，而不仅仅是匹配的数量。</li>
<li><strong>解法</strong>：在 <code>dp</code> 数组中存储权重和而不是匹配的数量。当 <code>nums1[i-1] == nums2[j-1]</code> 时，不是简单地加 <code>1</code>，而是加上它们的匹配权重值（可以提前给定的权重函数）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxWeightedUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[][] weights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 使用给定的权重值代替简单的 +1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + weights[nums1[i-<span class="number">1</span>]][nums2[j-<span class="number">1</span>]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变动点</strong>：这里加入了 <code>weights</code> 矩阵，代表不同元素匹配的权重，动态规划时会选择权重和最大的匹配方案。</p>
<h3 id="4-不允许某些特定匹配"><a href="#4-不允许某些特定匹配" class="headerlink" title="4. 不允许某些特定匹配"></a>4. <strong>不允许某些特定匹配</strong></h3><ul>
<li><strong>问题变形</strong>：要求有些元素不能匹配，例如给定一组禁用的匹配对 <code>(x, y)</code>，<code>nums1</code> 中的元素 <code>x</code> 不能和 <code>nums2</code> 中的元素 <code>y</code> 匹配。</li>
<li><strong>解法</strong>：在进行动态规划时，提前将这些禁止的匹配对存入一个哈希表，在判断 <code>nums1[i-1]</code> 和 <code>nums2[j-1]</code> 是否相等时，同时检查它们是否在禁用对中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, Set&lt;Pair&lt;Integer, Integer&gt;&gt; bannedPairs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                Pair&lt;Integer, Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>] &amp;&amp; !bannedPairs.contains(pair)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变动点</strong>：增加一个禁用匹配对的集合，在动态规划时排除不允许的匹配。</p>
<h3 id="5-求解两数组中部分元素的最大不相交线"><a href="#5-求解两数组中部分元素的最大不相交线" class="headerlink" title="5. 求解两数组中部分元素的最大不相交线"></a>5. <strong>求解两数组中部分元素的最大不相交线</strong></h3><ul>
<li><strong>问题变形</strong>：不是要求整个数组，而是要求找出两个子数组（或从原数组中任意挑选的若干元素）之间的最大不相交线数。</li>
<li><strong>解法</strong>：在原有的 <code>dp</code> 方法基础上，可以额外维护一个可以选择的元素集合或对两数组进行部分切割，动态规划求解部分区间的最长公共子序列。</li>
</ul>
<h1 id="题目6：53-最大子数组和"><a href="#题目6：53-最大子数组和" class="headerlink" title="题目6：53. 最大子数组和"></a>题目6：<a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><h2 id="1-题目描述-5"><a href="#1-题目描述-5" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,<span class="string">-1</span>,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[5,4,-1,7,8]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="2-题解-5"><a href="#2-题解-5" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-暴力解法-1"><a href="#2-1-暴力解法-1" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力解法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                result = Math.max(result,sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-贪心算法"><a href="#2-2-贪心算法" class="headerlink" title="2.2 贪心算法"></a>2.2 贪心算法</h3><ul>
<li>思路：<ul>
<li>在遍历数组的过程中，维护一个当前子数组的和 <code>sum</code>。</li>
<li>每次将当前元素加入到 <code>sum</code> 中，如果 <code>sum</code> 变为负数，则抛弃当前的子数组（即重置 <code>sum</code> 为 0），因为负数只会减少后续子数组的和。</li>
<li>同时在每一步更新记录最大子数组和的变量 <code>result</code>，确保记录遍历到的最大子数组和。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化结果为整数的最小值，表示子数组的最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 初始化当前子数组的和为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素加入当前子数组的和</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">// 更新最大子数组的和，比较当前的和与之前记录的最大值</span></span><br><span class="line">            result = Math.max(result, sum);</span><br><span class="line">            <span class="comment">// 如果当前子数组的和为负数，则将和重置为0（贪心策略：负数会降低后面的和）</span></span><br><span class="line">            sum = Math.max(sum, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大子数组和</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3-动态规划"><a href="#2-3-动态规划" class="headerlink" title="2.3 动态规划"></a>2.3 动态规划</h3><ul>
<li>思路：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义 dp 数组，dp[i] 表示以第 i 个元素结尾的子数组的最大和</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 初始化 dp[0]，即以第一个元素结尾的子数组最大和就是该元素本身</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 初始化 result，保存最终结果，初始值为第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程：dp[i] 表示以 nums[i] 结尾的最大子数组和</span></span><br><span class="line">            <span class="comment">// 选择要么将当前元素 nums[i] 加入前面的子数组（即 dp[i-1] + nums[i]），</span></span><br><span class="line">            <span class="comment">// 要么以当前元素 nums[i] 开始一个新的子数组，取两者中的最大值</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="comment">// 更新 result，确保 result 始终存储全局的最大子数组和</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; result) &#123;</span><br><span class="line">                result = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大子数组和</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目7：392-判断子序列"><a href="#题目7：392-判断子序列" class="headerlink" title="题目7：392. 判断子序列"></a>题目7：<a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h1><h2 id="1-题目描述-6"><a href="#1-题目描述-6" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>致谢：</strong></p>
<p>特别感谢 <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abc&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;axc&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 100</code></li>
<li>$0 &lt;= t.length &lt;= 10^4$</li>
<li>两个字符串都只由小写字符组成。</li>
</ul>
<h2 id="2-题解-6"><a href="#2-题解-6" class="headerlink" title="2.题解"></a>2.题解</h2><ul>
<li>这个道题目是最长公共子序列的变体</li>
</ul>
<h3 id="2-1-双指针"><a href="#2-1-双指针" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 s 和 t 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义双指针：left 指向 s，right 指向 t</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当两个指针都没有越界时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; n &amp;&amp; right &lt; m) &#123;</span><br><span class="line">            <span class="comment">// 如果 s[left] 与 t[right] 匹配，left 前进，查找 s 中下一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) == t.charAt(right)) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// right 指针总是前进，用来遍历 t</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 left 达到了 s 的末尾，说明 s 是 t 的子序列</span></span><br><span class="line">        <span class="keyword">return</span> left == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h3><ul>
<li><strong>动态规划表 <code>dp</code> 的定义：</strong><ul>
<li><code>dp[i][j]</code> 表示 <code>t</code> 的前 <code>i</code> 个字符和 <code>s</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。</li>
<li>核心是通过逐步填充 <code>dp</code> 表，来判断 <code>s</code> 是否可以作为 <code>t</code> 的子序列。</li>
</ul>
</li>
<li><strong>状态转移：</strong><ul>
<li>如果 <code>t[i-1] == s[j-1]</code>，那么当前字符相等，最长公共子序列的长度增加 <code>1</code>，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>如果 <code>t[i-1] != s[j-1]</code>，那么最长公共子序列的长度保持不变，即 <code>dp[i][j] = dp[i-1][j]</code>。</li>
</ul>
</li>
<li><strong>结果判断：</strong><ul>
<li>最后判断 <code>dp[n][m] == m</code> 是否成立。如果 <code>dp[n][m]</code> 等于 <code>m</code>，说明 <code>s</code> 的所有字符都可以在 <code>t</code> 中按顺序找到，即 <code>s</code> 是 <code>t</code> 的子序列，返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取字符串 t 和 s 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 t 的前 i 个字符和 s 的前 j 个字符的最长公共子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 t 的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历 s 的每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 获取 t 中的第 i-1 个字符和 s 中的第 j-1 个字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ct</span> <span class="operator">=</span> t.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span> s.charAt(j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果两个字符相等，说明它们可以加入到最长公共子序列</span></span><br><span class="line">                <span class="keyword">if</span> (ct == cs)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 否则最长公共子序列的长度保持不变，丢弃 t 的当前字符</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断最长公共子序列的长度是否等于 s 的长度</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m] == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目8：115-不同的子序列"><a href="#题目8：115-不同的子序列" class="headerlink" title="题目8：115. 不同的子序列"></a>题目8：<a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h1><h2 id="1-题目描述-7"><a href="#1-题目描述-7" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 109 + 7 取模。</p>
<p><strong>示例 1：</strong></p>
<p><img src="./assets/image-20241020120035127.png" alt="image-20241020120035127"></p>
<p><strong>示例 2：</strong></p>
<p><img src="./assets/image-20241020120051444.png" alt="image-20241020120051444"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<h2 id="2-题解-7"><a href="#2-题解-7" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-2"><a href="#2-1-动态规划-2" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length(); <span class="comment">// 获取字符串 t 的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s 的前 i 个字符中出现 t 的前 j 个字符的子序列个数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：当 t 为空串时，无论 s 是什么，结果都是 1，因为空串是任何字符串的子序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果 s[i-1] 与 t[j-1] 相等，可以选择匹配它们或者不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// dp[i-1][j-1] 表示匹配 s[i-1] 和 t[j-1]，dp[i-1][j] 表示不匹配</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 s[i-1] 与 t[j-1] 不相等，跳过 s[i-1]，保持 dp[i-1][j]</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果是 dp[n][m]，即 s 的前 n 个字符中出现 t 的前 m 个字符的子序列个数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-记忆化递归"><a href="#2-2-记忆化递归" class="headerlink" title="2.2 记忆化递归"></a>2.2 记忆化递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化一个二维数组来缓存递归结果，-1 表示尚未计算过</span></span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                memo[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用递归函数</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s, t, n, m, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归函数，计算 s 的前 i 个字符中有多少个子序列等于 t 的前 j 个字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(String s, String t, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 t 是空串，空串是任何字符串的子序列，返回 1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 s 是空串且 t 不是空串，不可能匹配，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经计算过，直接返回缓存的结果</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符匹配，既可以匹配当前字符，也可以跳过当前字符</span></span><br><span class="line">            memo[i][j] = dfs(s, t, i - <span class="number">1</span>, j - <span class="number">1</span>, memo) + dfs(s, t, i - <span class="number">1</span>, j, memo);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符不匹配，只能跳过当前字符</span></span><br><span class="line">            memo[i][j] = dfs(s, t, i - <span class="number">1</span>, j, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回计算结果</span></span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目8：583-两个字符串的删除操作"><a href="#题目8：583-两个字符串的删除操作" class="headerlink" title="题目8：583. 两个字符串的删除操作"></a>题目8：<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><h2 id="1-题目描述-8"><a href="#1-题目描述-8" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">word1</span> = <span class="string">&quot;sea&quot;</span>, <span class="attr">word2</span> = <span class="string">&quot;eat&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 第一步将 <span class="string">&quot;sea&quot;</span> 变为 <span class="string">&quot;ea&quot;</span> ，第二步将 <span class="string">&quot;eat &quot;</span>变为 <span class="string">&quot;ea&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>示例  2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">word2</span> = <span class="string">&quot;etco&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li>
</ul>
<h2 id="2-题解-8"><a href="#2-题解-8" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划2"><a href="#2-1-动态规划2" class="headerlink" title="2.1 动态规划2"></a>2.1 动态规划2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(); <span class="comment">// 获取 word1 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length(); <span class="comment">// 获取 word2 的长度</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作次数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则不需要进行任何操作，dp[i][j] 等于 dp[i-1][j-1]</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不相等，选择三种操作中最小的</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回将 word1 转换为 word2 所需的最少操作次数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划2"><a href="#2-2-动态规划2" class="headerlink" title="2.2 动态规划2"></a>2.2 动态规划2</h3><ul>
<li>只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(); <span class="comment">// 获取 word1 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length(); <span class="comment">// 获取 word2 的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 word1 的前 i 个字符和 word2 的前 j 个字符之间的最长公共子序列长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来记录最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// 遍历 word1 和 word2 的每个字符，填充 dp 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则最长公共子序列长度可以在前一个基础上 +1</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不相等，最长公共子序列的长度是去掉任一字符后的最大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最长公共子序列的长度</span></span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最少操作次数 = 两个字符串的长度之和 - 2 * 最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// 原因：最少操作次数等于将不属于最长公共子序列的字符删除，并插入到正确位置上</span></span><br><span class="line">        <span class="keyword">return</span> n + m - result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目9：72-编辑距离"><a href="#题目9：72-编辑距离" class="headerlink" title="题目9：72. 编辑距离"></a>题目9：<a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h1><h2 id="1-题目描述-9"><a href="#1-题目描述-9" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">horse</span> -&gt;</span> rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rorse</span> -&gt;</span> rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rose</span> -&gt;</span> ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">intention</span> -&gt;</span> inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">inention</span> -&gt;</span> enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">enention</span> -&gt;</span> exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">exention</span> -&gt;</span> exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">exection</span> -&gt;</span> execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h2 id="2-题解-9"><a href="#2-题解-9" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-3"><a href="#2-1-动态规划-3" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(); <span class="comment">// 获取 word1 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length(); <span class="comment">// 获取 word2 的长度</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作次数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化：将 word1 的前 i 个字符转换为空字符串，所需的操作次数是 i（全部删除）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="comment">// 初始化：将空字符串转换为 word2 的前 j 个字符，所需的操作次数是 j（全部插入）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则不需要进行任何操作，dp[i][j] 等于 dp[i-1][j-1]</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不相等，选择三种操作中最小的：</span></span><br><span class="line">                    <span class="comment">//dp[i - 1][j] + 1 删除操作</span></span><br><span class="line">                    <span class="comment">//dp[i][j - 1] + 1 增加操作</span></span><br><span class="line">                    <span class="comment">//dp[i-1][j-1] + 1 替换操作</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回将 word1 转换为 word2 所需的最少操作次数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目10：647-回文子串"><a href="#题目10：647-回文子串" class="headerlink" title="题目10：647. 回文子串"></a>题目10：<a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h1><h2 id="1-题目描述-10"><a href="#1-题目描述-10" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：三个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">6</span>个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h2 id="2-题解-10"><a href="#2-题解-10" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-4"><a href="#2-1-动态规划-4" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><ul>
<li>思路解析：</li>
</ul>
<ol>
<li><strong>回文子串的定义</strong>：<ul>
<li>回文子串是一个正读和反读都相同的子字符串。</li>
<li>例如：在字符串 “abcba” 中，”a”、”b”、”c”、”bcb”、”abcba” 都是回文子串。</li>
</ul>
</li>
<li><strong>动态规划的状态定义</strong>：<ul>
<li>创建一个二维数组 <code>dp[i][j]</code>，其中 <code>i</code> 表示子字符串的起始位置，<code>j</code> 表示子字符串的结束位置。<code>dp[i][j]</code> 为 <code>true</code> 表示子字符串 <code>s[i..j]</code> 是一个回文串，<code>false</code> 表示不是回文串。</li>
</ul>
</li>
<li><strong>转移方程</strong>：<ul>
<li>如果<code>s[i] == s[j]</code>，那么：<ul>
<li>如果 <code>j - i &lt;= 1</code>（即子串长度为 1 或 2），则 <code>s[i..j]</code> 肯定是回文串，直接标记 <code>dp[i][j] = true</code>。</li>
<li>如果 <code>j - i &gt; 1</code>，则需要判断内部的子串 <code>s[i+1..j-1]</code> 是否是回文串。如果 <code>dp[i+1][j-1] == true</code>，那么 <code>s[i..j]</code> 也是回文串。</li>
</ul>
</li>
</ul>
</li>
<li><strong>遍历顺序</strong>：<ul>
<li>从右向左遍历字符串 <code>s</code> 的每个字符 <code>i</code>，对于每个 <code>i</code>，遍历其右侧的每个字符 <code>j</code>（<code>j &gt;= i</code>），判断 <code>s[i..j]</code> 是否为回文串。</li>
<li>这种遍历顺序保证了在判断 <code>s[i..j]</code> 是否为回文串时，子串 <code>s[i+1..j-1]</code> 的状态已经被计算出来。</li>
</ul>
</li>
<li><strong>结果统计</strong>：<ul>
<li>每当找到一个回文子串（即 <code>dp[i][j] == true</code>），结果 <code>result</code> 加 1。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度 n</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n]; <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 存储回文子串的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从字符串末尾向前遍历每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123; <span class="comment">// 遍历以 i 开始、以 j 结束的子字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123; <span class="comment">// 如果 s[i] == s[j]</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 如果子串长度为 1 或 2</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result++; <span class="comment">// 是回文串，计数加 1</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123; <span class="comment">// 否则检查 s[i+1..j-1] 是否为回文</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result++; <span class="comment">// 如果 s[i+1..j-1] 是回文，则 s[i..j] 也是回文</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回回文子串的总个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码优化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度 n</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n]; <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 存储回文子串的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从字符串末尾向前遍历每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123; <span class="comment">// 遍历以 i 开始、以 j 结束的子字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i == <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123; <span class="comment">// 如果 s[i] == s[j]</span></span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    result++; <span class="comment">// 是回文串，计数加 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回回文子串的总个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h3><ul>
<li><strong>中心扩展法</strong>：<ul>
<li>对于一个长度为 <code>n</code> 的字符串，有 <code>2n-1</code> 个可能的中心。对于每个字符，它可以作为单字符中心，此外，两个相邻字符之间也可以作为双字符中心。因此有 <code>n</code> 个单字符中心和 <code>n-1</code> 个双字符中心。</li>
</ul>
</li>
<li><strong>双指针</strong>：<ul>
<li><code>left</code> 和 <code>right</code> 两个指针从中心开始向外扩展，检查左右两侧的字符是否相等。如果相等，则说明找到一个回文子串。</li>
<li><code>i / 2</code> 用于计算左指针，<code>i % 2</code> 用于处理双字符中心的情况。</li>
</ul>
</li>
<li><strong>计数</strong>：<ul>
<li>每当找到一个回文子串，<code>result</code> 计数器就加 1。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用双指针法，通过中心扩展来计算回文子串数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于记录回文子串的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 2 * n - 1 个中心点</span></span><br><span class="line">        <span class="comment">// 对于长度为 n 的字符串，可以有 n 个单字符中心和 n-1 个双字符中心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前中心的左边界和右边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i / <span class="number">2</span>; <span class="comment">// 左指针指向当前中心的左侧字符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + i % <span class="number">2</span>; <span class="comment">// 右指针指向当前中心的右侧字符，取决于是单字符中心还是双字符中心</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩展中心，检查回文</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                result++; <span class="comment">// 找到一个回文子串，计数+1</span></span><br><span class="line">                left--; <span class="comment">// 左指针向左扩展</span></span><br><span class="line">                right++; <span class="comment">// 右指针向右扩展</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回找到的回文子串总数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目11：5-最长回文子串"><a href="#题目11：5-最长回文子串" class="headerlink" title="题目11：5. 最长回文子串"></a>题目11：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="1-题目描述-11"><a href="#1-题目描述-11" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h2 id="2-题解-11"><a href="#2-题解-11" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-5"><a href="#2-1-动态规划-5" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;  <span class="comment">// 如果字符串为空或只有一个字符，直接返回</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, maxLength = <span class="number">1</span>;  <span class="comment">// 初始的最长回文长度为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历的顺序：从后往前填充</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;  <span class="comment">// 单个字符本身就是回文</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断当前字符是否相同以及内部子串是否是回文</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i == <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">int</span> <span class="variable">currentLength</span> <span class="operator">=</span> j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (currentLength &gt; maxLength) &#123;</span><br><span class="line">                        maxLength = currentLength;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目12：516-最长回文子序列"><a href="#题目12：516-最长回文子序列" class="headerlink" title="题目12：516. 最长回文子序列"></a>题目12：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><h2 id="1-题目描述-12"><a href="#1-题目描述-12" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bbbb&quot;</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bb&quot;</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="2-题解-12"><a href="#2-题解-12" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-二维数组-1"><a href="#2-1-动态规划-二维数组-1" class="headerlink" title="2.1 动态规划-二维数组"></a>2.1 动态规划-二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示从字符串 s 的第 i 个字符到第 j 个字符之间的最长回文子序列的长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前遍历字符串的每个字符 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 内部循环从 i 到字符串的末尾 j</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果第 i 和第 j 个字符相同</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">// 如果 i 和 j 是同一个字符，最长回文子序列的长度为 1</span></span><br><span class="line">                    <span class="keyword">if</span> (j == i)</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 否则，最长回文子序列等于 2 加上去掉当前字符后的回文长度</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 i 和 j 字符不同，则取舍去掉 i 或去掉 j 的情况中较大的回文子序列长度</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回从字符串第 0 个字符到最后一个字符之间的最长回文子序列长度</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>零钱兑换 | LeetCode-322 | 动态规划</title>
    <url>/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 =<span class="number"> 5 </span>+<span class="number"> 5 </span>+ 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：coins </span>=<span class="string"> [2], amount = 3</span></span><br><span class="line"><span class="string">输出：-1</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：coins </span>=<span class="string"> [1], amount = 0</span></span><br><span class="line"><span class="string">输出：0</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li>$1 &lt;= coins[i] &lt;= 2^{31} - 1$</li>
<li>$0 &lt;= amount &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划-滚动数组"><a href="#2-1-动态规划-滚动数组" class="headerlink" title="2.1 动态规划-滚动数组"></a>2.1 动态规划-滚动数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度为 amount + 1 的动态规划数组 dp，初始化为 Integer.MAX_VALUE 表示无穷大</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化其他金额的 dp 值为最大值，表示初始时无法组成这些金额</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个金额 i，从 1 到 amount</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个硬币面值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前金额 i 大于等于当前硬币面值，并且 dp[i - coins[j]] 不为无穷大，说明可以使用当前硬币</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coins[j] &amp;&amp; dp[i - coins[j]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="comment">// 更新 dp[i]，取最小的硬币数量</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 dp[amount] 仍为无穷大，说明无法组成该金额，返回 -1，否则返回 dp[amount]</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>整数拆分 | LeetCode-343 | 动态规划</title>
    <url>/2024/09/23/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 1</span><br><span class="line">解释:<span class="number"> 2 </span>=<span class="number"> 1 </span>+ 1,<span class="number"> 1 </span>×<span class="number"> 1 </span>= 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 36</span><br><span class="line">解释:<span class="number"> 10 </span>=<span class="number"> 3 </span>+<span class="number"> 3 </span>+ 4,<span class="number"> 3 </span>×<span class="number"> 3 </span>×<span class="number"> 4 </span>= 36。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个公共方法 integerBreak，它接受一个整数 n 作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个动态规划数组，长度为 n + 1，并且所有元素初始化为 0</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 n 为 2 时，最大乘积为 1（2 = 1 * 1）</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 3 开始遍历到 n，因为当 n = 2 时的情况已经处理过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有可能断裂的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 确保断裂后的两个数都大于等于 2，即至少有一个断点</span></span><br><span class="line">                <span class="comment">// 更新 dp[i] 的值为三个值中的最大者：</span></span><br><span class="line">                <span class="comment">// 1. 当前 dp[i] 的值</span></span><br><span class="line">                <span class="comment">// 2. 断裂位置 j 和剩余部分 i - j 的乘积</span></span><br><span class="line">                <span class="comment">// 3. 断裂位置 j 和剩余部分断裂后的最大乘积 dp[i - j]</span></span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 n 断裂的最大乘积</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-数论"><a href="#2-2-数论" class="headerlink" title="2.2 数论"></a>2.2 数论</h2><ul>
<li><p>解题思路：</p>
<ul>
<li><p>设将整数$n$拆分为$a$个小数字：</p>
<p>$n=n_1+n_2+…+n_a$</p>
</li>
<li><p>本题等价于求解：</p>
<p>$\max(n_1\times n_2\times…\times n_a)$</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下数学推导总体分为两步：① 当所有拆分出的数字相等时，乘积最大。② 最优拆分数字为 3 。</p>
</blockquote>
<h5 id="拆分规则："><a href="#拆分规则：" class="headerlink" title="拆分规则："></a>拆分规则：</h5><ol>
<li><strong>最优：</strong> 3 。把数字 <em>n</em> 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。</li>
<li><strong>次优：</strong> 2 。若余数为 2 ；则保留，不再拆为 1+1 。</li>
<li><strong>最差：</strong> 1 。若余数为 1 ；则应把一份 3+1 替换为 2+2，因为 2×2&gt;3×1。</li>
</ol>
<h5 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h5><ol>
<li>当 <em>n</em>≤3 时，按照规则应不拆分，但由于题目要求必须拆分，因此必须拆出一个因子 1 ，即返回 <em>n</em>−1 。</li>
<li>当n&gt;3时，求n除以3的 整数部分<em>a</em>和 余数部分<em>b</em>（即<em>n</em>=3<em>a</em>+<em>b</em>），并分为以下三种情况：<ul>
<li>当 <em>b</em>=0 时，直接返回 3<em>a</em>；</li>
<li>当 <em>b</em>=1 时，要将一个 1+3 转换为 2+2，因此返回$3^{a−1}×4$；</li>
<li>当 <em>b</em>=2 时，返回$3^a×2$</li>
</ul>
</li>
</ol>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个公共方法 integerBreak，它接受一个整数 n 作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 n 小于或等于 3，直接返回 n - 1 （除了 n = 2 时，其本身已经是最大乘积）</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 n 除以 3 的商</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 n 除以 3 的余数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 n 能够被 3 整除，即余数为 0，则结果就是 3 的 a 次方</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果余数是 1，表示可以将一个 3 替换为 4 （因为 3 + 3 变为 2 + 2 + 3），从而得到更大的乘积</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果余数是 2，则直接将两个 3 中的一个替换为 2 （因为 3 * 3 变为 3 * 2），这样不会减少乘积</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和IV | LeetCode-377 | 动态规划</title>
    <url>/2024/10/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ<a/></b></p>
<center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="keyword">target</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>], <span class="keyword">target</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划-滚动数组"><a href="#2-1-动态规划-滚动数组" class="headerlink" title="2.1 动态规划-滚动数组"></a>2.1 动态规划-滚动数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个动态规划数组 dp，长度为 target + 1，dp[i] 表示达到和为 i 的组合数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化，达到和为 0 的组合数为 1（空组合）</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历目标值从 0 到 target</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组 nums 中的每个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前目标值 i 大于等于 nums[j]，则更新 dp[i]</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= nums[j])</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回达到和为 target 的组合数</span></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分割等和子集 | LeetCode-416 | 动态规划</title>
    <url>/2024/10/02/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量 II<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：stones = <span class="comment">[2,7,4,1,8,1]</span></span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 <span class="comment">[2,7,1,8,1]</span>，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 <span class="comment">[2,1,1,1]</span>，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 <span class="comment">[1,1,1]</span>，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 <span class="comment">[1]</span>，这就是最优值。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：stones = <span class="string">[31,26,33,21,40]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个公共方法 numTrees，它接受一个整数 n 作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个动态规划数组，长度为 n + 1，并且所有元素初始化为 0</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件：0个节点和1个节点的情况下，只有一种构建BST的方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 2 开始遍历到 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有可能的根节点值 j（从 0 到 i-1）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// dp[i] 表示 i 个节点的不同BST数量</span></span><br><span class="line">                <span class="comment">// 对于每一个根节点 j，左子树有 j 个节点，右子树有 i - 1 - j 个节点</span></span><br><span class="line">                <span class="comment">// 根据组合公式，累加 dp[j] 和 dp[i - 1 - j] 的乘积</span></span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回 n 个节点的不同BST数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-数学"><a href="#2-2-数学" class="headerlink" title="2.2 数学"></a>2.2 数学</h2><ul>
<li><p>卡塔兰数：</p>
<p>$C<em>0=1,\quad C</em>{n+1}=\frac{2(2n+1)}{n+2}C_n$</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列 | LeetCode-509 | 动态规划</title>
    <url>/2024/09/16/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数<a/></b></p>
<center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">F</span><span class="params">(<span class="number">0</span>)</span></span> = <span class="number">0</span>，<span class="built_in">F</span>(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">F</span><span class="params">(n)</span></span> = <span class="built_in">F</span>(n - <span class="number">1</span>) + <span class="built_in">F</span>(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">输入：<span class="variable">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="function"><span class="title">F</span>(<span class="number">2</span>) = <span class="title">F</span>(<span class="number">1</span>) + <span class="title">F</span>(<span class="number">0</span>) = <span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span></span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">输入：<span class="variable">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="function"><span class="title">F</span>(<span class="number">3</span>) = <span class="title">F</span>(<span class="number">2</span>) + <span class="title">F</span>(<span class="number">1</span>) = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">输入：<span class="variable">n</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="function"><span class="title">F</span>(<span class="number">4</span>) = <span class="title">F</span>(<span class="number">3</span>) + <span class="title">F</span>(<span class="number">2</span>) = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划求斐波那契数列</span></span><br><span class="line">        <span class="comment">// 如果 n 是 0 或 1，直接返回 n，因为 fib(0) = 0，fib(1) = 1</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化变量：a 表示前一个斐波那契数（fib(i-2)），b 表示当前斐波那契数（fib(i-1)）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 2 开始计算斐波那契数，一直到 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// c 表示下一个斐波那契数，即 fib(i) = fib(i-1) + fib(i-2)</span></span><br><span class="line">            c = a + b;</span><br><span class="line">            <span class="comment">// 更新 a 和 b，准备计算下一个斐波那契数</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 fib(n)，即最终计算出的斐波那契数列的第 n 项</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-递归"><a href="#2-2-递归" class="headerlink" title="2.2 递归"></a>2.2 递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">1</span> ) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径 | LeetCode-62 | 动态规划</title>
    <url>/2024/09/23/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-62-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径<a/></b></p>
<center>



<hr>
<h1 id="题目1-62-不同路径"><a href="#题目1-62-不同路径" class="headerlink" title="题目1:62. 不同路径"></a>题目1:<a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">7</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 $2 * 10^9$</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个大小为 m * n 的二维数组 dp，用于存储每个位置的路径数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行，机器人只能向右走，因此每个位置都有唯一一条路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列，机器人只能向下走，因此每个位置都有唯一一条路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 数组，其它位置的路径数为上方位置和左侧位置的路径数之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回终点位置的路径数，即右下角的 dp[m-1][n-1]</span></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-动态规划优化"><a href="#2-2-动态规划优化" class="headerlink" title="2.2 动态规划优化"></a>2.2 动态规划优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度为 n 的一维数组 dp，用于存储每列的路径数</span></span><br><span class="line">        <span class="comment">// 初始时表示从起点 (0, 0) 到达每个列位置的路径数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行，机器人只能向右走，因此第一行每个位置都有唯一一条路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二行开始，逐行更新路径数</span></span><br><span class="line">        <span class="comment">// 每一行的路径数可以通过当前列上方的路径数（dp[j]）和左侧的路径数（dp[j - 1]）累加得到</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>]; <span class="comment">// 上方的路径数 + 左侧的路径数</span></span><br><span class="line">                <span class="comment">// dp[j]     代表上方的路径数</span></span><br><span class="line">                <span class="comment">// dp[j - 1] 代表左侧的路径数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回终点位置的路径数，即最后一列的 dp[n - 1]</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-组合数"><a href="#2-3-组合数" class="headerlink" title="2.3 组合数"></a>2.3 组合数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用一个 long 类型的变量 result 来保存计算结果，避免中间计算过程中的整数溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过组合数学公式计算唯一路径数</span></span><br><span class="line">        <span class="comment">// 循环的目的是计算公式 C(m+n-2, n-1) 或 C(m+n-2, m-1)</span></span><br><span class="line">        <span class="comment">// 公式表示在 m-1 次向下移动和 n-1 次向右移动中选择 m-1 或 n-1 的组合数</span></span><br><span class="line">        <span class="comment">// 即 C(m+n-2, n-1) = (n * (n+1) * ... * (m+n-2)) / ((m-1)!)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n, y = <span class="number">1</span>; y &lt; m; x++, y++)&#123;</span><br><span class="line">            result = result * x / y; <span class="comment">// 每次计算当前组合的部分结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终结果，将 long 类型转换为 int 类型</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：63-不同路径-II"><a href="#题目2：63-不同路径-II" class="headerlink" title="题目2：63. 不同路径 II"></a>题目2：<a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == obstacleGrid.length</code></li>
<li><code>n == obstacleGrid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-动态规划-1"><a href="#2-1-动态规划-1" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯 | LeetCode-70 | 动态规划</title>
    <url>/2024/09/16/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1.<span class="number"> 1 </span>阶 +<span class="number"> 1 </span>阶</span><br><span class="line">2.<span class="number"> 2 </span>阶</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1.<span class="number"> 1 </span>阶 +<span class="number"> 1 </span>阶 +<span class="number"> 1 </span>阶</span><br><span class="line">2.<span class="number"> 1 </span>阶 +<span class="number"> 2 </span>阶</span><br><span class="line">3.<span class="number"> 2 </span>阶 +<span class="number"> 1 </span>阶</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划求斐波那契数列</span></span><br><span class="line">        <span class="comment">// 如果 n 是 0 或 1，直接返回 n，因为 fib(0) = 0，fib(1) = 1</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化变量：a 表示前一个斐波那契数（fib(i-2)），b 表示当前斐波那契数（fib(i-1)）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 2 开始计算斐波那契数，一直到 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// c 表示下一个斐波那契数，即 fib(i) = fib(i-1) + fib(i-2)</span></span><br><span class="line">            c = a + b;</span><br><span class="line">            <span class="comment">// 更新 a 和 b，准备计算下一个斐波那契数</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 fib(n)，即最终计算出的斐波那契数列的第 n 项</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-递归-超时"><a href="#2-2-递归-超时" class="headerlink" title="2.2 递归(超时)"></a>2.2 递归(超时)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-爬楼梯进阶"><a href="#3-爬楼梯进阶" class="headerlink" title="3.爬楼梯进阶"></a>3.爬楼梯进阶</h1><h2 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h2><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 </p>
<p>每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ </p>
<p>注意：给定 n 是一个正整数。</p>
<h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入共一行，包含两个正整数，分别表示n, m</p>
<h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示爬到楼顶的方法数。</p>
<h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>1 &lt;= m &lt; n &lt;= 32;</p>
<p>当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。</p>
<p>此时你有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶段</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<h2 id="3-2-题解"><a href="#3-2-题解" class="headerlink" title="3.2 题解"></a>3.2 题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 读取输入：使用 Scanner 类从控制台读取两个整数 n 和 m</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();  <span class="comment">// 读取要爬的台阶数 n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();  <span class="comment">// 读取每次最多可以爬的台阶数 m</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 初始化一个大小为 n+1 的数组 d，用于存储每个台阶位置的爬法数</span></span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 初始条件：当 i = 0 时，表示不需要爬任何台阶，只有一种方式，即不动，所以 d[0] = 1</span></span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 动态规划计算每一级台阶的爬法数</span></span><br><span class="line">        <span class="comment">// 外层循环从 1 开始到 n，逐步计算每一级台阶的爬法数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// 内层循环从 1 到 m，表示可以从前面的 m 个台阶跳过来</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果当前台阶 i 减去 j（前一个台阶的位置）大于等于 0，</span></span><br><span class="line">                <span class="comment">// 说明可以从第 i-j 个台阶跳到第 i 个台阶</span></span><br><span class="line">                <span class="keyword">if</span>(i - j &gt;= <span class="number">0</span> ) d[i] += d[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 输出结果，打印出爬到第 n 级台阶的总爬法数</span></span><br><span class="line">        System.out.println(d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>使用最小花费爬楼梯 | LeetCode-746 | 动态规划</title>
    <url>/2024/09/16/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯<a/></b></p>
<center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为<span class="number"> 1 </span>的台阶开始。</span><br><span class="line">- 支付<span class="number"> 15 </span>，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为<span class="number"> 15 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为<span class="number"> 0 </span>的台阶开始。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 2 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 4 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 6 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬一个台阶，到达下标为<span class="number"> 7 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬两个台阶，到达下标为<span class="number"> 9 </span>的台阶。</span><br><span class="line">- 支付<span class="number"> 1 </span>，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">总花费为<span class="number"> 6 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= cost.length &lt;= 1000</code></li>
<li><code>0 &lt;= cost[i] &lt;= 999</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划-写法1"><a href="#2-1-动态规划-写法1" class="headerlink" title="2.1 动态规划-写法1"></a>2.1 动态规划-写法1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个数组 d，表示爬到每一级台阶的最小花费</span></span><br><span class="line">        <span class="comment">// d 的长度为 cost.length + 1，因为需要计算到达顶端后的花费</span></span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始条件：爬到第 0 级和第 1 级台阶的花费为 0</span></span><br><span class="line">        <span class="comment">// 因为可以从第 0 或第 1 级直接开始</span></span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第 2 级台阶开始计算，逐步确定到每一级台阶的最小花费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= cost.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算到达第 i 级台阶的最小花费</span></span><br><span class="line">            <span class="comment">// 可以从第 i-1 级台阶爬上来，花费是 d[i-1] + cost[i-1]</span></span><br><span class="line">            <span class="comment">// 也可以从第 i-2 级台阶爬上来，花费是 d[i-2] + cost[i-2]</span></span><br><span class="line">            <span class="comment">// 取两者中的较小值作为到达第 i 级台阶的最小花费</span></span><br><span class="line">            d[i] = Math.min(d[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], d[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回到达顶端（即 cost.length 位置）的最小花费</span></span><br><span class="line">        <span class="keyword">return</span> d[cost.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-动态规划-写法2"><a href="#2-2-动态规划-写法2" class="headerlink" title="2.2 动态规划-写法2"></a>2.2 动态规划-写法2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化三个变量：</span></span><br><span class="line">        <span class="comment">// pre 表示到达 i-2 级台阶的最小花费</span></span><br><span class="line">        <span class="comment">// cur 表示到达 i-1 级台阶的最小花费</span></span><br><span class="line">        <span class="comment">// next 表示到达当前台阶的最小花费</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第 2 级台阶开始，逐步计算到达每一级台阶的最小花费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= cost.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算到达当前台阶 i 的最小花费</span></span><br><span class="line">            <span class="comment">// 可以从第 i-2 级台阶跳过来，花费是 pre + cost[i-2]</span></span><br><span class="line">            <span class="comment">// 也可以从第 i-1 级台阶跳过来，花费是 cur + cost[i-1]</span></span><br><span class="line">            next = Math.min(pre + cost[i - <span class="number">2</span>], cur + cost[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 pre 和 cur，为下一次迭代做准备</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回到达顶端的最小花费，即最后一次迭代的 cur 值</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树 | LeetCode-96 | 动态规划</title>
    <url>/2024/09/24/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LeetCode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<center><b>动态规划练习题</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树<a/></b></p>
<center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/algorithm/image-20240924174531055.png" alt="image-20240924174531055"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个公共方法 numTrees，它接受一个整数 n 作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个动态规划数组，长度为 n + 1，并且所有元素初始化为 0</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件：0个节点和1个节点的情况下，只有一种构建BST的方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 2 开始遍历到 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有可能的根节点值 j（从 0 到 i-1）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// dp[i] 表示 i 个节点的不同BST数量</span></span><br><span class="line">                <span class="comment">// 对于每一个根节点 j，左子树有 j 个节点，右子树有 i - 1 - j 个节点</span></span><br><span class="line">                <span class="comment">// 根据组合公式，累加 dp[j] 和 dp[i - 1 - j] 的乘积</span></span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回 n 个节点的不同BST数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-数学"><a href="#2-2-数学" class="headerlink" title="2.2 数学"></a>2.2 数学</h2><ul>
<li><p>卡塔兰数：</p>
<p>$C<em>0=1,\quad C</em>{n+1}=\frac{2(2n+1)}{n+2}C_n$</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分割回文字符串 | LeetCode-131 | 回溯算法</title>
    <url>/2024/09/05/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<blockquote>
<p>回溯算法练习题</p>
</blockquote>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串<a/></b>
</center>

<hr>
<h1 id="题目1：131-分割回文串"><a href="#题目1：131-分割回文串" class="headerlink" title="题目1：131. 分割回文串"></a>题目1：<a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出：[[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">[[&quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 16</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-回溯"><a href="#2-1-回溯" class="headerlink" title="2.1 回溯"></a>2.1 回溯</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 保存所有符合条件的回文分割方案</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前回溯路径，用于保存一次递归过程中生成的回文子串</span></span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，接收字符串并启动回溯过程</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 从字符串的第 0 个字符开始进行回溯</span></span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回最终的所有回文分割方案</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，递归生成回文子串的组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 start 达到字符串末尾时，说明已经找到了一个完整的分割方案</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径（回文组合）添加到结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 start 开始，尝试截取不同长度的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取从 start 到 i 的子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(start, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果子串是回文，则将其加入路径并继续递归</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(sub)) &#123;</span><br><span class="line">                <span class="comment">// 添加当前回文子串到路径中</span></span><br><span class="line">                path.add(sub);</span><br><span class="line">                <span class="comment">// 递归处理从 i+1 开始的剩余字符串</span></span><br><span class="line">                backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯，撤销上一步的选择，将最后一个子串移除</span></span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断字符串是否为回文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针法，左指针从头，右指针从尾部向中间移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较字符串左右两端的字符，直到左指针超过右指针</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果左右字符不相等，则不是回文</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 移动左右指针</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有发现不相等的字符，则是回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="题目2：132-分割回文串-II"><a href="#题目2：132-分割回文串-II" class="headerlink" title="题目2：132. 分割回文串 II"></a>题目2：<a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文串。返回符合要求的 <strong>最少分割次数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只需一次分割就可将 s 分割成 [<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>] 这样两个回文子串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-写法1-超时"><a href="#2-1-写法1-超时" class="headerlink" title="2.1 写法1-超时"></a>2.1 写法1-超时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            min = path.size()-<span class="number">1</span> &lt; min ? path.size()-<span class="number">1</span> : min;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(start, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(sub)) &#123;</span><br><span class="line">                path.add(sub);</span><br><span class="line">                backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
        <tag>分割</tag>
      </tags>
  </entry>
  <entry>
    <title>重新安排行程 | LeetCode- | 回溯算法 |</title>
    <url>/2024/08/01/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧！</p>
<p>回溯算法练习题</p>
</blockquote>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一份航线列表 <code>tickets</code> ，其中 $tickets[i] = [from_i, to_i]$ 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：tickets = [[<span class="string">&quot;MUC&quot;</span>,<span class="string">&quot;LHR&quot;</span>],[<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;MUC&quot;</span>],[<span class="string">&quot;SFO&quot;</span>,<span class="string">&quot;SJC&quot;</span>],[<span class="string">&quot;LHR&quot;</span>,<span class="string">&quot;SFO&quot;</span>]]</span><br><span class="line">输出：[<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;MUC&quot;</span>,<span class="string">&quot;LHR&quot;</span>,<span class="string">&quot;SFO&quot;</span>,<span class="string">&quot;SJC&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：tickets = [[<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;SFO&quot;</span>],[<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;ATL&quot;</span>],[<span class="string">&quot;SFO&quot;</span>,<span class="string">&quot;ATL&quot;</span>],[<span class="string">&quot;ATL&quot;</span>,<span class="string">&quot;JFK&quot;</span>],[<span class="string">&quot;ATL&quot;</span>,<span class="string">&quot;SFO&quot;</span>]]</span><br><span class="line">输出：[<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;ATL&quot;</span>,<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;SFO&quot;</span>,<span class="string">&quot;ATL&quot;</span>,<span class="string">&quot;SFO&quot;</span>]</span><br><span class="line">解释：另一种有效的行程是 [<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;SFO&quot;</span>,<span class="string">&quot;ATL&quot;</span>,<span class="string">&quot;JFK&quot;</span>,<span class="string">&quot;ATL&quot;</span>,<span class="string">&quot;SFO&quot;</span>] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= tickets.length &lt;= 300$</li>
<li>$tickets[i].length == 2$</li>
<li>$from_i.length == 3$</li>
<li>$to_i.length == 3$</li>
<li>$from_i$和 $to_i$ 由大写英文字母组成</li>
<li>$from_i  \ != to_i$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-回溯算法-写法1"><a href="#2-1-回溯算法-写法1" class="headerlink" title="2.1 回溯算法-写法1"></a>2.1 回溯算法-写法1</h2><ul>
<li>代码解释：<a href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/1/dfshui-su-chao-ji-xiang-xi-jie-shi-by-dr-iy95/">https://leetcode.cn/problems/reconstruct-itinerary/solutions/1/dfshui-su-chao-ji-xiang-xi-jie-shi-by-dr-iy95/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用双端队列存储最终结果，方便在两端进行操作</span></span><br><span class="line">    <span class="keyword">public</span> Deque&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 HashMap 存储航班信息，key 为出发机场，value 为到达机场以及相应航班的次数</span></span><br><span class="line">    <span class="comment">// TreeMap 保证到达机场按字典序排列</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Map&lt;String, Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历机票信息，构建航班映射表</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; t : tickets) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; temp;</span><br><span class="line">            <span class="comment">// 如果出发机场已经存在于 map 中，取出对应的到达机场映射</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(t.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                temp = map.get(t.get(<span class="number">0</span>));</span><br><span class="line">                <span class="comment">// 更新到达机场的航班次数（允许重复航班）</span></span><br><span class="line">                temp.put(t.get(<span class="number">1</span>), temp.getOrDefault(t.get(<span class="number">1</span>), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果出发机场不存在，创建一个 TreeMap 来保存到达机场，确保按字典序排序</span></span><br><span class="line">                temp = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 升序</span></span><br><span class="line">                temp.put(t.get(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将更新后的到达机场映射存回 map</span></span><br><span class="line">            map.put(t.get(<span class="number">0</span>), temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起点是 &quot;JFK&quot;，将其加入结果路径</span></span><br><span class="line">        result.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始回溯搜索，尝试找到一条完整的行程</span></span><br><span class="line">        backtracking(tickets.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果转换为 List 并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，尝试构建完整行程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> ticketNum)</span> &#123;</span><br><span class="line">        <span class="comment">// 当路径中的节点数等于机票数加 1 时，说明已找到完整路径</span></span><br><span class="line">        <span class="keyword">if</span> (result.size() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前路径最后一个机场</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> result.getLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前机场是否存在后续航班</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(last)) &#123; <span class="comment">// 防止空指针异常</span></span><br><span class="line">            <span class="comment">// 遍历所有从该机场出发的航班</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> target.getValue();</span><br><span class="line">                <span class="comment">// 如果还有未使用的航班</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将该目的地加入结果路径</span></span><br><span class="line">                    result.add(target.getKey());</span><br><span class="line">                    <span class="comment">// 更新该航班的剩余次数</span></span><br><span class="line">                    target.setValue(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 递归调用，继续构建剩余行程</span></span><br><span class="line">                    <span class="keyword">if</span> (backtracking(ticketNum)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到可行路径，立即返回</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 回溯操作：移除最后一个添加的目的地，恢复航班次数</span></span><br><span class="line">                    result.removeLast();</span><br><span class="line">                    target.setValue(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到有效路径，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-回溯算法-写法2-超时"><a href="#2-2-回溯算法-写法2-超时" class="headerlink" title="2.2 回溯算法-写法2-超时"></a>2.2 回溯算法-写法2-超时</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用于存储最终的行程结果</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;String&gt; res;</span><br><span class="line">    <span class="comment">// 用于存储当前路径</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        <span class="comment">// 对机票按照目的地字母顺序进行排序，保证字典序最小的行程先被访问</span></span><br><span class="line">        Collections.sort(tickets, (a, b) -&gt; a.get(<span class="number">1</span>).compareTo(b.get(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起点是 &quot;JFK&quot;，将其加入路径中</span></span><br><span class="line">        path.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来标记机票是否已被使用</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[tickets.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始回溯搜索，寻找符合条件的行程</span></span><br><span class="line">        backTracking((ArrayList) tickets, used);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，用来寻找符合条件的行程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(ArrayList&lt;List&lt;String&gt;&gt; tickets, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 当路径长度等于机票数量 + 1 时，说明找到了完整路径</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == tickets.size() + <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path); <span class="comment">// 将当前路径复制到结果中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回 true 表示已找到结果，终止递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有机票，尝试找到下一个符合条件的目的地</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tickets.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前机票未被使用，且该机票的出发地与当前路径的最后一个机场相同</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i] &amp;&amp; tickets.get(i).get(<span class="number">0</span>).equals(path.getLast())) &#123;</span><br><span class="line">                <span class="comment">// 将目的地添加到路径中</span></span><br><span class="line">                path.add(tickets.get(i).get(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 标记该机票已使用</span></span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归调用，继续寻找下一站行程</span></span><br><span class="line">                <span class="keyword">if</span> (backTracking(tickets, used)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到了完整路径，直接返回 true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回溯操作：移除最后一个添加的目的地，并重置该机票的使用状态</span></span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到有效路径，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>非递减子序列 | LeetCode-491 | 回溯算法</title>
    <url>/2024/09/09/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-491-%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧！</p>
<p>回溯算法练习题</p>
</blockquote>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 非递减子序列<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[4,6,7,7]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[4,6]</span>,<span class="comment">[4,6,7]</span>,<span class="comment">[4,6,7,7]</span>,<span class="comment">[4,7]</span>,<span class="comment">[4,7,7]</span>,<span class="comment">[6,7]</span>,<span class="comment">[6,7,7]</span>,<span class="comment">[7,7]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[4,4]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 15</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-回溯算法-哈希集合"><a href="#2-1-回溯算法-哈希集合" class="headerlink" title="2.1 回溯算法-哈希集合"></a>2.1 回溯算法-哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储最终结果的列表，用于保存所有满足条件的子序列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前子序列的路径，用于构建每一个子序列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 findSubsequences，输入一个整数数组 nums，返回所有递增的子序列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 从索引 0 开始回溯生成子序列</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回生成的所有递增子序列</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法，用于生成所有符合条件的子序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="comment">// 当当前路径长度大于1时，将其加入结果列表中（子序列长度至少为2）</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Set 集合去重，避免在同一层次中使用相同的元素</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，从起始索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过不符合递增条件或在同一层中已处理过的数字</span></span><br><span class="line">            <span class="comment">// 1. 如果当前数字小于路径中的最后一个数字，则跳过（不满足递增条件）</span></span><br><span class="line">            <span class="comment">// 2. 如果当前数字在本轮递归中已经使用过，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>)) || set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前数字加入 Set 集合，表示本层已经处理过该数字</span></span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="comment">// 将当前数字加入子序列路径</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归处理后续的数字，构建新的子序列</span></span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯：移除路径中的最后一个元素，进行下一个可能的选择</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-回溯算法-哈希数组"><a href="#2-2-回溯算法-哈希数组" class="headerlink" title="2.2 回溯算法-哈希数组"></a>2.2 回溯算法-哈希数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储最终结果的列表，用于保存所有满足条件的子序列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前子序列的路径，用于构建每一个子序列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 findSubsequences，输入一个整数数组 nums，返回所有递增的子序列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 从索引 0 开始回溯生成子序列</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回生成的所有递增子序列</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法，用于生成所有符合条件的子序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="comment">// 当当前路径长度大于1时，将其加入结果列表中（子序列长度至少为2）</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建哈希数组，范围为 [-100, 100]，用于去重</span></span><br><span class="line">        <span class="type">boolean</span>[] hash = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，从起始索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过不符合递增条件或在同一层中已处理过的数字</span></span><br><span class="line">            <span class="comment">// 1. 如果当前数字小于路径中的最后一个数字，则跳过（不满足递增条件）</span></span><br><span class="line">            <span class="comment">// 2. 如果当前数字在本轮递归中已经使用过（即哈希数组中标记为 true），则跳过</span></span><br><span class="line">            <span class="keyword">if</span> ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>)) || hash[nums[i] + <span class="number">100</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前数字标记为已使用</span></span><br><span class="line">            hash[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 将当前数字加入子序列路径</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归处理后续的数字，构建新的子序列</span></span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯：移除路径中的最后一个元素，进行下一个可能的选择</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>子集 | LeetCode-78 | 回溯算法</title>
    <url>/2024/09/08/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-46-47-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<center> <b>回溯算法练习题 | 子集问题</b>

---

<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/subsets/">78. 子集<a/></b>
</center>

<hr>
<h1 id="题目1：46-全排列"><a href="#题目1：46-全排列" class="headerlink" title="题目1：46. 全排列"></a>题目1：<a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[0,1],[1,0]]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><ul>
<li>图解：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/javaweb/image-20240909193332821.png" alt="image-20240909193332821"></p>
<h3 id="2-1-回溯解法1"><a href="#2-1-回溯解法1" class="headerlink" title="2.1 回溯解法1"></a>2.1 回溯解法1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义存储最终结果的列表，result 用于存储所有可能的全排列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义存储当前排列路径的列表，path 用于构建当前的排列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 permute，输入一个整数数组 nums，返回其所有全排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回溯算法，初始化一个长度为 nums.length 的布尔数组 used，用于记录每个元素是否被使用</span></span><br><span class="line">        backtracking(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="comment">// 返回最终的排列结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回溯算法方法 backtracking，用于生成所有可能的全排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前路径的长度等于数组的长度，则表示已经生成了一个完整的排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123; </span><br><span class="line">            <span class="comment">// 将当前路径 path 的副本加入结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束当前递归</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素已经被使用，则跳过该元素</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 标记当前元素为已使用</span></span><br><span class="line">            used[i] = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// 将当前元素添加到排列路径 path 中</span></span><br><span class="line">            path.add(nums[i]); </span><br><span class="line">            <span class="comment">// 递归调用回溯函数，处理下一个元素</span></span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            <span class="comment">// 回溯：移除路径中的最后一个元素</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); </span><br><span class="line">            <span class="comment">// 重置当前元素的使用状态，以便下一次使用</span></span><br><span class="line">            used[i] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-回溯解法2"><a href="#2-2-回溯解法2" class="headerlink" title="2.2 回溯解法2"></a>2.2 回溯解法2</h3><ul>
<li>这种写法得益于数组中没有重复元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义存储最终结果的列表，result 用于存储所有可能的全排列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义存储当前排列路径的列表，path 用于构建当前的排列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 permute，输入一个整数数组 nums，返回其所有全排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回溯算法，开始生成全排列</span></span><br><span class="line">        backtracking(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="comment">// 返回最终的排列结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法方法 backtracking，用于生成所有可能的全排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前路径的长度等于数组的长度，则表示已经生成了一个完整的排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径 path 的副本加入结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 path 已经包含当前元素 nums[i]，则跳过该元素</span></span><br><span class="line">            <span class="keyword">if</span> (path.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将当前元素添加到排列路径 path 中</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归调用回溯函数，处理下一个元素</span></span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            <span class="comment">// 回溯：移除路径中的最后一个元素</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：47-全排列-II"><a href="#题目2：47-全排列-II" class="headerlink" title="题目2：47. 全排列 II"></a>题目2：<a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[<span class="comment">[1,1,2]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[1,2,1]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[2,1,1]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><ul>
<li><p>使用哈希集合去重的思路来源于：<a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 非递减子序列</a></p>
</li>
<li><p>使用排序去重思路来源于：<a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p>
</li>
</ul>
<h3 id="2-1-回溯算法-哈希集合去重"><a href="#2-1-回溯算法-哈希集合去重" class="headerlink" title="2.1 回溯算法-哈希集合去重"></a>2.1 回溯算法-哈希集合去重</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储最终结果的列表，result 用于存储所有可能的全排列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前排列路径的列表，path 用于构建当前的排列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 permuteUnique，输入一个包含重复元素的整数数组 nums，返回其所有不重复的全排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回溯算法，初始化标记数组，并开始回溯</span></span><br><span class="line">        backtracking(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法方法 backtracking，用于生成所有可能的不重复全排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 当路径的长度等于数组的长度时，表示已经生成一个完整的排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径 path 的副本加入结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一个 Set 集合去重，避免在同一层中使用相同的元素</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素已经被使用，或在同一层中已添加到 set 集合，则跳过该元素</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] || set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 添加当前元素到 set 集合，表示在当前层已经处理过该元素</span></span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="comment">// 标记当前元素为已使用</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 将当前元素添加到排列路径中</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归处理下一个元素</span></span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            <span class="comment">// 回溯：移除路径中的最后一个元素</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 重置当前元素的使用状态，以便回溯到上一步</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-回溯算法-哈希数组去重"><a href="#2-2-回溯算法-哈希数组去重" class="headerlink" title="2.2 回溯算法-哈希数组去重"></a>2.2 回溯算法-哈希数组去重</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储最终结果的列表，保存所有不重复的全排列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储当前排列路径的列表，用于构建每一个排列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，输入一个包含重复数字的数组 nums，返回所有不重复的全排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]; <span class="comment">// 标记数组，记录每个数字是否已经在当前排列中使用过</span></span><br><span class="line">        backtracking(nums, used); <span class="comment">// 调用回溯算法开始生成全排列</span></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回生成的所有不重复全排列结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法方法，用于生成所有不重复的全排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 当当前排列路径的长度等于数组的长度时，表示已生成一个完整的排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="comment">// 将当前路径保存到结果列表中</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">21</span>]; <span class="comment">// 哈希数组，避免同一层中使用相同的数字，范围 [-10, 10] 映射为 [0, 20]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素，尝试将其加入当前排列路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素已经使用过，或者在本轮递归中已经处理过相同的元素，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] || hash[nums[i] + <span class="number">10</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 标记该元素为已使用</span></span><br><span class="line">            hash[nums[i] + <span class="number">10</span>] = <span class="number">1</span>; <span class="comment">// 在哈希数组中记录该元素本轮递归已使用</span></span><br><span class="line">            path.add(nums[i]); <span class="comment">// 将当前元素加入排列路径</span></span><br><span class="line">            </span><br><span class="line">            backtracking(nums, used); <span class="comment">// 递归处理下一个元素</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 回溯过程：移除路径中的最后一个元素，并重置其使用状态</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); </span><br><span class="line">            used[i] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-回溯算法-排序去重"><a href="#2-3-回溯算法-排序去重" class="headerlink" title="2.3 回溯算法-排序去重"></a>2.3 回溯算法-排序去重</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储最终结果的列表，用于保存所有不重复的全排列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储当前排列路径的列表，用于构建每一个排列</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 permuteUnique，输入一个包含重复元素的整数数组 nums，返回其所有不重复的全排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组进行排序，便于后续剪枝去重</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 调用回溯算法，初始化标记数组并开始递归生成全排列</span></span><br><span class="line">        backtracking(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="comment">// 返回生成的所有不重复的全排列</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法，用于生成所有不重复的全排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 当路径的长度等于数组的长度时，表示已生成一个完整的排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径的副本加入结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素，尝试将其加入当前排列路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过重复的数字</span></span><br><span class="line">            <span class="comment">// nums[i] == nums[i-1] 保证当前数字和前一个相同</span></span><br><span class="line">            <span class="comment">// used[i-1] == false 保证是在同一层级使用过该元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前元素未使用过</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>; <span class="comment">// 标记当前元素为已使用</span></span><br><span class="line">                path.add(nums[i]); <span class="comment">// 将元素加入当前排列路径</span></span><br><span class="line">                backtracking(nums, used); <span class="comment">// 递归处理下一个元素</span></span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除最后加入的元素</span></span><br><span class="line">                used[i] = <span class="literal">false</span>; <span class="comment">// 重置使用状态，以便后续递归使用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>补充：去重最为关键的代码为：、</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>如果改成 <code>used[i - 1] == true</code>， 也是正确的!</strong>，去重代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p>
<p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p>
<p>这么说是不是有点抽象？</p>
<p>来来来，我就用输入: [1,1,1] 来举一个例子。</p>
<p>树层上去重(used[i - 1] == false)，的树形结构如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png" alt="47.全排列II2"></p>
<p>树枝上去重（used[i - 1] == true）的树型结构如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png" alt="47.全排列II3"></p>
<p>大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>组合 | LeetCode-77     | 回溯算法 |</title>
    <url>/2024/09/02/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-77-39-40-216-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>回溯算法练习题</p>
</blockquote>
<h1 id="题目1：77-组合"><a href="#题目1：77-组合" class="headerlink" title="题目1：77.组合"></a>题目1：<a href="https://leetcode.cn/problems/combinations/">77.组合</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,4]</span>,</span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-回溯算法"><a href="#2-1-回溯算法" class="headerlink" title="2.1 回溯算法"></a>2.1 回溯算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 结果列表，用于存储所有组合</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前路径，用于生成组合</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，生成1到n中选择k个数字的所有组合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 开始回溯，从数字1开始</span></span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回所有组合的结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，n是范围的上限，k是组合的大小，startIndex是当前数字的起始索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前路径的大小等于k，说明已经生成了一个合法的组合</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径的拷贝添加到结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 退出当前回溯</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从startIndex开始，遍历到n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前数字添加到路径中</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            <span class="comment">// 递归调用回溯函数，继续生成组合</span></span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯，将最后一个数字从路径中移除</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意细节：<ul>
<li>细节1：每次递归的开始索引都是<code>i+1</code>，这样保证了不会重复，例如出现[3,4]和[4,3]的现象</li>
<li>细节2：</li>
</ul>
</li>
</ul>
<h3 id="2-2-回溯优化"><a href="#2-2-回溯优化" class="headerlink" title="2.2 回溯优化"></a>2.2 回溯优化</h3><ul>
<li>图解：</li>
</ul>
<p><img src="./assets/image-20240902220333770.png" alt="image-20240902220333770"></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 结果列表，用于存储所有组合</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前路径，用于生成组合</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，生成1到n中选择k个数字的所有组合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 开始回溯，从数字1开始</span></span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回所有组合的结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，n是范围的上限，k是组合的大小，startIndex是当前数字的起始索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前路径的大小等于k，说明已经生成了一个合法的组合</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径的拷贝添加到结果列表中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 退出当前回溯</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化：计算当前可以选择的数字的最大值</span></span><br><span class="line">        <span class="comment">// 减少无效递归的次数，确保路径中还可以添加足够的数字以满足组合的长度要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前数字添加到路径中</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            <span class="comment">// 递归调用回溯函数，继续生成组合</span></span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯，将最后一个数字从路径中移除</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码说明：<ul>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ul>
</li>
</ul>
<h1 id="题目2：39-组合总和"><a href="#题目2：39-组合总和" class="headerlink" title="题目2：39.组合总和"></a>题目2：<a href="https://leetcode.cn/problems/combination-sum/">39.组合总和</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和<span class="number"> 3 </span>可以形成一组候选，2 +<span class="number"> 2 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。注意<span class="number"> 2 </span>可以使用多次。</span><br><span class="line">7 也是一个候选，<span class="number"> 7 </span>=<span class="number"> 7 </span>。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,3,5]</span>, target = 8</span><br><span class="line">输出: <span class="comment">[<span class="comment">[2,2,2,2]</span>,<span class="comment">[2,3,3]</span>,<span class="comment">[3,5]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2]</span>, target = 1</span><br><span class="line">输出: <span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储所有符合条件的组合结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于存储当前的组合路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法，用于调用回溯算法并返回结果</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 从第一个元素开始进行回溯</span></span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回所有符合条件的组合结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯方法，用于寻找所有和为 target 的组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> start)</span> &#123; </span><br><span class="line">        <span class="comment">// 如果当前路径的和等于目标值，将当前路径加入结果列表</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="comment">// 将当前路径的副本加入结果集</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 回溯终止，返回上层调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历候选数组，寻找下一步可能的组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum &lt; target; i++) &#123;</span><br><span class="line">            path.add(candidates[i]); <span class="comment">// 将当前元素加入路径</span></span><br><span class="line">            <span class="comment">// 递归调用回溯方法，继续寻找下一步组合</span></span><br><span class="line">            backtracking(candidates, target, sum + candidates[i], i); </span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除最后一个加入的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目3：40-组合总和II"><a href="#题目3：40-组合总和II" class="headerlink" title="题目3：40.组合总和II"></a>题目3：<a href="https://leetcode.cn/problems/combination-sum-ii/">40.组合总和II</a></h1><h2 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[10,1,2,7,6,1,5]</span>, target = 8,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,1,6]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,5]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,7]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[2,6]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,5,2,1,2]</span>, target = 5,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,2]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[5]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 100</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<h2 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="题目4：216-组合总和III"><a href="#题目4：216-组合总和III" class="headerlink" title="题目4：216.组合总和III"></a>题目4：<a href="https://leetcode.cn/problems/combination-sum-iii/">216.组合总和III</a></h1><h2 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong> </li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: <span class="string">[[1,2,4]]</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 +<span class="number"> 2 </span>+<span class="number"> 6 </span>= 9</span><br><span class="line">1 +<span class="number"> 3 </span>+<span class="number"> 5 </span>= 9</span><br><span class="line">2 +<span class="number"> 3 </span>+<span class="number"> 4 </span>= 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: k = 4, n = 1</span></span><br><span class="line"><span class="section">输出: []</span></span><br><span class="line"><span class="section">解释: 不存在有效的组合。</span></span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>2 &lt;= k &lt;= 9</code></li>
<li><code>1 &lt;= n &lt;= 60</code></li>
</ul>
<h2 id="2-题解-3"><a href="#2-题解-3" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-写法1"><a href="#2-1-写法1" class="headerlink" title="2.1 写法1"></a>2.1 写法1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储所有满足条件的组合结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前的组合路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法：求和为n的k个数的所有组合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 从数字1开始进行回溯</span></span><br><span class="line">        backtracking(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯方法：生成符合条件的组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件：当路径中的数字数量达到k时</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算路径中所有数字的总和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) sum += path.get(i);</span><br><span class="line">            <span class="comment">// 如果总和等于目标值n，则将该路径加入结果列表</span></span><br><span class="line">            <span class="keyword">if</span> (sum == n) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 终止当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从startIndex开始遍历数字1到9</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            path.add(i); <span class="comment">// 将当前数字加入路径</span></span><br><span class="line">            <span class="comment">// 递归调用，将下一个数字加入路径，i+1确保每个数字只用一次</span></span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径中的最后一个数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-优化1"><a href="#2-2-优化1" class="headerlink" title="2.2 优化1"></a>2.2 优化1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储所有满足条件的组合结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前的组合路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法：求和为n的k个数的所有组合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 从数字1开始进行回溯</span></span><br><span class="line">        backtracking(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯方法：生成符合条件的组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件：当路径中的数字数量达到k时</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算路径中所有数字的总和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) sum += path.get(i);</span><br><span class="line">            <span class="comment">// 如果总和等于目标值n，则将该路径加入结果列表</span></span><br><span class="line">            <span class="keyword">if</span> (sum == n) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 终止当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化后的循环：限制循环范围以减少不必要的遍历</span></span><br><span class="line">        <span class="comment">// 当path.size()已选择的数字数和剩余的k-path.size()个数字无法满足1-9的范围时，循环提前结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.add(i); <span class="comment">// 将当前数字加入路径</span></span><br><span class="line">            <span class="comment">// 递归调用，将下一个数字加入路径，i+1确保每个数字只用一次</span></span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径中的最后一个数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-优化2（推荐）"><a href="#2-3-优化2（推荐）" class="headerlink" title="2.3 优化2（推荐）"></a>2.3 优化2（推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储所有满足条件的组合结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前的组合路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法：求和为n的k个数的所有组合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化回溯，起始索引为1，总和为0</span></span><br><span class="line">        backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯方法：生成符合条件的组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件：当路径中的数字数量达到k时</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="comment">// 如果当前路径的总和等于目标值n，则将路径加入结果列表</span></span><br><span class="line">            <span class="keyword">if</span> (sum == n) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 终止当前递归</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化后的循环：限制循环范围以减少不必要的遍历</span></span><br><span class="line">        <span class="comment">// 当剩余的数字数量不足以组成所需的k个数字时，提前结束循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.add(i); <span class="comment">// 将当前数字加入路径</span></span><br><span class="line">            <span class="comment">//sum += i; // 更新当前路径的总和</span></span><br><span class="line">            <span class="comment">// 递归调用，将下一个数字加入路径，i+1确保每个数字只用一次</span></span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>, sum + i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径中的最后一个数字</span></span><br><span class="line">            <span class="comment">//sum -= i; // 恢复总和为添加当前数字之前的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后 | LeetCode-51 | 回溯算法</title>
    <url>/2024/09/11/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-51-N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<blockquote>
<p>回溯算法练习题</p>
</blockquote>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/n-queens/">51. N 皇后<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：[[<span class="string">&quot;.Q..&quot;</span>,<span class="string">&quot;...Q&quot;</span>,<span class="string">&quot;Q...&quot;</span>,<span class="string">&quot;..Q.&quot;</span>],[<span class="string">&quot;..Q.&quot;</span>,<span class="string">&quot;Q...&quot;</span>,<span class="string">&quot;...Q&quot;</span>,<span class="string">&quot;.Q..&quot;</span>]]</span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[&quot;Q&quot;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 9</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-回溯算法-写法1"><a href="#2-1-回溯算法-写法1" class="headerlink" title="2.1 回溯算法-写法1"></a>2.1 回溯算法-写法1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义保存最终结果的列表，每个解法是一个List&lt;String&gt;，代表棋盘上的布局</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义保存当前棋盘路径的列表，存放字符串形式的每一行布局</span></span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，负责初始化棋盘并调用回溯算法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义棋盘，char数组，用 &#x27;.&#x27; 表示空位</span></span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化棋盘，每个位置都填充为 &#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                chessboard[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(chessboard, n, <span class="number">0</span>);<span class="comment">// 开始回溯算法，从第0行开始放置皇后</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">// 返回所有可能的解法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，递归尝试每一行的不同列位置放置皇后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessboard, <span class="type">int</span> n, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前路径长度等于n，说明已经找到一个解法，加入结果集中</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == n) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));  <span class="comment">// 将当前路径加入到结果中</span></span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 回溯终止条件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在当前行（depth）每一列放置皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置放置皇后合法</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(chessboard, n, depth, col)) &#123;</span><br><span class="line">                <span class="comment">// 构建当前行的字符串表示，并在指定列放置 &#x27;Q&#x27;</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) sb.append(<span class="string">&quot;.&quot;</span>);  <span class="comment">// 初始化为全是空位 &#x27;.&#x27;</span></span><br><span class="line">                sb.replace(col, col + <span class="number">1</span>, <span class="string">&quot;Q&quot;</span>);  <span class="comment">// 在col列位置放置皇后 &#x27;Q&#x27;</span></span><br><span class="line">                path.add(sb.toString());<span class="comment">// 将当前行加入路径</span></span><br><span class="line">                chessboard[depth][col] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">// 在棋盘上放置皇后</span></span><br><span class="line">                backtracking(chessboard, n, depth + <span class="number">1</span>);<span class="comment">// 递归放置下一行的皇后</span></span><br><span class="line">                chessboard[depth][col] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">// 回溯，移除当前行的皇后</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 回溯，移除当前行的字符串布局</span></span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);  <span class="comment">// 使用 path.removeLast() 会出错，因为 List 不支持这个方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断在棋盘的(row, col)位置放置皇后是否合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessboard, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前列是否有其他皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 当前列已经有皇后，放置非法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断135度对角线（左上到右下）是否有其他皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 135度对角线上已经有皇后</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断45度对角线（右上到左下）是否有其他皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 45度对角线上已经有皇后</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 没有冲突，放置合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-回溯算法-写法1-优化"><a href="#2-2-回溯算法-写法1-优化" class="headerlink" title="2.2 回溯算法-写法1-优化"></a>2.2 回溯算法-写法1-优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储最终结果的列表，每个解法是一个 List&lt;String&gt;，表示棋盘的布局</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主函数，初始化棋盘并调用回溯算法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义棋盘，初始化为 &#x27;.&#x27; 表示空位</span></span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                chessboard[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用回溯函数，开始从第0行放置皇后</span></span><br><span class="line">        backtracking(chessboard, n, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回所有可能的解法</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，递归尝试每一行的不同列放置皇后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] chessboard, <span class="type">int</span> n, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经放置了n个皇后，说明找到一个解，保存结果</span></span><br><span class="line">        <span class="keyword">if</span>(depth == n) &#123;</span><br><span class="line">            result.add(arrayToList(chessboard));  <span class="comment">// 将棋盘的当前布局转为列表并加入结果</span></span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 回溯终止条件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在当前行（depth）的每一列放置皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 如果在 (depth, col) 放置皇后合法</span></span><br><span class="line">            <span class="keyword">if</span>(isValid(chessboard, n, depth, col)) &#123;</span><br><span class="line">                <span class="comment">// 在棋盘上放置皇后</span></span><br><span class="line">                chessboard[depth][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 递归放置下一行的皇后</span></span><br><span class="line">                backtracking(chessboard, n, depth + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 回溯，撤销当前行的皇后</span></span><br><span class="line">                chessboard[depth][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将棋盘转换为字符串列表，便于保存结果</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] chs : chessboard) &#123;</span><br><span class="line">            <span class="comment">// 将每一行的字符数组转换为字符串并加入列表</span></span><br><span class="line">            list.add(String.copyValueOf(chs));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断在棋盘 (row, col) 位置放置皇后是否合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] chessboard, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前列是否有其他皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 同列有冲突</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断135度对角线（左上到右下）是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 135度对角线上有冲突</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断45度对角线（右上到左下）是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 45度对角线上有冲突</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 没有冲突，放置合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>子集 | LeetCode-78 | 回溯算法</title>
    <url>/2024/09/08/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-78-90-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<center> <b>回溯算法练习题 | 子集问题</b>

---

<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/subsets/">78. 子集<a/></b>
</center>

<hr>
<h1 id="题目1：78-子集"><a href="#题目1：78-子集" class="headerlink" title="题目1：78. 子集"></a>题目1：<a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[]</span>,<span class="comment">[1]</span>,<span class="comment">[2]</span>,<span class="comment">[1,2]</span>,<span class="comment">[3]</span>,<span class="comment">[1,3]</span>,<span class="comment">[2,3]</span>,<span class="comment">[1,2,3]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个列表 result，用于存储最终生成的所有子集</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">// path 用于存储当前路径的子集</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 主方法 subsets，输入一个整数数组 nums，返回所有可能的子集</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回溯算法生成所有子集，初始从索引 0 开始</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法方法 backtracking，构建不同大小的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次递归调用时，将当前路径 path 的副本加入结果列表中</span></span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 start 已经到达数组末尾，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，从 start 开始选择当前元素作为子集的一部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素加入路径 path</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归调用 backtracking 处理下一个元素，生成包含当前元素的子集</span></span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯：移除最后加入的元素，尝试其他组合</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：90-子集-II"><a href="#题目2：90-子集-II" class="headerlink" title="题目2：90. 子集 II"></a>题目2：<a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,2]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[]</span>,<span class="comment">[1]</span>,<span class="comment">[1,2]</span>,<span class="comment">[1,2,2]</span>,<span class="comment">[2]</span>,<span class="comment">[2,2]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储最终的子集结果</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储当前路径的子集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序以便去重</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>); <span class="comment">// 从索引 0 开始回溯</span></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回所有子集结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="comment">// 将当前路径加入结果列表</span></span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) <span class="keyword">return</span>; <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复元素</span></span><br><span class="line">            path.add(nums[i]); <span class="comment">// 将当前元素加入路径</span></span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>); <span class="comment">// 递归处理下一个元素</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯：移除最后添加的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复原IP地址 | LeetCode-93 | 回溯算法 | 切割</title>
    <url>/2024/09/05/algorithm/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/LeetCode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<blockquote>
<p>回溯算法练习题</p>
</blockquote>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;255.255.11.135&quot;</span>,<span class="string">&quot;255.255.111.35&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;0000&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;0.0.0.0&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;101023&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;1.0.10.23&quot;</span>,<span class="string">&quot;1.0.102.3&quot;</span>,<span class="string">&quot;10.1.0.23&quot;</span>,<span class="string">&quot;10.10.2.3&quot;</span>,<span class="string">&quot;101.0.2.3&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅由数字组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个列表 result，用于存储最终生成的所有合法的 IP 地址</span></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法 restoreIpAddresses，输入一个字符串 s，返回所有可能的合法 IP 地址</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果字符串的长度不在有效范围内（4 到 12），直接返回空结果</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">4</span> || s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 使用回溯算法生成所有可能的 IP 地址</span></span><br><span class="line">        backtracking(s, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法方法 backtracking，构建有效的 IP 地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当分割为 3 段时，处理剩下的最后一段</span></span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果剩余部分的长度超过 3 或 start 越界，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (len - (start + <span class="number">1</span>) &gt; <span class="number">3</span> || start &gt;= len) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 提取最后一段的字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(start, len);</span><br><span class="line">            <span class="comment">// 检查这段字符串是否合法，如果合法则加入到结果中</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(sub)) &#123;</span><br><span class="line">                sb.append(sub);  <span class="comment">// 添加最后一段</span></span><br><span class="line">                result.add(sb.toString());  <span class="comment">// 将完整的 IP 地址添加到结果列表中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 start 开始，最多取 3 位字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; len &amp;&amp; i - start &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 提取从 start 到 i 的子字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(start, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果当前段不合法，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!isValid(sub)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 添加当前段到 StringBuilder，并添加一个 &#x27;.&#x27; 分隔符</span></span><br><span class="line">            sb.append(sub).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="comment">// 递归处理剩余的字符串</span></span><br><span class="line">            backtracking(s, sb, i + <span class="number">1</span>, level + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯：删除刚才添加的字符，以便尝试其他组合</span></span><br><span class="line">            sb.delete(start + level, sb.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法 isValid，用于判断一个字符串是否为合法的 IP 地址段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果字符串长度大于 1 且以 &#x27;0&#x27; 开头，则该段不合法（IP 段不能以 &#x27;0&#x27; 开头）</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查字符串中的字符是否全为数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串转换为整数，并检查是否在 0 到 255 的范围内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> num &gt;=<span class="number">0</span> &amp;&amp; num &lt;=<span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h1><p>给定一个字符串 <code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code>；如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code>；如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code>。</p>
<p><strong>有效的 IPv4 地址:</strong> 是<code>x1.x2.x3.x4</code>形式的 IP 地址，其中<code>0 &lt;= xi &lt;= 255</code>，且<code>xi</code>不能包含前导零。</p>
<ul>
<li>例如：<code>&quot;192.168.1.1&quot;</code> 是有效的 IPv4 地址。</li>
<li><code>&quot;192.168.1.01&quot;</code>、<code>&quot;192.168.1.00&quot;</code>、<code>&quot;192.168@1.1&quot;</code> 是无效的 IPv4 地址。</li>
</ul>
<p><strong>有效的 IPv6 地址:</strong> 是<code>x1:x2:x3:x4:x5:x6:x7:x8</code>形式的 IP 地址，其中<code>1&lt;=xi.length&lt;=4</code>，<code>xi</code>是一个十六进制字符串，可以包含数字、小写字母（从 ‘a’到 ‘f’）和大写字母（从 ‘A’到 ‘F’），在<code>xi</code>中允许前导零。</p>
<ul>
<li>例如：<code>&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是有效的 IPv6 地址。</li>
<li><code>&quot;2001:db8:85a3::8a2e:0370:7334&quot;</code> 和 <code>&quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是无效的 IPv6 地址。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>回溯算法</tag>
        <tag>切割</tag>
      </tags>
  </entry>
  <entry>
    <title>图解Floyd判圈算法 | 判断链表或者迭代函数是否有环 | Java代码</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E5%AD%A6/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center>
    <b>今天毛毛张分享的是Floyd判圈算法，这是刷LeetCode必备基础算法理论！</b>
</center>

<span id="more"></span>
<h1 id="1-Floyd判圈算法概述🍇"><a href="#1-Floyd判圈算法概述🍇" class="headerlink" title="1.Floyd判圈算法概述🍇"></a>1.Floyd判圈算法概述🍇</h1><ul>
<li>🍑<strong>定义：</strong> <code>Floyd</code>判圈算法（<code>Floyd Cycle Detection Algorithm</code>），又称龟兔赛跑算法（<code>Tortoise and Hare Algorithm</code>），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法🍏</li>
<li>🍒<strong>算法思想：</strong><ol>
<li>有限时间内快慢指针必然相遇且在相遇点在环上1️⃣</li>
<li>相遇点和起点的等速指针将在换的入口出相遇2️⃣</li>
</ol>
</li>
<li><p>🍓<strong>算法作用：</strong></p>
<ul>
<li>判断迭代函数或者链表上面是否有环1️⃣</li>
<li>如果有环可以找到环的起点2️⃣</li>
<li>如果有换可以计算环的长度3️⃣ </li>
</ul>
</li>
<li><p>🫐<strong>这个算法只需要大家了解其原理就行，毛毛张在这里不做严密的逻辑推导，而是通过推介举例的方式来帮助大家理解这个算法</strong></p>
</li>
</ul>
<h1 id="2-如何判断是否有环🍉"><a href="#2-如何判断是否有环🍉" class="headerlink" title="2.如何判断是否有环🍉"></a>2.如何判断是否有环🍉</h1><hr>
<center>
    <b>有限时间内快慢指针必然相遇且相遇点在环上</b>
</center>

<hr>
<ul>
<li>由于这个算法的另外一个名称是龟兔赛跑算法，因此毛毛张就拿龟兔赛跑的例子来举例说明：<ul>
<li>假设：我们可以假设有乌龟和兔子在一个跑道上比赛跑步，我们默认兔子的跑步速度是快于乌龟的</li>
<li>如果是直线型跑道，两者同时从起点出出发，中途乌龟是永远追不上兔子的，直到涂子到达终点</li>
<li>如果是环形跑道，两者同时从起点出发，经过有限的时间内，兔子会追上乌龟，两者相遇，如果运动过程中兔子的速度是乌龟速度的两倍，那么两者第一次相遇时，兔子的路程就是乌龟路程的两倍</li>
</ul>
</li>
<li><strong>上面这个例子是小学问题中一个很简单的相遇和追及问题，我们回到这个算法本身：</strong><ul>
<li><strong>假设兔子就是那个快指针<code>fast</code>，每次走两步，乌龟就是那个慢指针<code>slow</code>，每次走一步</strong></li>
<li><strong>如果链表或者迭代函数没用环，那么快指针迭代到终点，在此过程中，两个指针是不会相遇</strong></li>
<li><strong>如果链表或者迭代函数有环，那么快指针在迭代过程中一定会追上慢指针</strong></li>
</ul>
</li>
<li><strong>图解：</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/floyd/image-20240809104404465.png" alt="image-20240809104404465"></p>
<h1 id="3-如何找到环的起点🍍"><a href="#3-如何找到环的起点🍍" class="headerlink" title="3.如何找到环的起点🍍"></a>3.如何找到环的起点🍍</h1><hr>
<center>
    <b>相遇点和起点的等速指针将在换的入口出相遇</b>
</center>

<hr>
<ul>
<li><p>在上面的问题中，<strong>我们假设快指针的速度是慢指针的两倍</strong>，那么在相同时间内，第一次相遇的时候，<strong>快指针走过的距离为2n，慢指针走过的距离为n</strong>，因此单位时间内快指针比慢指针多走一个$n$；<strong>于是我们让慢指针回到起点，快指针还在相遇点，即让快指针先走$n$的距离；然后让两个指针的前进速度相同，区分为前指针和后指针</strong></p>
</li>
<li><p><strong>图解：</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/floyd/image-20240810201955223.png" alt="image-20240810201955223"></p>
<h1 id="4-计算环的长度🥭"><a href="#4-计算环的长度🥭" class="headerlink" title="4.计算环的长度🥭"></a>4.计算环的长度🥭</h1><ul>
<li><strong>顺着找到环的入口的思路</strong>，我们可以得到<strong>方式1：</strong>在找到环的入口后，一步一步遍历回到起点时，走过的距离就是环的长度</li>
<li><strong>顺着判断是否有环的思路</strong>，我们可以得到<strong>方式2：</strong> 在找到相遇点之后，继续执行并重新对快慢指针进行计步，直到快慢指针第二次相遇，此时快指针比慢指针多走的距离就是环的长度</li>
<li><strong>方式3：</strong> 当快慢指针相遇之后，让快指针一步一步遍历回到相遇点时，走过的距离就是环的长度</li>
</ul>
<h1 id="5-代码实现🍎"><a href="#5-代码实现🍎" class="headerlink" title="5.代码实现🍎"></a>5.代码实现🍎</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListCycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个有环的链表，环的长度为5</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">createCyclicLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">third</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fourth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fifth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sixth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        head.next = second;</span><br><span class="line">        second.next = third;</span><br><span class="line">        third.next = fourth;</span><br><span class="line">        fourth.next = fifth;</span><br><span class="line">        fifth.next = sixth;</span><br><span class="line">        sixth.next = third; <span class="comment">// 第三个节点为环的入口，环的长度为5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否有环</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到环的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断是否有环</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有环，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!hasCycle) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到环的入口</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算环的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCycleLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找到相遇点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有环，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (!hasCycle) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从相遇点开始计算环的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cycleLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            cycleLength++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cycleLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cyclicList</span> <span class="operator">=</span> createCyclicLinkedList();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Has cycle: &quot;</span> + hasCycle(cyclicList));</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cycleEntry</span> <span class="operator">=</span> detectCycle(cyclicList);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cycle entry node value: &quot;</span> + (cycleEntry != <span class="literal">null</span> ? cycleEntry.val : <span class="string">&quot;No cycle&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Cycle length: &quot;</span> + getCycleLength(cyclicList));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://blog.csdn.net/qq_43919533/article/details/129991996">https://blog.csdn.net/qq_43919533/article/details/129991996</a></li>
<li><a href="https://blog.csdn.net/weixin_45609535/article/details/125708493">https://blog.csdn.net/weixin_45609535/article/details/125708493</a></li>
<li><a href="https://blog.csdn.net/m0_50344530/article/details/114225317">https://blog.csdn.net/m0_50344530/article/details/114225317</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数 | LeetCode-203 | 一个简单的数学题！| Floyd判圈算法</title>
    <url>/2024/08/08/algorithm/leetcode/%E6%95%B0%E5%AD%A6/LeetCode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<center>
    <b>不知道Floyd判圈算法这道题做起来一点也不快乐！</b>
</center>





<span id="more"></span>
<center>
    <b><font color=darkorange face="楷体" size=4 >🙋大家好！我是毛毛张! </font></b>
    <hr>
    <b>
    LeetCode链接：<a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a>
    </b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 +<span class="number"> 92 </span>= 82</span><br><span class="line">82 +<span class="number"> 22 </span>= 68</span><br><span class="line">62 +<span class="number"> 82 </span>= 100</span><br><span class="line">12 +<span class="number"> 02 </span>+<span class="number"> 02 </span>= 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n &lt;= 2^{31} - 1$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-Floyd判圈算法"><a href="#2-1-Floyd判圈算法" class="headerlink" title="2.1 Floyd判圈算法"></a>2.1 Floyd判圈算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用快慢指针法检测环的存在。快指针每次移动两步，慢指针每次移动一步。</span></span><br><span class="line">        <span class="comment">// 初始时，快指针移动两次后的结果，慢指针移动一次后的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> iterator(iterator(n));</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> iterator(n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 快慢指针相遇时，说明存在环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = iterator(iterator(fast)); <span class="comment">// 快指针移动两次</span></span><br><span class="line">            slow = iterator(slow);           <span class="comment">// 慢指针移动一次</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针相遇后，判断是否在环的入口，即是否为1</span></span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法，用于计算数位平方和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iterator</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> n % <span class="number">10</span>; <span class="comment">// 取出最低位数字</span></span><br><span class="line">            sum += mod * mod; <span class="comment">// 计算该数字的平方并累加到sum</span></span><br><span class="line">            n = n / <span class="number">10</span>;       <span class="comment">// 去掉最低位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">// 返回累加的平方和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-哈希集合"><a href="#2-2-哈希集合" class="headerlink" title="2.2 哈希集合"></a>2.2 哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个集合用于存储计算过程中出现过的数字，防止出现无限循环</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n;  <span class="comment">// 当前需要检查的数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环进行计算，直到发现一个重复的数字</span></span><br><span class="line">        <span class="keyword">while</span> (!set.contains(cur)) &#123;</span><br><span class="line">            set.add(cur);  <span class="comment">// 将当前数字加入集合</span></span><br><span class="line">            cur = iterator(cur);  <span class="comment">// 计算当前数字每位的平方和</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果循环退出时，cur等于1，说明n是快乐数</span></span><br><span class="line">        <span class="keyword">return</span> cur == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个数字每位的平方和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iterator</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> n % <span class="number">10</span>;  <span class="comment">// 取出最低位数字</span></span><br><span class="line">            sum += mod * mod;  <span class="comment">// 计算该数字的平方并累加到sum</span></span><br><span class="line">            n = n / <span class="number">10</span>;  <span class="comment">// 去掉最低位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;  <span class="comment">// 返回累加的平方和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>排列硬币 | LeetCode-441 | 一个简单的数学题！</title>
    <url>/2024/07/28/algorithm/leetcode/%E6%95%B0%E5%AD%A6/LeetCode-441/</url>
    <content><![CDATA[<blockquote>
<p><b>这是LeetCode中一道标签为<font color="green">简单</font>的算法题，点击“阅读全文”即可查看题解！</b></p>
</blockquote>
<span id="more"></span>
<center>
    <b><font color=darkorange face="楷体" size=4 >🙋大家好！我是毛毛张! </font></b>
    <hr>
    <b>
    LeetCode链接：<a href="https://leetcode.cn/problems/arranging-coins/">441. 排列硬币</a>
    </b>
</center>

<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>你总共有 <code>n</code> 枚硬币，并计划将它们按阶梯状排列。对于一个由 <code>k</code> 行组成的阶梯，其第 <code>i</code> 行必须正好有 <code>i</code> 枚硬币。阶梯的最后一行 <strong>可能</strong> 是不完整的。</p>
<p>给你一个数字 <code>n</code> ，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg" alt="img"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：因为第三行不完整，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg" alt="img"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：因为第四行不完整，所以返回 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n &lt;= 2^{31} - 1$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-公式解法"><a href="#2-1-公式解法" class="headerlink" title="2.1 公式解法"></a>2.1 公式解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数学公式求解排列硬币问题</span></span><br><span class="line">        <span class="comment">// 使用 long 类型防止溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">long</span>) n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算公式：</span></span><br><span class="line">        <span class="comment">// 完整行数 k 满足的方程：k * (k + 1) / 2 &lt;= n</span></span><br><span class="line">        <span class="comment">// 变形成：k^2 + k &lt;= 2 * n</span></span><br><span class="line">        <span class="comment">// 转化为求解 k 的公式：k = (sqrt(8 * n + 1) - 1) / 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 k 的值，并将结果转换为 int 类型返回</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((Math.sqrt(<span class="number">8</span> * num + <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-暴力解法"><a href="#2-2-暴力解法" class="headerlink" title="2.2 暴力解法"></a>2.2 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化变量i为0，用于表示行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环判断能够放多少行完整的硬币</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// 增加行数</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 计算当前行数需要的硬币总数，使用long类型防止溢出</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">coins</span> <span class="operator">=</span> (<span class="type">long</span>) i * (<span class="number">1</span> + i) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 如果当前行数需要的硬币总数大于n，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (coins &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回完整行数的数量</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-二分查找"><a href="#2-3-二分查找" class="headerlink" title="2.3 二分查找"></a>2.3 二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化二分查找的左边界和右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用二分查找寻找最大完整行数</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 计算中间位置，防止整型溢出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前中间位置能放的硬币总数，使用 long 类型防止溢出</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">long</span>) mid * (<span class="number">1</span> + mid) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 n 小于当前总数，则说明完整行数过多，缩小右边界</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 修正为 right</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，说明当前行数可以放下 n，增加左边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回右边界，即最大完整行数</span></span><br><span class="line">        <span class="keyword">return</span> right; <span class="comment">// 返回完整行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>替换数字 | KamaCoder-54 | 简单</title>
    <url>/2024/08/09/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/KamaCoder-54-%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<center><b>这题除了简单就没什么了</b></center>

<span id="more"></span>
<hr>
<center>
    <b>卡码网链接：<a href="https://kamacoder.com/problempage.php?pid=1064">54. 替换数字（第八期模拟笔试）<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote>
<p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p>
</blockquote>
<h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><blockquote>
<p>输入一个字符串 s,s 仅包含小写字母和数字字符。</p>
</blockquote>
<h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><blockquote>
<p>打印一个新的字符串，其中每个数字字符都被替换为了number</p>
</blockquote>
<h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">a<span class="number">1</span>b<span class="number">2</span><span class="keyword">c</span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">anumberbnumbercnumber</span></span><br></pre></td></tr></table></figure>
<h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><blockquote>
<p>数据范围：</p>
<p>1 &lt;= s.length &lt; 10000</p>
</blockquote>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取输入的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">// 调用替换数字字符的函数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> replaceDigits(s);</span><br><span class="line">        <span class="comment">// 打印替换后的字符串</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换字符串中的数字字符为 &quot;number&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceDigits</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 使用StringBuilder构建新字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i); <span class="comment">// 获取字符串中的每一个字符</span></span><br><span class="line">            <span class="comment">// 检查字符是否为数字字符（ASCII 范围 &#x27;0&#x27;-&#x27;9&#x27;）</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;number&quot;</span>); <span class="comment">// 如果是数字字符，追加 &quot;number&quot; 到StringBuilder中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c); <span class="comment">// 如果是字母字符，保持不变，直接追加到StringBuilder中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString(); <span class="comment">// 将构建好的字符串返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>右旋字符串 | KamaCoder-55</title>
    <url>/2024/08/10/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/KamaCoder-55-%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<center><b>这题主要考察的逻辑思维</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://kamacoder.com/problempage.php?pid=1065">55. 右旋字符串<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote>
<p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 </p>
<p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p>
</blockquote>
<h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><blockquote>
<p>输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p>
</blockquote>
<h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><blockquote>
<p>输出共一行，为进行了右旋转操作后的字符串。</p>
</blockquote>
<h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">abcdefg</span><br></pre></td></tr></table></figure>
<h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">fgabcde</span></span><br></pre></td></tr></table></figure>
<h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><blockquote>
<p>数据范围：<br>1 &lt;= k &lt; 10000,<br>1 &lt;= s.length &lt; 10000;</p>
</blockquote>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-内置函数"><a href="#2-1-内置函数" class="headerlink" title="2.1 内置函数"></a>2.1 内置函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象用于读取用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取用户输入的整数 k，表示旋转的位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(sc.nextLine());</span><br><span class="line">        <span class="comment">// 读取用户输入的字符串 s</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        <span class="comment">// 调用 rotate 方法进行字符串旋转，并打印结果</span></span><br><span class="line">        System.out.println(rotate(s, k));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">rotate</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 StringBuilder 对象用于构建旋转后的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 将字符串的后 k 个字符追加到 StringBuilder 中</span></span><br><span class="line">        sb.append(s.substring(s.length() - k, s.length()));</span><br><span class="line">        <span class="comment">// 将字符串的前部分（除去后 k 个字符）追加到 StringBuilder 中</span></span><br><span class="line">        sb.append(s.substring(<span class="number">0</span>, s.length() - k));</span><br><span class="line">        <span class="comment">// 将 StringBuilder 转换为字符串并返回</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-整体反转-局部反转"><a href="#2-2-整体反转-局部反转" class="headerlink" title="2.2 整体反转+局部反转"></a>2.2 整体反转+局部反转</h2><ul>
<li>图解：</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231106172058.png" alt="img"></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象用于从标准输入读取用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取用户输入的整数 k，表示需要旋转的位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(sc.nextLine());</span><br><span class="line">        <span class="comment">// 读取用户输入的字符串 s</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组，方便操作</span></span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 获取字符数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chs.length;</span><br><span class="line">        <span class="comment">// 第一步：反转字符串的前 len - k 个字符</span></span><br><span class="line">        reverse(chs, <span class="number">0</span>, len - k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 第二步：反转字符串的后 k 个字符</span></span><br><span class="line">        reverse(chs, len - k, len - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 第三步：反转整个字符串</span></span><br><span class="line">        reverse(chs, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 输出最终旋转后的字符数组（即字符串）</span></span><br><span class="line">        System.out.println(chs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转字符数组中从 begin 到 end 的部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 交换 begin 和 end 位置的字符，直到两个指针相遇</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chs[begin];  <span class="comment">// 保存 begin 位置的字符</span></span><br><span class="line">            chs[begin++] = chs[end]; <span class="comment">// 将 end 位置的字符赋值给 begin</span></span><br><span class="line">            chs[end--] = temp;       <span class="comment">// 将保存的 temp 赋值给 end</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共前缀 | LeetCode-14</title>
    <url>/2024/09/15/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<center><b>这是一道一看就会，一做就错的题目！</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀<a/></b></p>
<h2 id="lt-center-gt"><a href="#lt-center-gt" class="headerlink" title="&lt;/center&gt;"></a>&lt;/center&gt;</h2><h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">strs</span> = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">strs</span> = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-横向扫描"><a href="#2-1-横向扫描" class="headerlink" title="2.1 横向扫描"></a>2.1 横向扫描</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果输入数组为空，直接返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化结果为第一个字符串。我们将不断缩短这个字符串，直到找到所有字符串的公共前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个字符串开始遍历，和结果字符串进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="comment">// 逐字符比较 result 和当前字符串 strs[i]</span></span><br><span class="line">            <span class="comment">// 比较的条件是：两个字符串都没有越界，并且字符相等</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; result.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;</span><br><span class="line">                <span class="comment">// 一旦找到不匹配的字符，停止比较</span></span><br><span class="line">                <span class="keyword">if</span> (result.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新 result 为当前匹配的最长前缀</span></span><br><span class="line">            result = result.substring(<span class="number">0</span>, j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 result 变成空字符串，意味着不存在公共前缀，直接返回空字符串</span></span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回找到的最长公共前缀</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图解：</li>
</ul>
<p><img src="https://assets.leetcode-cn.com/solution-static/14/14_fig1.png" alt="fig1"></p>
<h2 id="2-2-纵向扫描"><a href="#2-2-纵向扫描" class="headerlink" title="2.2 纵向扫描"></a>2.2 纵向扫描</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果输入为空或字符串数组长度为0，直接返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取第一个字符串的长度，用于后续的字符比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">// 获取字符串数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历第一个字符串的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个字符串中当前下标的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从第二个字符串开始，依次比较对应位置的字符是否一致</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果到达某个字符串的末尾，或当前字符与第一个字符串的字符不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="comment">// 返回第一个字符串的前缀，长度为i</span></span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果循环结束，说明所有字符串的前缀一致，返回第一个字符串</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图解</li>
</ul>
<p><img src="https://assets.leetcode-cn.com/solution-static/14/14_fig2.png" alt="fig2"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词 | LeetCode-151 | 字符串 | 6种写法</title>
    <url>/2024/08/10/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;the sky is blue&quot;</span></span><br><span class="line">输出：<span class="string">&quot;blue is sky the&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;  hello world  &quot;</span></span><br><span class="line">输出：<span class="string">&quot;world hello&quot;</span></span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;a good   example&quot;</span></span><br><span class="line">输出：<span class="string">&quot;example good a&quot;</span></span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^4$</li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li><p>思路：</p>
<ul>
<li>步骤1：去除字符串两端的空格</li>
<li>步骤2：反转字符串</li>
<li>步骤3：反转单词</li>
</ul>
</li>
<li><p>方法1使用内置函数</p>
</li>
<li>方法2三个步骤的内置函数均是单独写的</li>
<li>方法3步骤2和步骤3可以通过双指针合并</li>
</ul>
<h2 id="2-1-内置函数"><a href="#2-1-内置函数" class="headerlink" title="2.1 内置函数"></a>2.1 内置函数</h2><h3 id="2-1-1-写法1"><a href="#2-1-1-写法1" class="headerlink" title="2.1.1 写法1"></a>2.1.1 写法1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除字符串首尾的多余空格</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过正则表达式 &quot;\\s+&quot; 将字符串按照一个或多个空格进行分割，形成单词列表</span></span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转单词列表中的元素顺序</span></span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将反转后的单词列表重新拼接成一个字符串，中间用单个空格隔开</span></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-写法2"><a href="#2-1-2-写法2" class="headerlink" title="2.1.2 写法2"></a>2.1.2 写法2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照空格分割字符串，生成单词数组</span></span><br><span class="line">        String[] words = s.split(<span class="string">&quot; +&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 StringBuilder 高效地拼接字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 从后向前遍历单词数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 跳过空字符串</span></span><br><span class="line">            <span class="keyword">if</span> (words[i].isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 拼接单词并加上空格</span></span><br><span class="line">            sb.append(words[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉末尾的多余空格并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-写法3"><a href="#2-1-3-写法3" class="headerlink" title="2.1.3 写法3"></a>2.1.3 写法3</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(s.trim().split(<span class="string">&quot; +&quot;</span>))</span><br><span class="line">                     .filter(word -&gt; !word.isEmpty())</span><br><span class="line">                     .collect(Collectors.joining(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>解释：</li>
</ul>
<ol>
<li><strong><code>s.trim()</code></strong>:<ul>
<li>去除字符串首尾的空格。</li>
</ul>
</li>
<li><strong><code>split(&quot; +&quot;)</code></strong>:<ul>
<li>按照一个或多个空格分割字符串，生成单词数组。</li>
</ul>
</li>
<li><strong><code>stream()</code></strong>:<ul>
<li>将单词数组转换为流。</li>
</ul>
</li>
<li><strong><code>filter(word -&gt; !word.isEmpty())</code></strong>:<ul>
<li>过滤掉可能的空字符串元素。</li>
</ul>
</li>
<li><strong><code>collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot;&quot;))</code></strong>:<ul>
<li>使用 <code>Collectors.joining</code> 将流中的单词连接成一个字符串，以空格分隔。</li>
</ul>
</li>
</ol>
<h2 id="2-2-自行编写对应的函数"><a href="#2-2-自行编写对应的函数" class="headerlink" title="2.2 自行编写对应的函数"></a>2.2 自行编写对应的函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除多余的空格并返回字符数组</span></span><br><span class="line">        <span class="type">char</span>[] chs = trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转整个字符数组</span></span><br><span class="line">        reverse(chs, <span class="number">0</span>, chs.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转每个单词</span></span><br><span class="line">        reverseEachWord(chs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符数组转换回字符串并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] trimSpaces(String s) &#123;</span><br><span class="line">        <span class="comment">// 使用 StringBuilder 存储非空字符</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到首尾非空字符的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) right--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录非空字符并处理多余的空格</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 只在非空或前一个字符不是空格时添加字符</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回处理后的字符数组</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString().toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 反转字符数组中的字符</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 交换 begin 和 end 的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chs[end];</span><br><span class="line">            chs[end--] = chs[begin];</span><br><span class="line">            chs[begin++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历字符数组</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; chs.length) &#123;</span><br><span class="line">            <span class="comment">// 找到单词的结束位置</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; chs.length &amp;&amp; chs[end] != <span class="string">&#x27; &#x27;</span>) end++;</span><br><span class="line">            <span class="comment">// 反转当前单词</span></span><br><span class="line">            reverse(chs, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新 start，准备查找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-双指针"><a href="#2-3-双指针" class="headerlink" title="2.3 双指针"></a>2.3 双指针</h2><h3 id="2-3-1-写法1-自己写函数"><a href="#2-3-1-写法1-自己写函数" class="headerlink" title="2.3.1 写法1-自己写函数"></a>2.3.1 写法1-自己写函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 步骤1: 去除多余的空格</span></span><br><span class="line">        s = trimSpaces(s);</span><br><span class="line">        <span class="comment">// 创建一个 StringBuilder 用于存储结果</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length(); <span class="comment">// 字符串末尾的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> end - <span class="number">1</span>;  <span class="comment">// 从最后一个字符开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双指针从后向前遍历字符串</span></span><br><span class="line">        <span class="keyword">while</span> (begin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到单词的开始位置</span></span><br><span class="line">            <span class="keyword">while</span> (begin &gt;= <span class="number">0</span> &amp;&amp; s.charAt(begin) != <span class="string">&#x27; &#x27;</span>) begin--; <span class="comment">// 遇到空格退出循环</span></span><br><span class="line">            <span class="comment">// 获取子串并添加到结果中</span></span><br><span class="line">            sb.append(s.substring(begin + <span class="number">1</span>, end));</span><br><span class="line">            <span class="comment">// 如果不是最后一个单词，添加空格</span></span><br><span class="line">            <span class="keyword">if</span> (begin &gt; <span class="number">0</span>) sb.append(<span class="string">&#x27; &#x27;</span>); </span><br><span class="line">            <span class="comment">// 更新 end 和 begin 以继续查找下一个单词</span></span><br><span class="line">            end = begin; <span class="comment">// 更新 end 为当前单词的开始位置</span></span><br><span class="line">            begin--;     <span class="comment">// 移动到下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到首尾非空字符的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) right--;</span><br><span class="line">        <span class="comment">// 记录非空字符并处理多余的空格</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 只在非空或前一个字符不是空格时添加字符</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回处理后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-写法2-内置函数"><a href="#2-3-2-写法2-内置函数" class="headerlink" title="2.3.2 写法2-内置函数"></a>2.3.2 写法2-内置函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 步骤1: 去除首尾空格</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 StringBuilder 用于构建结果字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; <span class="comment">// 记录字符串的末尾索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> end; <span class="comment">// 从末尾开始查找单词</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双指针从后向前遍历字符串</span></span><br><span class="line">        <span class="keyword">while</span> (begin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到当前单词的开始位置</span></span><br><span class="line">            <span class="keyword">while</span> (begin &gt;= <span class="number">0</span> &amp;&amp; s.charAt(begin) != <span class="string">&#x27; &#x27;</span>) begin--; <span class="comment">// 遇到空格退出循环</span></span><br><span class="line">            <span class="comment">// 获取当前单词并添加到结果中</span></span><br><span class="line">            sb.append(s.substring(begin + <span class="number">1</span>, end + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 如果不是最后一个单词，则在单词后添加空格</span></span><br><span class="line">            <span class="keyword">if</span> (begin &gt; <span class="number">0</span>) sb.append(<span class="string">&#x27; &#x27;</span>); </span><br><span class="line">            <span class="comment">// 跳过空格，更新 begin 以找到下一个单词</span></span><br><span class="line">            <span class="keyword">while</span> (begin &gt;= <span class="number">0</span> &amp;&amp; s.charAt(begin) == <span class="string">&#x27; &#x27;</span>) begin--; <span class="comment">// 遇到字母退出循环</span></span><br><span class="line">            <span class="comment">// 更新 end 为当前单词的开始位置</span></span><br><span class="line">            end = begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终构建的字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词 | LeetCode-242 | 哈希集合</title>
    <url>/2024/08/01/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<center><b>在字符串中，如果能使用哈希集合，那么大概率也能使用哈希数组</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p>
<p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;anagram&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;rat&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;car&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>$1 &lt;= s.length, t.length &lt;= 5 * 10^4$</li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-哈希集合"><a href="#2-1-哈希集合" class="headerlink" title="2.1 哈希集合"></a>2.1 哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用哈希表来记录每个字符的频率</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 s，将每个字符的频率存入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">// 如果字符已存在于哈希表中，频率加 1；否则将其频率设为 1</span></span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 t，减少哈希表中每个字符的频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="comment">// 如果字符已存在于哈希表中，频率减 1；否则将其频率设为 -1</span></span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查哈希表中每个字符的频率</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="comment">// 如果任意字符的频率不为 0，则说明两个字符串不是字母异位词</span></span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有字符的频率都为 0，则说明两个字符串是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图解：<a href="https://leetcode.cn/problems/valid-anagram/solutions/1/242-you-xiao-de-zi-mu-yi-wei-ci-ha-xi-bi-cch7/">https://leetcode.cn/problems/valid-anagram/solutions/1/242-you-xiao-de-zi-mu-yi-wei-ci-ha-xi-bi-cch7/</a></li>
</ul>
<h2 id="2-2-哈希数组"><a href="#2-2-哈希数组" class="headerlink" title="2.2 哈希数组"></a>2.2 哈希数组</h2><ul>
<li>由于这道题目具有特殊性，只有小写字母，所有转化成哈希数组来做</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度为 26 的整型数组，用于存储每个字母的出现频率</span></span><br><span class="line">        <span class="type">int</span>[] chs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 s，统计每个字母的出现频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算字符对应的数组索引，并增加相应位置的计数</span></span><br><span class="line">            chs[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 t，减少每个字母的出现频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算字符对应的数组索引，并减少相应位置的计数</span></span><br><span class="line">            chs[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查数组中的每个计数是否为 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果有任意一个计数不为 0，表示 s 和 t 不是字母异位词</span></span><br><span class="line">            <span class="keyword">if</span>(chs[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有计数都为 0，表示 s 和 t 是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-暴力解法"><a href="#2-3-暴力解法" class="headerlink" title="2.3 暴力解法"></a>2.3 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果两个字符串的长度不同，它们不可能是字母异位词，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串 s 和 t 转换为字符数组</span></span><br><span class="line">        <span class="type">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] strt = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对两个字符数组进行排序</span></span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        Arrays.sort(strt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较排序后的字符数组是否相等</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(strs, strt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>哈希集合</tag>
        <tag>哈希数组</tag>
      </tags>
  </entry>
  <entry>
    <title>找出字符串中第一个匹配项的下标 | LeetCode-28 | KMP算法 | next数组 | Java</title>
    <url>/2024/08/14/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<center><b>KMP算法练习题</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标<span class="number"> 0 </span>和<span class="number"> 6 </span>处匹配。</span><br><span class="line">第一个匹配项的下标是<span class="number"> 0 </span>，所以返回<span class="number"> 0 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;leeto&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：<span class="string">&quot;leeto&quot;</span> 没有在 <span class="string">&quot;leetcode&quot;</span> 中出现，所以返回 -<span class="number">1</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= haystack.length, needle.length &lt;= 10^4$</li>
<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 如果 needle 是空字符串，返回 0，根据题目要求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 haystack，从索引 0 到 haystack.length() - needle.length()</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 检查当前子串是否与 needle 匹配</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; needle.length() &amp;&amp; haystack.charAt(i + j) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) &#123;<span class="comment">// 如果 j 达到 needle.length()，说明完全匹配</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 如果没有找到匹配的子串，返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-KMP算法"><a href="#2-2-KMP算法" class="headerlink" title="2.2 KMP算法"></a>2.2 KMP算法</h2><h3 id="2-2-1-KMP写法1（不减1）"><a href="#2-2-1-KMP写法1（不减1）" class="headerlink" title="2.2.1 KMP写法1（不减1）"></a>2.2.1 KMP写法1（不减1）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果 needle 是空字符串，返回 0，根据题目要求</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = getNext(needle);<span class="comment">// 生成 needle 的前缀函数数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 匹配指针，用于遍历 needle</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，根据前缀函数回退 j</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果字符匹配，增加 j</span></span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) j++;</span><br><span class="line">            <span class="comment">// 完全匹配，返回起始位置</span></span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到匹配，返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成前缀函数数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀指针</span></span><br><span class="line"></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个字符的前缀长度为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，回退前缀指针 j</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果字符匹配，前缀长度增加</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) j++;</span><br><span class="line">            <span class="comment">// 记录前缀长度到 next 数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-KMP写法2（减1）"><a href="#2-2-2-KMP写法2（减1）" class="headerlink" title="2.2.2 KMP写法2（减1）"></a>2.2.2 KMP写法2（减1）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 needle 是空字符串，返回 -1（根据题目要求）</span></span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 needle 的前缀函数数组，用于 KMP 算法</span></span><br><span class="line">        <span class="type">int</span>[] next = getNext(needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 匹配指针 j，用于遍历 needle。初始值为 -1，表示还没有匹配任何字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 haystack 中的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，根据前缀函数回退 j，直到找到一个可匹配的前缀位置或 j 变为 -1</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j + <span class="number">1</span>)) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符匹配，增加 j 以匹配 needle 的下一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j + <span class="number">1</span>)) j++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 j 达到了 needle 的最后一个字符的位置，表示找到了匹配的子串</span></span><br><span class="line">            <span class="keyword">if</span> (j == needle.length() - <span class="number">1</span>) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 如果没有找到匹配的子串，返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成前缀函数数组 next，用于 KMP 算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 前缀指针 j，初始值为 -1，表示还没有匹配任何前缀</span></span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;<span class="comment">// next[0] 初始化为 -1，表示第一个字符没有前缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个字符开始，遍历整个字符串 s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，回退前缀指针 j，直到找到一个可匹配的前缀位置或 j 变为 -1</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j + <span class="number">1</span>)) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j + <span class="number">1</span>)) j++;<span class="comment">// 如果当前字符匹配，增加 j 以匹配下一个字符</span></span><br><span class="line">            next[i] = j; <span class="comment">// 记录前缀长度到 next 数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-KMP算法改进"><a href="#2-3-KMP算法改进" class="headerlink" title="2.3 KMP算法改进"></a>2.3 KMP算法改进</h2><ul>
<li><code>nextval</code> 数组是对 <code>next</code> 数组的进一步优化，主要用于加快失配后的回溯过程。<code>nextval</code> 数组在失配时可以避免一些不必要的匹配操作，从而提高算法的效率。</li>
</ul>
<h3 id="2-3-1-写法1（不减1）"><a href="#2-3-1-写法1（不减1）" class="headerlink" title="2.3.1 写法1（不减1）"></a>2.3.1 写法1（不减1）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成优化后的前缀函数数组 nextval</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNextval(String s) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] nextval = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀指针</span></span><br><span class="line"></span><br><span class="line">    nextval[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">// 第一个字符的前缀长度设为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前字符不匹配时，回退前缀指针 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j + <span class="number">1</span>)) &#123;</span><br><span class="line">            j = nextval[j]; <span class="comment">// 根据 nextval 数组回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果字符匹配，前缀长度增加</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j + <span class="number">1</span>)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前字符的前缀长度到 nextval 数组</span></span><br><span class="line">        nextval[i] = j; <span class="comment">// 当前字符的前缀长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-写法2（减1）"><a href="#2-3-2-写法2（减1）" class="headerlink" title="2.3.2 写法2（减1）"></a>2.3.2 写法2（减1）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getNextval(String s) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] nextval = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 前缀指针</span></span><br><span class="line">    nextval[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">// 初始化第一个字符的 nextval 为 -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 当当前字符不匹配时，回退前缀指针 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j + <span class="number">1</span>)) j = nextval[j]; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果字符匹配，前缀长度加一</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j + <span class="number">1</span>)) j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若失配时，当前字符与 nextval[j] 指向的字符相同，则使用 nextval[j]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; s.charAt(i + <span class="number">1</span>) == s.charAt(j + <span class="number">1</span>)) </span><br><span class="line">            nextval[i] = nextval[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextval[i] = j;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nextval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 3 | 无重复字符的最长子串 | 双指针 | 滑动窗口 | 2025兴业银行秋招笔试题 | 哈希集合</title>
    <url>/2024/08/04/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<center><b>这是一道银行的面试题，就是简单？！</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$0 &lt;= s.length &lt;= 5 * 10^4$</li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li>盲猜暴力解法肯定超时，毛毛张就不在这里介绍了</li>
<li>这个题目只需要最长子串的长度，做完可以尝试一下这道题目：<a href="https://zzxrepository.github.io/2024/08/01/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/">LeetCode:67.最小覆盖子串</a></li>
</ul>
<h2 id="2-1-双指针-哈希集合"><a href="#2-1-双指针-哈希集合" class="headerlink" title="2.1 双指针-哈希集合"></a>2.1 双指针-哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用一个Set来存储当前子串中的字符</span></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化左右指针和最大长度</span></span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左到右遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前字符</span></span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符不在Set中，更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(c)) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符在Set中，则移动左指针直到没有重复字符</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(c)) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前字符添加到Set中</span></span><br><span class="line">            set.add(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最大长度</span></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针-哈希数组"><a href="#2-2-双指针-哈希数组" class="headerlink" title="2.2 双指针-哈希数组"></a>2.2 双指针-哈希数组</h2><ul>
<li>如果能用哈希集合，那么大概率也可以使用哈希数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用一个大小为128的整数数组来记录字符出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 初始化左右指针和最大长度</span></span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左到右遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符在数组中的计数为0，更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span> (arr[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符在数组中的计数不为0，则移动左指针直到没有重复字符</span></span><br><span class="line">            <span class="keyword">while</span> (arr[c] != <span class="number">0</span>) &#123;</span><br><span class="line">                arr[s.charAt(left)]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前字符的计数加1</span></span><br><span class="line">            arr[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最大长度</span></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>哈希集合</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串 | LeetCode-344 | 双指针 | 通过率80% | 比二分查找还简单</title>
    <url>/2024/08/08/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = [<span class="string">&quot;H&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;h&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;H&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^5$</li>
<li><code>s[i]</code> 都是ASCII码表中的可打印字符</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-双指针"><a href="#2-1-双指针" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化左指针和右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当左指针小于右指针时，交换左右指针对应的字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 暂存右指针对应的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">            <span class="comment">// 将左指针对应的字符赋值给右指针位置，同时右指针向左移动</span></span><br><span class="line">            s[right--] = s[left];</span><br><span class="line">            <span class="comment">// 将暂存的右指针字符赋值给左指针位置，同时左指针向右移动</span></span><br><span class="line">            s[left++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>赎金信 | LeetCode-383 | 哈希集合</title>
    <url>/2024/08/09/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-383-%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    <content><![CDATA[<center><b>在字符串中，如果能使用哈希集合，那么大概率也能使用哈希数组</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">&quot;a&quot;</span>, <span class="attr">magazine</span> = <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">&quot;aa&quot;</span>, <span class="attr">magazine</span> = <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">&quot;aa&quot;</span>, <span class="attr">magazine</span> = <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= ransomNote.length, magazine.length &lt;= 10^5$</li>
<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-哈希集合"><a href="#2-1-哈希集合" class="headerlink" title="2.1 哈希集合"></a>2.1 哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希表用于存储 magazine 中每个字符出现的次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 magazine 字符串，将每个字符的出现次数记录到哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> magazine.charAt(i);  <span class="comment">// 获取当前字符</span></span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);  <span class="comment">// 更新字符出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 ransomNote 字符串，检查每个字符是否能够从 magazine 中取出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ransomNote.charAt(i);  <span class="comment">// 获取当前字符</span></span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);  <span class="comment">// 将字符在哈希表中的计数减1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历哈希表，检查是否有字符的计数为负数</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() &lt; <span class="number">0</span>)  <span class="comment">// 如果某个字符的计数为负数，说明 ransomNote 中需要的该字符多于 magazine 提供的字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 返回 false 表示无法构造</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有字符的计数都不为负数，返回 true 表示可以构造</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-哈希数组"><a href="#2-2-哈希数组" class="headerlink" title="2.2 哈希数组"></a>2.2 哈希数组</h2><ul>
<li>由于这道题目具有特殊性，只有小写字母，所有转化成哈希数组来做</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个大小为26的数组来记录magazine中每个字母的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] charCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历magazine字符串，将每个字符的出现次数记录到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> magazine.charAt(i);</span><br><span class="line">            charCounts[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历ransomNote字符串，检查每个字符是否能够从magazine中取出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ransomNote.charAt(i);</span><br><span class="line">            charCounts[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (charCounts[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果某个字符的计数变为负数，说明magazine中的该字符数量不足</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有字符的数量都足够，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>哈希集合</tag>
        <tag>哈希数组</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串 | LeetCode-459 | 字符串匹配 | KMP | 双指针</title>
    <url>/2024/08/14/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<center><b>KMP练习题</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;abab&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 可由子串 <span class="string">&quot;ab&quot;</span> 重复两次构成。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;abcabcabcabc&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 可由子串 <span class="string">&quot;abc&quot;</span> 重复四次构成。 (或子串 <span class="string">&quot;abcabc&quot;</span> 重复两次构成。)</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^4$</li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();  <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="comment">// 枚举可能的子串长度，最大长度为字符串长度的一半</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果字符串长度能被子串长度整除，说明可能由该长度的子串重复构成</span></span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="comment">// 检查从索引 i 开始的字符是否和子串的字符匹配</span></span><br><span class="line">                <span class="keyword">for</span>(j = i; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符与前面子串对应位置的字符不匹配，跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i)) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 j 遍历到了字符串的末尾，说明整个字符串可以由子串重复构成</span></span><br><span class="line">                <span class="keyword">if</span>(j == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到满足条件的子串，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-KMP-移动匹配"><a href="#2-2-KMP-移动匹配" class="headerlink" title="2.2 KMP - 移动匹配"></a>2.2 KMP - 移动匹配</h2><h3 id="2-2-1-内置函数"><a href="#2-2-1-内置函数" class="headerlink" title="2.2.1 内置函数"></a>2.2.1 内置函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 判断字符串 s 是否由一个子串重复组成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串 s 自身连接，并从索引 1 开始查找 s 的首次出现位置</span></span><br><span class="line">        <span class="comment">// 如果找到了且位置不等于 s 的长度，说明 s 是由一个子串重复组成</span></span><br><span class="line">        <span class="keyword">return</span> (s + s).indexOf(s, <span class="number">1</span>) != s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-KMP实现"><a href="#2-2-2-KMP实现" class="headerlink" title="2.2.2 KMP实现"></a>2.2.2 KMP实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 判断字符串 s 是否由一个子串重复组成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> s; <span class="comment">// 保存原始字符串</span></span><br><span class="line">        s = s + s; <span class="comment">// 将字符串 s 自身连接，形成新的字符串</span></span><br><span class="line">        <span class="type">int</span>[] next = getNext(goal); <span class="comment">// 生成目标字符串的前缀函数数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化匹配指针，用于遍历目标字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历新的字符串 s，直到 n*2-1 位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，根据前缀函数回退 j</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != goal.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果字符匹配，增加 j</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == goal.charAt(j)) j++;</span><br><span class="line">            <span class="comment">// 如果 j 达到目标字符串的长度，表示找到了重复子串</span></span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有找到符合条件的重复子串，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成前缀函数数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 初始化前缀函数数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀指针</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个字符的前缀长度为 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，从第二个字符开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class="number">1</span>];<span class="comment">// 当当前字符不匹配时，回退前缀指针 j</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) j++;<span class="comment">// 如果字符匹配，前缀长度增加</span></span><br><span class="line">            next[i] = j;<span class="comment">// 记录当前字符的前缀长度到 next 数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next; <span class="comment">// 返回前缀函数数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-KMP优化"><a href="#2-3-KMP优化" class="headerlink" title="2.3 KMP优化"></a>2.3 KMP优化</h2><ul>
<li>这个方法需要对种字符串的<code>next</code>数组的特征要了解，毛毛张在下面举几个例子<ul>
<li><strong>正例：</strong> 字符串<code>abababab</code>的<code>next</code>数组：<code>[0, 0, 1, 2, 3, 4, 5, 6]</code>  </li>
<li><strong>正例：</strong> 字符串<code>ababcababcababc</code>的<code>next</code>数组：<code>[0, 0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></li>
<li><strong>反例：</strong> 字符串<code>abcabca</code>的<code>next</code>数组：<code>[0, 0, 0, 1, 2, 3, 4]</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">int</span>[] next = getNext(s); <span class="comment">// 生成字符串 s 的前缀函数数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> n - next[n - <span class="number">1</span>]; <span class="comment">// 计算最小重复子串的长度</span></span><br><span class="line">		<span class="comment">//minLen &lt; n 是为了防止这种情况:abcdef 此时minLen=0 </span></span><br><span class="line">        <span class="comment">// 如果最小长度小于字符串长度，并且字符串长度能够被最小长度整除，则存在重复子串</span></span><br><span class="line">        <span class="keyword">if</span> (minLen &lt; n &amp;&amp; n % minLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 否则返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成前缀函数数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 初始化前缀函数数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀指针</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个字符的前缀长度为 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，从第二个字符开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class="number">1</span>];<span class="comment">// 当当前字符不匹配时，回退前缀指针 j</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) j++;<span class="comment">// 如果字符匹配，前缀长度增加</span></span><br><span class="line">            next[i] = j;<span class="comment">// 记录当前字符的前缀长度到 next 数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next; <span class="comment">// 返回前缀函数数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>字母异位词分组 | LeetCode-49 | 哈希集合</title>
    <url>/2024/10/02/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<center><b>在字符</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;bat&quot;</span>],[<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],[<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;&quot;</span>]</span><br><span class="line">输出: <span class="string">[[&quot;&quot;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;a&quot;</span>]</span><br><span class="line">输出: <span class="string">[[&quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= strs.length &lt;= 10^4$</li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1 排序"></a>2.1 排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希表用于存储异位词分组</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">            <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">            <span class="comment">// 对字符数组进行排序，得到异位词的统一表示</span></span><br><span class="line">            Arrays.sort(chs);</span><br><span class="line">            <span class="comment">// 将排序后的字符数组转换为字符串作为键</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">            <span class="comment">// 获取当前键对应的列表，如果不存在则创建一个新的列表</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            <span class="comment">// 将当前字符串加入对应的列表中</span></span><br><span class="line">            list.add(str);</span><br><span class="line">            <span class="comment">// 更新哈希表</span></span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有异位词分组，作为列表列表形式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码优化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.stream(strs)</span><br><span class="line">            .collect(Collectors.groupingBy(str -&gt; &#123;</span><br><span class="line">                <span class="comment">// 返回 str 排序后的结果。</span></span><br><span class="line">                <span class="comment">// 按排序后的结果来grouping by，算子类似于 sql 里的 group by。</span></span><br><span class="line">                <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">                Arrays.sort(array);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            &#125;)).values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// str -&gt; intstream -&gt; sort -&gt; collect by StringBuilder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.stream(strs).collect(Collectors.groupingBy(str -&gt; str.chars().sorted().collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::appendCodePoint, StringBuilder::append).toString())).values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-计数"><a href="#2-2-计数" class="headerlink" title="2.2 计数"></a>2.2 计数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希表，用于存储异位词分组</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输入字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="comment">// 创建一个长度为26的数组，记录每个字母在字符串中的出现次数</span></span><br><span class="line">            <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                counts[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用StringBuilder构造唯一的键，基于字符及其频率</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counts[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将字符及其出现次数加入到键中</span></span><br><span class="line">                    sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i)).append(counts[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前键对应的列表，如果不存在则创建一个新的列表</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            <span class="comment">// 将当前字符串加入对应的列表中</span></span><br><span class="line">            list.add(str);</span><br><span class="line">            <span class="comment">// 更新哈希表</span></span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有异位词分组，以列表列表的形式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串2 | LeetCode-541 | 双指针 | 分类讨论</title>
    <url>/2024/08/09/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/</url>
    <content><![CDATA[<center><b>这个题目除了分类讨论就没什么了</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abcdefg&quot;</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;bacdfeg&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;abcd&quot;</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;bacd&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^4$</li>
<li><code>s</code> 仅由小写英文组成</li>
<li>$1 &lt;= k &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-直接法"><a href="#2-1-直接法" class="headerlink" title="2.1 直接法"></a>2.1 直接法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组，方便操作</span></span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 计算完整的2k段的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> chs.length / (<span class="number">2</span> * k);</span><br><span class="line">        <span class="comment">// 逐段反转每个完整的k个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            reverseStr(chs, <span class="number">2</span> * i * k, <span class="number">2</span> * i * k + k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余的字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> chs.length % (<span class="number">2</span> * k);</span><br><span class="line">        <span class="comment">// 如果剩余的字符数大于或等于k，反转前k个字符</span></span><br><span class="line">        <span class="keyword">if</span> (mod &gt;= k) &#123;</span><br><span class="line">            reverseStr(chs, <span class="number">2</span> * count * k, <span class="number">2</span> * count * k + k - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 如果剩余的字符数小于k，反转所有剩余的字符</span></span><br><span class="line">            reverseStr(chs, <span class="number">2</span> * count * k, chs.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符数组转换回字符串并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转字符数组指定范围内的字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseStr</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 暂存末尾字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> chs[end];</span><br><span class="line">            <span class="comment">// 将开头字符赋值给末尾位置，同时末尾索引向前移动</span></span><br><span class="line">            chs[end--] = chs[begin];</span><br><span class="line">            <span class="comment">// 将暂存的末尾字符赋值给开头位置，同时开头索引向后移动</span></span><br><span class="line">            chs[begin++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组，方便对字符串进行操作</span></span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 初始化开始位置指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>, end;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐段处理字符数组</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; chs.length) &#123;</span><br><span class="line">            <span class="comment">// 计算剩余字符的长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">reaminLen</span> <span class="operator">=</span> chs.length - begin;</span><br><span class="line">            <span class="comment">// 确定本段反转的结束位置</span></span><br><span class="line">            end = reaminLen &gt;= k ? begin + k - <span class="number">1</span> : chs.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 反转从begin到end的字符</span></span><br><span class="line">            reverseStr(chs, begin, end);</span><br><span class="line">            <span class="comment">// 将起始位置指针向后移动2k位置</span></span><br><span class="line">            begin += <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符数组转换回字符串并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转字符数组中指定范围内的字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseStr</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 暂存末尾字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> chs[end];</span><br><span class="line">            <span class="comment">// 将开头字符赋值给末尾位置，同时末尾索引向前移动</span></span><br><span class="line">            chs[end--] = chs[begin];</span><br><span class="line">            <span class="comment">// 将暂存的末尾字符赋值给开头位置，同时开头索引向后移动</span></span><br><span class="line">            chs[begin++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCOde | 76 | 最小覆盖子串 | 双指针 | 滑动窗口 | 哈希集合</title>
    <url>/2024/08/01/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<center><b>这道题在LeetCode上的难度标签为：<font color="red">困难</font>！你能看出来这是一道用双指针就可以解决的题目吗？</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：s <span class="punctuation">=</span> <span class="string">&quot;ADOBECODEBANC&quot;</span><span class="punctuation">,</span> t <span class="punctuation">=</span> <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br><span class="line">解释：最小覆盖子串 <span class="string">&quot;BANC&quot;</span> 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入<span class="symbol">:</span> s = <span class="string">&quot;a&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="built_in">t</span> 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == s.length</code></li>
<li><code>n == t.length</code></li>
<li>$1 &lt;= m, n &lt;= 10^5$</li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法-超时"><a href="#2-1-暴力解法-超时" class="headerlink" title="2.1 暴力解法(超时)"></a>2.1 暴力解法(超时)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Map集合用于记录t字符串中的字母及其个数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最小长度为一个较大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 初始化左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于记录当前窗口的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于记录最终结果的子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历s字符串</span></span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>; left &lt; s.length(); left++) &#123;</span><br><span class="line">            <span class="comment">// 每次左指针移动时都重新创建一个countMap，复制map</span></span><br><span class="line">            Map&lt;Character, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(map);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从当前left位置开始移动右指针</span></span><br><span class="line">            <span class="keyword">for</span> (right = left; right &lt; s.length(); right++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">                <span class="comment">// 如果右指针位置的字符在countMap中，减少它的计数</span></span><br><span class="line">                <span class="keyword">if</span> (countMap.containsKey(c)) &#123;</span><br><span class="line">                    countMap.put(c, countMap.get(c) - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 如果计数减少到0，移除该字符</span></span><br><span class="line">                    <span class="keyword">if</span> (countMap.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        countMap.remove(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当countMap为空时，说明当前窗口包含了t中的所有字符</span></span><br><span class="line">                <span class="keyword">if</span> (countMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 计算当前窗口的长度</span></span><br><span class="line">                    length = right - left + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 更新最小长度和结果字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (length &lt; minLen) &#123;</span><br><span class="line">                        minLen = length;</span><br><span class="line">                        result = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针-哈希集合"><a href="#2-2-双指针-哈希集合" class="headerlink" title="2.2 双指针-哈希集合"></a>2.2 双指针-哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Map集合用于记录t字符串中的字母及其个数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建Map集合用于记录s字符串滑动窗口过程中的字母及其个数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到字符串s中包含字符串t所有字符的最小子串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 字符串s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 字符串t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含字符串t所有字符的最小子串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化tMap，用于记录t字符串中的每个字符及其出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            tMap.put(c, tMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最小长度和结果字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滑动窗口的左右指针</span></span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="comment">// 遍历s字符串</span></span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前字符</span></span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">// 将当前字符加入sMap中，记录其出现次数</span></span><br><span class="line">            sMap.put(c, sMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当滑动窗口中包含t字符串的所有字符时，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> (check()) &#123;</span><br><span class="line">                <span class="comment">// 更新最小长度和结果字符串</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (length &lt; minLen) &#123;</span><br><span class="line">                    minLen = length;</span><br><span class="line">                    result = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移除左边界的字符，并更新sMap中的计数</span></span><br><span class="line">                c = s.charAt(left);</span><br><span class="line">                sMap.put(c, sMap.get(c) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 收缩左边界</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最小窗口的子串</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查当前滑动窗口是否包含t字符串中的所有字符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果包含所有字符，返回true；否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历tMap中的每个字符及其计数</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : tMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 如果sMap中当前字符的计数小于tMap中的计数，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (sMap.getOrDefault(c, <span class="number">0</span>) &lt; entry.getValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果sMap中包含tMap中的所有字符及其计数，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-双指针-哈希数组"><a href="#2-3-双指针-哈希数组" class="headerlink" title="2.3 双指针-哈希数组"></a>2.3 双指针-哈希数组</h2><ul>
<li>如果能用哈希集合，那么大概率也可以使用哈希数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主方法，寻找字符串 s 中包含字符串 t 的最小窗口子串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于存储 t 中各字符的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] tArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 用于存储 s 中当前窗口各字符的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] sArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 tArr 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            tArr[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 左右指针初始化为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最小长度初始化为无穷大</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 最终结果字符串初始化为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动右指针，扩展窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            sArr[s.charAt(right)]++; <span class="comment">// 记录右指针指向字符的出现次数</span></span><br><span class="line">            <span class="comment">// 当窗口内的字符已经包含 t 中所有字符时，移动左指针缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (check(sArr, tArr)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> right - left + <span class="number">1</span>; <span class="comment">// 计算当前窗口长度</span></span><br><span class="line">                <span class="keyword">if</span> (length &lt; minLen) &#123; <span class="comment">// 如果当前窗口长度小于最小长度，更新最小长度和结果字符串</span></span><br><span class="line">                    minLen = length;</span><br><span class="line">                    result = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sArr[s.charAt(left)]--; <span class="comment">// 左指针右移前，减少左指针指向字符的出现次数</span></span><br><span class="line">                left++; <span class="comment">// 左指针右移，缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 右指针右移，扩大窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前窗口是否包含 t 中所有字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] sArr, <span class="type">int</span>[] tArr)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查大写字母 A-Z</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sArr[i] &lt; tArr[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查小写字母 a-z</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sArr[i] &lt; tArr[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 当前窗口包含 t 中所有字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-优化"><a href="#2-4-优化" class="headerlink" title="2.4 优化"></a>2.4 优化</h2><ul>
<li>上面两种方法，每次都需要调用<code>check()</code>函数，我们能不能优化一下呢？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主方法，寻找字符串 s 中包含字符串 t 的最小窗口子串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于存储 t 中各字符的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] tArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 用于存储 s 中当前窗口各字符的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] sArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 tArr 数组，记录 t 中每个字符的出现次数，并统计不同字符的种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tArr[t.charAt(i)]++ == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 左右指针初始化为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最小长度初始化为无穷大</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 最终结果字符串初始化为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动右指针，扩展窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            sArr[c]++;</span><br><span class="line">            <span class="comment">// 当窗口中的某字符数量达到 t 中该字符的数量时，计数器 cnt 减 1</span></span><br><span class="line">            <span class="keyword">if</span> (sArr[c] == tArr[c]) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当计数器 cnt 为 0 时，窗口包含了 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 更新最小长度和结果子字符串</span></span><br><span class="line">                <span class="keyword">if</span> (length &lt; minLen) &#123;</span><br><span class="line">                    minLen = length;</span><br><span class="line">                    result = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移动左指针，缩小窗口</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                sArr[x]--;</span><br><span class="line">                <span class="comment">// 当某字符数量小于 t 中该字符数量时，计数器 cnt 加 1</span></span><br><span class="line">                <span class="keyword">if</span> (sArr[x] &lt; tArr[x]) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>哈希集合</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>比较含退格的字符串 | LeetCode-844 | 双指针</title>
    <url>/2024/08/01/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p>
<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ab<span class="subst">#c</span>&quot;</span>, t = <span class="string">&quot;ad<span class="subst">#c</span>&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s 和 t 都会变成 <span class="string">&quot;ac&quot;</span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ab##&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;c#d#&quot;</span></span><br><span class="line">输出：<span class="built_in">true</span></span><br><span class="line">解释：s 和 <span class="built_in">t</span> 都会变成 <span class="string">&quot;&quot;</span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a#c&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：<span class="built_in">false</span></span><br><span class="line">解释：s 会变成 <span class="string">&quot;c&quot;</span>，但 <span class="built_in">t</span> 仍然是 <span class="string">&quot;b&quot;</span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 200</code></li>
<li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以用 <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主方法 backspaceCompare，比较两个字符串 s 和 t 在处理退格字符 &#x27;#&#x27; 后是否相等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 getTrueString 方法获取处理退格后的字符串，并比较两者是否相等</span></span><br><span class="line">        <span class="keyword">return</span> getTrueString(s).equals(getTrueString(t));</span><br><span class="line">        <span class="comment">//字符串不能直接比较</span></span><br><span class="line">        <span class="comment">//return getTrueString(s) == getTrueString(t);//报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法 getTrueString，用于处理包含退格字符 &#x27;#&#x27; 的字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTrueString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 StringBuilder sb 来构建处理退格后的有效字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入字符串 s 的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);  <span class="comment">// 获取当前字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前字符不是 &#x27;#&#x27;，将其添加到 StringBuilder 中</span></span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符是 &#x27;#&#x27; 并且 sb 不为空，则删除 sb 中的最后一个字符，模拟退格操作</span></span><br><span class="line">                <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回处理后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h2><ul>
<li>图解：<a href="https://leetcode.cn/problems/backspace-string-compare/solutions/1/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">https://leetcode.cn/problems/backspace-string-compare/solutions/1/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用双指针法</span></span><br><span class="line">        <span class="comment">// i 指针指向字符串 s 的最后一个字符</span></span><br><span class="line">        <span class="comment">// j 指针指向字符串 t 的最后一个字符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// skipS 和 skipT 分别用于记录字符串 s 和 t 中的退格 &#x27;#&#x27; 的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">skipS</span> <span class="operator">=</span> <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i 或 j 任一大于等于 0 时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理字符串 s 的退格</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符是 &#x27;#&#x27;, 增加 skipS 计数，表示要跳过一个有效字符</span></span><br><span class="line">                    skipS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不是 &#x27;#&#x27; 且 skipS 大于 0，表示前面有未处理的退格，需要跳过当前字符</span></span><br><span class="line">                    skipS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 skipS 为 0，且当前字符不是 &#x27;#&#x27;, 说明找到了一个有效字符，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理字符串 t 的退格</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(j) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符是 &#x27;#&#x27;, 增加 skipT 计数，表示要跳过一个有效字符</span></span><br><span class="line">                    skipT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前字符不是 &#x27;#&#x27; 且 skipT 大于 0，表示前面有未处理的退格，需要跳过当前字符</span></span><br><span class="line">                    skipT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 skipT 为 0，且当前字符不是 &#x27;#&#x27;, 说明找到了一个有效字符，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较 s 和 t 中的当前字符</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前 s 和 t 的字符不相同，返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) != t.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果其中一个字符串已经处理完，而另一个没有，返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续向前移动 i 和 j</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有字符都相同，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转字符串 | LeetCode-796 | 模拟 | KMP | 字符串匹配</title>
    <url>/2024/08/14/algorithm/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/LeetCode-796-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<center><b>KMP算法练习题</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/rotate-string/">796. 旋转字符串<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定两个字符串, <code>s</code> 和 <code>goal</code>。如果在若干次旋转操作之后，<code>s</code> 能变成 <code>goal</code> ，那么返回 <code>true</code> 。</p>
<p><code>s</code> 的 <strong>旋转操作</strong> 就是将 <code>s</code> 最左边的字符移动到最右边。 </p>
<ul>
<li>例如, 若 <code>s = &#39;abcde&#39;</code>，在旋转一次之后结果就是<code>&#39;bcdea&#39;</code> 。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;abcde&quot;</span>, <span class="attr">goal</span> = <span class="string">&quot;cdeab&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;abcde&quot;</span>, <span class="attr">goal</span> = <span class="string">&quot;abced&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, goal.length &lt;= 100</code></li>
<li><code>s</code> 和 <code>goal</code> 由小写英文字母组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查两个字符串的长度，如果长度不同，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() != goal.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();<span class="comment">// 将字符串 s 转换为字符数组</span></span><br><span class="line">        <span class="type">char</span>[] cht = goal.toCharArray();<span class="comment">// 将目标字符串 goal 转换为字符数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每一个可能的旋转位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保存当前字符，以便进行旋转</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chs[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 将字符数组向左旋转一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cht.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                chs[j] = chs[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将保存的字符放到数组末尾</span></span><br><span class="line">            chs[chs.length - <span class="number">1</span>] = temp;</span><br><span class="line">            <span class="comment">// 如果当前旋转后的字符数组等于目标字符数组，返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(chs, cht)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 如果没有找到任何匹配，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-2-模拟"><a href="#2-2-模拟" class="headerlink" title="2.2 模拟"></a>2.2 模拟</h2><ul>
<li>上面我们是通过将字符串转换成字符数组，然后实际进行旋转，当时实际上并不需要，我们可以通过取模的方式来模拟旋转字符串，<strong>这种方法称为模拟</strong></li>
<li>首先，如果$s$和$goal$的长度不一样，那么无论怎么旋转，$s$都不能得到$goal$，返回$false$。在长度一样（都为 <em>n</em>）的前提下，假设$s$旋转$i$位，则与$goal$中的某一位字符$ goal[j] $对应的原$s$中的字符应该为 $s[(i+j)\  mod\  n]$。在固定$i$的情况下，遍历所有$j$，若对应字符都相同，则返回$true$。否则，继续遍历其他候选的 $i$。若所有的$i$都不能使$s$变成$goal$，则返回 $false$</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查两个字符串的长度，如果不相等则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() != goal.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="comment">// 遍历字符串 s 的每一个字符作为旋转的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j; <span class="comment">// 初始化目标字符串 goal 的索引</span></span><br><span class="line">            <span class="comment">// 遍历目标字符串 goal</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="comment">// 通过模运算计算旋转后的字符在字符串 s 中的位置，并进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt((i + j) % len) != goal.charAt(j)) <span class="keyword">break</span>; <span class="comment">// 如果不匹配，跳出内层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 j 达到目标字符串的长度，表示完全匹配，返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (j == len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到匹配，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-字符串匹配-移动匹配"><a href="#2-3-字符串匹配-移动匹配" class="headerlink" title="2.3 字符串匹配 - 移动匹配"></a>2.3 字符串匹配 - 移动匹配</h2><ul>
<li>首先，如果 <em>s</em> 和 <em>goal</em> 的长度不一样，那么无论怎么旋转，<em>s</em> 都不能得到 <em>goal</em>，返回 false。字符串 <em>s</em>+<em>s</em> 包含了所有 <em>s</em> 可以通过旋转操作得到的字符串，只需要检查 <em>goal</em> 是否为 <em>s</em>+<em>s</em> 的子字符串即可。</li>
</ul>
<h3 id="2-3-1-内置函数"><a href="#2-3-1-内置函数" class="headerlink" title="2.3.1 内置函数"></a>2.3.1 内置函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length() == goal.length() &amp;&amp; (s+s).contains(goal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-KMP"><a href="#2-3-2-KMP" class="headerlink" title="2.3.2 KMP"></a>2.3.2 KMP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查字符串的长度，如果不相等则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() != goal.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串 s 进行拼接，以便于处理旋转情况</span></span><br><span class="line">        s = s + s;</span><br><span class="line">        <span class="comment">// 生成目标字符串 goal 的前缀函数数组</span></span><br><span class="line">        <span class="type">int</span>[] next = getNext(goal); </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 匹配指针，用于遍历目标字符串 goal</span></span><br><span class="line">        <span class="comment">// 遍历拼接后的字符串 s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，根据前缀函数回退 j</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != goal.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == goal.charAt(j)) j++;<span class="comment">// 如果字符匹配，增加 j</span></span><br><span class="line">            <span class="comment">// 如果 j 达到目标字符串的长度，表示完全匹配，返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (j == goal.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到匹配，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成目标字符串的前缀函数数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 存储前缀函数的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀指针</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个字符的前缀长度为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，生成前缀函数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前字符不匹配时，回退前缀指针 j</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) j++;<span class="comment">// 如果字符匹配，前缀长度增加</span></span><br><span class="line">            next[i] = j;<span class="comment">// 记录前缀长度到 next 数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next; <span class="comment">// 返回前缀函数数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表 | LeetCode-141 | LeetCode-142 | Floyd判圈算法 | 双指针 | 哈希集合</title>
    <url>/2024/08/10/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-141-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<center><b>Floyd判圈算法练习题</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表1<a/></b>
</center>

<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表2<a/></b>
</center>

<hr>
<h1 id="题目1：环形链表1"><a href="#题目1：环形链表1" class="headerlink" title="题目1：环形链表1"></a>题目1：环形链表1</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 $[0, 10^4]$内</li>
<li>$-10^5 &lt;= Node.val &lt;= 10^5$</li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-哈希集合"><a href="#2-1-哈希集合" class="headerlink" title="2.1 哈希集合"></a>2.1 哈希集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HashSet 用于存储访问过的节点</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化当前节点为链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点已经在 HashSet 中存在，说明存在环</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            set.add(cur);<span class="comment">// 否则，将当前节点加入 HashSet</span></span><br><span class="line">            cur = cur.next;<span class="comment">// 将当前节点移向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 如果遍历完链表，未发现环，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Floyd判圈算法-双指针"><a href="#2-2-Floyd判圈算法-双指针" class="headerlink" title="2.2 Floyd判圈算法-双指针"></a>2.2 Floyd判圈算法-双指针</h3><ul>
<li><strong>写法1： 这种写法对于下面一个题适用，推荐</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果链表为空，或者链表只有一个节点，直接返回 false，因为不可能有环</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 初始化两个指针：慢指针 slow 和 快指针 fast</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;           <span class="comment">// 慢指针从头节点开始，每次移动一步</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;      <span class="comment">// 快指针从第二个节点开始，每次移动两步</span></span><br><span class="line">    <span class="comment">// 循环，直到快指针到达链表末尾或找到环</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;<span class="comment">// 快指针每次移动两步 </span></span><br><span class="line">        slow = slow.next;<span class="comment">// 慢指针每次移动一步</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果快指针追上慢指针，说明链表有环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果循环结束还没有找到环，返回 false，表示链表没有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写法2：这种写法对于下面一个题目不适用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空或只有一个节点，直接返回false，因为不可能有环</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 初始化两个指针：慢指针slow指向头节点，快指针fast指向第二个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当快指针和慢指针不相遇时，继续遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 如果快指针到达链表末尾或者没有下一个节点，说明没有环，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;     </span><br><span class="line">            slow = slow.next;<span class="comment">// 慢指针每次前进一步            </span></span><br><span class="line">            fast = fast.next.next;<span class="comment">// 快指针每次前进两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果快指针和慢指针相遇，则说明链表中有环，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：环形链表2"><a href="#题目2：环形链表2" class="headerlink" title="题目2：环形链表2"></a>题目2：环形链表2</h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 $[0, 10^4]$内</li>
<li>$-10^5 &lt;= Node.val &lt;= 10^5$</li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-哈希集合-1"><a href="#2-1-哈希集合-1" class="headerlink" title="2.1 哈希集合"></a>2.1 哈希集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">// 创建一个 HashSet，用于存储遍历过程中访问过的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">// 初始化当前节点为链表的头节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点已经在 HashSet 中，说明该节点是环的起点，返回该节点</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur)) <span class="keyword">return</span> cur;</span><br><span class="line">            set.add(cur);<span class="comment">// 如果当前节点不在 HashSet 中，将其添加进去</span></span><br><span class="line">            cur = cur.next;<span class="comment">// 继续遍历下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果遍历完整个链表都没有发现环，返回 null，表示链表中没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Floyd判圈算法-双指针-1"><a href="#2-2-Floyd判圈算法-双指针-1" class="headerlink" title="2.2 Floyd判圈算法-双指针"></a>2.2 Floyd判圈算法-双指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空或者只有一个节点，直接返回 null，因为不可能有环</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化两个指针：慢指针 slow 和 快指针 fast</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 标记是否存在环的布尔变量</span></span><br><span class="line">        <span class="comment">// 快慢指针开始移动</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;  <span class="comment">// 快指针每次移动两步</span></span><br><span class="line">            slow = slow.next;       <span class="comment">// 慢指针每次移动一步</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果快指针追上慢指针，说明存在环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;    <span class="comment">// 标记存在环</span></span><br><span class="line">                <span class="keyword">break</span>;              <span class="comment">// 跳出循环</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasCycle) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 如果不存在环，直接返回 null</span></span><br><span class="line"></span><br><span class="line">        slow = head;<span class="comment">// 重新初始化慢指针，将其设置为头节点</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;<span class="comment">// 快慢指针再次移动，直到相遇，相遇点就是环的起点</span></span><br><span class="line">            slow = slow.next;   <span class="comment">// 慢指针每次移动一步</span></span><br><span class="line">            fast = fast.next;   <span class="comment">// 快指针每次移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回环的起点节点</span></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>哈希集合</tag>
        <tag>Floyd算法</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2024/08/02/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值<a/></b></p>
<h2 id="lt-center-gt"><a href="#lt-center-gt" class="headerlink" title="&lt;/center&gt;"></a>&lt;/center&gt;</h2><h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 19 | 删除链表的倒数第 N 个结点 | 双指针 | 递归 | 栈</title>
    <url>/2024/08/05/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<center><font color="green"><b>这道题还可以用递归法，你想到了吗？</b></font></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取链表的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断要删除的节点位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> length - n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点，指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要删除的结点的前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行删除操作</span></span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表长度函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针-暴力解法优化"><a href="#2-2-双指针-暴力解法优化" class="headerlink" title="2.2 双指针- 暴力解法优化"></a>2.2 双指针- 暴力解法优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点，指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化双指针，都指向虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy, second = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 让first指针先走n步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同时移动first和second指针，直到first指针到达链表末尾</span></span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时second指针的下一个节点就是要删除的节点</span></span><br><span class="line">        <span class="comment">// 执行删除操作</span></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-递归"><a href="#2-3-递归" class="headerlink" title="2.3 递归"></a>2.3 递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器，用于记录递归层数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归法 三步走</span></span><br><span class="line">    <span class="comment">// 1.确定形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 2.确定单层递归条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.确定单层递归逻辑</span></span><br><span class="line">        head.next = removeNthFromEnd(head.next, n); <span class="comment">// 递归到链表末尾</span></span><br><span class="line">        count++; <span class="comment">// 递归返回时增加计数</span></span><br><span class="line">        <span class="keyword">return</span> count == n ? head.next : head; <span class="comment">// 如果当前节点是倒数第n个节点，跳过它</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-4-借助栈"><a href="#2-4-借助栈" class="headerlink" title="2.4 借助栈"></a>2.4 借助栈</h2><ul>
<li>我们知道递归的本质就是栈，因此我们也可以使用栈来解决这道题目</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//虚设一个头节点  </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="comment">//创建栈用于存储链表结点</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//开始迭代，所有结点入栈</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈顶开始弹出元素，一直弹到要删除的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再弹出的元素就是要删除的结点的前一个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 203 | 移除链表元素 | 迭代法 | 虚设头节点 | 递归 | 三种方法</title>
    <url>/2024/08/02/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<center color="orange"><b>链表入门题！虚设头节点做链表：屡试不爽</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 $[0, 10^4]$ 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-直接法"><a href="#2-1-直接法" class="headerlink" title="2.1 直接法"></a>2.1 直接法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况，如果链表为空，直接返回 null</span></span><br><span class="line">        <span class="comment">// if (head == null) return null;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要删除的节点是头节点，更新头节点为下一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建指针 pre，用于遍历链表，初始化为当前头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果下一个节点不为空且下一个节点的值等于需要删除的值 val</span></span><br><span class="line">            <span class="keyword">if</span> (pre.next != <span class="literal">null</span> &amp;&amp; pre.next.val == val) &#123;</span><br><span class="line">                <span class="comment">// 跳过下一个节点，实现删除操作</span></span><br><span class="line">                pre.next = pre.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，移动指针到下一个节点</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回删除指定值后的链表头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-2-虚设头节点"><a href="#2-2-虚设头节点" class="headerlink" title="2.2 虚设头节点"></a>2.2 虚设头节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况，如果链表为空，直接返回 null</span></span><br><span class="line">        <span class="comment">// if (head == null) return null;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个新的头节点 newHead，指向原链表的头节点 head</span></span><br><span class="line">        <span class="comment">// 这样可以方便处理删除头节点的情况</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建指针 pre，初始化为 newHead，用于指示要删除的节点的前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> newHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始迭代，寻找要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果下一个节点不为空且下一个节点的值等于需要删除的值 val</span></span><br><span class="line">            <span class="keyword">if</span> (pre.next != <span class="literal">null</span> &amp;&amp; pre.next.val == val) &#123;</span><br><span class="line">                <span class="comment">// 跳过下一个节点，实现删除操作</span></span><br><span class="line">                pre.next = pre.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，移动指针到下一个节点</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回删除指定值后的链表头节点（即原链表的头节点）</span></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-3-递归"><a href="#2-3-递归" class="headerlink" title="2.3 递归"></a>2.3 递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="comment">//递归法 三步走</span></span><br><span class="line">    <span class="comment">//1.确定参数和返回值</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 确定终止条件：当链表遍历到 null 节点时，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定单层递归逻辑：</span></span><br><span class="line">        <span class="comment">// 递归处理当前节点的下一个节点，并更新当前节点的 next 指针</span></span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前节点：如果当前节点的值等于要删除的值，则返回它的 next 节点；否则返回当前节点</span></span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>迭代</tag>
        <tag>递归</tag>
        <tag>虚设头节点</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表 | LeetCode-206 | 递归 | 递归法 | 迭代法</title>
    <url>/2024/08/05/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-双指针-迭代法"><a href="#2-1-双指针-迭代法" class="headerlink" title="2.1 双指针(迭代法)"></a>2.1 双指针(迭代法)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// pre 用于存储当前节点的前一个节点，初始化为 null</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// cur 用于遍历链表，初始化为头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表，直到 cur 变为 null</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 暂存当前节点的下一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">// 将当前节点的 next 指针指向前一个节点，实现反转</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">// 更新 pre 为当前节点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">// cur 前进到下一个节点</span></span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回反转后的链表的新头节点，即原链表的最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-递归法"><a href="#2-2-递归法" class="headerlink" title="2.2 递归法"></a>2.2 递归法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 反转单链表的主函数</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用辅助函数进行递归反转，初始调用时前一个节点为 null，当前节点为头节点</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归函数，用于反转链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定终止条件：当当前节点为 null 时，返回前一个节点作为新头节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前节点的下一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">// 将当前节点的 next 指针指向前一个节点，实现反转</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用自身，将当前节点作为前一个节点，将下一个节点作为当前节点</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>迭代法</tag>
        <tag>递归法</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2024/08/02/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值<a/></b></p>
<h2 id="lt-center-gt"><a href="#lt-center-gt" class="headerlink" title="&lt;/center&gt;"></a>&lt;/center&gt;</h2><h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2024/08/02/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值<a/></b></p>
<h2 id="lt-center-gt"><a href="#lt-center-gt" class="headerlink" title="&lt;/center&gt;"></a>&lt;/center&gt;</h2><h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/13/algorithm/leetcode/%E9%93%BE%E8%A1%A8/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<blockquote>
<p>毛毛张分享的本篇博客是对《代码随想录》中的链表一章的LeetCode题目解法的总结，一共包含了八道题目，毛毛张全部使用Java代码进行编写，并在第3题中给出了毛毛张递归的解法，这个题目如果清楚递归的逻辑，用递归求解是比较方便的</p>
</blockquote>
<p>[toc]</p>
<h1 id="1-链表基础理论"><a href="#1-链表基础理论" class="headerlink" title="1.链表基础理论"></a>1.链表基础理论</h1><ul>
<li>在刷下面的LeetCode题目之前，让我们先来回顾一下链表的相关基础知识！</li>
</ul>
<h2 id="1-1-什么是链表？"><a href="#1-1-什么是链表？" class="headerlink" title="1.1 什么是链表？"></a>1.1 什么是链表？</h2><ul>
<li>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域(存放指向下一个节点的指针)，最后一个节点的指针域指向null（空指针的意思），链表的入口节点称为链表的头节点也就是head，如下图所示</li>
</ul>
<p><img src="./assets/image-20240701204314254.png" alt="image-20240701204314254"></p>
<h2 id="1-2-链表的类型"><a href="#1-2-链表的类型" class="headerlink" title="1.2 链表的类型"></a>1.2 链表的类型</h2><ul>
<li>单链表：上面说的就是单链表，单链表中的指针域只能指向节点的下一个节点</li>
<li>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点，因此双链表既可以向前查询也可以向后查询，如下图所示：</li>
</ul>
<p><img src="./assets/image-20240701204609310-1719837971596-1.png" alt="image-20240701204609310"></p>
<ul>
<li><strong>循环链表：</strong> 即链表首尾相连，循环链表可以用来解决约瑟夫问题，如下图所示：</li>
</ul>
<p><img src="./assets/image-20240701204739496.png" alt="image-20240701204739496"></p>
<h2 id="1-3-链表结点定义"><a href="#1-3-链表结点定义" class="headerlink" title="1.3 链表结点定义"></a>1.3 链表结点定义</h2><ul>
<li>在平时刷LeetCode的时候，链表的结点都默认定义好了，但是在面试的是时候可能不会给出，所以大家一定要熟悉链表结点的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-链表的操作"><a href="#1-4-链表的操作" class="headerlink" title="1.4 链表的操作"></a>1.4 链表的操作</h2><ul>
<li>对于不同类型的数据结构无外乎四种操作：增、删、改、查，对于链表来说，后面两种操作比较简单，复杂的是删除结点和增加结点</li>
</ul>
<h3 id="1-4-1-删除结点"><a href="#1-4-1-删除结点" class="headerlink" title="1.4.1 删除结点"></a>1.4.1 删除结点</h3><ul>
<li><p>下图展示了要删除一个结点的操作的图解，假设要删除的结点是D结点，如果要删除D结点就只需要找到要删除的结点的前一个结点C，然后将C结点的next指针指向E结点就可以了</p>
<p><img src="./assets/image-20240701210604334.png" alt="image-20240701210604334"></p>
</li>
<li><p><strong>删除操作最关键的是找到要删除的结点的前面一个结点，上图中cur指向的是要删除的结点、pre指向的是要删除的结点的前面一个结点</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line">pre.next = cur.next;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-4-2-增加结点"><a href="#1-4-2-增加结点" class="headerlink" title="1.4.2 增加结点"></a>1.4.2 增加结点</h3><ul>
<li>下图展示的是要增加的一个结点的操作的图解。</li>
</ul>
<p><img src="./assets/image-20240701213204269.png" alt="image-20240701213204269"></p>
<ul>
<li><p>假设要在索引为3的位置(D结点)插入结点F，上图中cur指向的是要插入位置的结点、pre指向的是要插入的位置的前一个结点</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建要插入的结点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">F</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">cur = pre.next;</span><br><span class="line">pre.next = F;</span><br><span class="line">F.next = cur;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><ul>
<li>链表的长度是不固定的，并且可以动态增删，适合数量不固定，频繁增删，较少查询的场景</li>
<li>上面知识对链表的相关知识点进行了一个简单的回顾，更多的可以参见毛毛张的这篇博客：<a href=""></a></li>
</ul>
<h1 id="2-203-移除链表元素"><a href="#2-203-移除链表元素" class="headerlink" title="2.203. 移除链表元素"></a>2.<a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><blockquote>
<p>LeetCode标签：<font color="green"><b>简单</b></font></p>
</blockquote>
<h2 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h2 id="2-2-题解"><a href="#2-2-题解" class="headerlink" title="2.2 题解"></a>2.2 题解</h2><h3 id="2-2-1-迭代"><a href="#2-2-1-迭代" class="headerlink" title="2.2.1 迭代"></a>2.2.1 迭代</h3><h4 id="写法1：直接使用原来的链表来进行移除结点操作"><a href="#写法1：直接使用原来的链表来进行移除结点操作" class="headerlink" title="写法1：直接使用原来的链表来进行移除结点操作"></a>写法1：直接使用原来的链表来进行移除结点操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="comment">//if(head == null) return null;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断如果删除的是第一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val ==val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义结点用来记录要删除的结点的前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.next != <span class="literal">null</span> &amp;&amp; val == pre.next.val)&#123;</span><br><span class="line">                pre.next = pre.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解：</strong> 以链表 <strong>1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</strong> 为例</p>
<ol>
<li>首先，<strong>pre 指向 head</strong><br> <img src="https://pic.leetcode-cn.com/1607529142-ZAUCIw-image.png" alt="image.png"></li>
<li><strong>当 pre 指向的节点的下一个节点的值不等于 val 时，右移 pre 进行遍历</strong><br> <img src="https://pic.leetcode-cn.com/1607529652-FryQBQ-image.png" alt="image.png"></li>
<li><strong>等于时，将 pre 指向其下一个节点的下一个节点，相当于删除了 pre 之前指向节点的下一个节点</strong><br> <img src="https://pic.leetcode-cn.com/1607529811-oBupyJ-image.png" alt="image.png"></li>
<li><strong>继续遍历，操作步骤跟前面两步一样</strong><br> <img src="https://pic.leetcode-cn.com/1615688115-MrdBil-image.png" alt="image.png"></li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1615688240-EgDMzc-image.png" alt="image.png"></p>
<p><img src="https://pic.leetcode-cn.com/1607530059-TroltH-image.png" alt="image.png"></p>
<p>处理后的结果：</p>
<p><img src="https://pic.leetcode-cn.com/1607530139-pAkasa-image.png" alt="image.png"></p>
<blockquote>
<p>看到上面的代码发现有两种情况，原因就是头节点也存储了元素，如果要删除的第一个结点的时候，无法知道该头节点的前一个结点，无法进行统一的删除结点操作，<strong>于是我们可以虚设一个头节点，这样就方便执行统一的删除操作</strong></p>
</blockquote>
<h4 id="写法2：设置一个虚拟头结点在进行移除节点操作"><a href="#写法2：设置一个虚拟头结点在进行移除节点操作" class="headerlink" title="写法2：设置一个虚拟头结点在进行移除节点操作"></a>写法2：设置一个虚拟头结点在进行移除节点操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建指针，用来指示要删除的结点前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="comment">//开始迭代，寻找要删除的结点</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.val == val)&#123;</span><br><span class="line">                pre.next = pre.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码说明：</strong></p>
<ul>
<li>设置一个虚拟头节点之后，要删除题设链表的第一个结点的操作和后面一个结点的操作就是相同的，整个代码逻辑比较清晰，毛毛张就不在这里过多阐述了</li>
</ul>
<h3 id="2-2-2-递归"><a href="#2-2-2-递归" class="headerlink" title="2.2.2 递归"></a>2.2.2 递归</h3><p><strong>分析：</strong></p>
<ul>
<li>链表具有天然的递归性，我们要删除整个链表中符合条件的结点，可以递归到更短的链表，删除短的链表中符合条件的结点</li>
</ul>
<p><img src="./assets/image-20240702101736591.png" alt="image-20240702101736591"></p>
<ul>
<li>上面的迭代法是从前往后进行删除，因此在删除前需要知道要删除的结点的前一个结点，而递归法的逻辑则是从后往前处理</li>
<li>递归法的代码比较简洁，大家可以先看代码，然后再看图解，大家一定要理解这个逻辑，我们可以通过这个思路来求解第三题</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归法 三步走</span></span><br><span class="line">    <span class="comment">//1.确定形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        <span class="comment">//递归到最后一个结点才进行删除操作，从后往前</span></span><br><span class="line">        head.next = removeElements(head.next,val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解：</strong></p>
<p><img src="./assets/2_3-1719844420944-5.gif" alt="2_3"></p>
<blockquote>
<p>看完递归求解上面这个题目，大家可以使用递归法来求解下面这道题目</p>
</blockquote>
<h1 id="3-19-删除链表的倒数第-N-个结点"><a href="#3-19-删除链表的倒数第-N-个结点" class="headerlink" title="3.19. 删除链表的倒数第 N 个结点"></a>3.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><blockquote>
<p>LeetCode标签：<font color="orange"><b>中等</b></font></p>
</blockquote>
<h2 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h2 id="3-2-题解"><a href="#3-2-题解" class="headerlink" title="3.2 题解"></a>3.2 题解</h2><h3 id="3-2-1-迭代"><a href="#3-2-1-迭代" class="headerlink" title="3.2.1 迭代"></a>3.2.1 迭代</h3><h4 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h4><ul>
<li>首先计算链表的长度$Length$</li>
<li>删除倒数第$N$个结点，就是删除正着数的第$Length-N+1$个结点</li>
<li>删除第$Length-N+1$个结点，需要找到要删除结点的前一个结点，就是第$Length-N$个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//获取链表的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断要删除的节点位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> length - n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是不是要删除第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不是迭代到要删除的节点的前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//要删除的结点的前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">//要删除的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行删除操作</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：借助栈"><a href="#方法2：借助栈" class="headerlink" title="方法2：借助栈"></a>方法2：借助栈</h4><p><strong>思路：</strong></p>
<ul>
<li>我们也可以在遍历链表的同时将所有节点依次入栈。</li>
<li>根据栈「先进后出」的原则，我们弹出栈的第 <em>n</em> 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//虚设一个头节点  </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="comment">//创建栈用于存储链表结点</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//开始迭代，所有结点入栈</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈顶开始弹出元素，一直弹到要删除的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再弹出的元素就是要删除的结点的前一个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解：</strong></p>
<p><img src="./assets/3.gif" alt="3"></p>
<h4 id="方法3：双指针法"><a href="#方法3：双指针法" class="headerlink" title="方法3：双指针法"></a>方法3：双指针法</h4><p><strong>思路：</strong></p>
<p>由于我们需要找到倒数第 <em>n</em> 个节点，因此我们可以使用两个指针 <em>first</em> 和 <em>second</em> 同时对链表进行遍历，并且 <em>first</em> 比 <em>second</em> 超前 <em>n</em> 个节点。当 <em>first</em> 遍历到链表的末尾时，<em>second</em> 就恰好处于倒数第 <em>n</em> 个节点。</p>
<p>具体地，初始时 <em>first</em> 和 <em>second</em> 均指向头节点。我们首先使用 <em>first</em> 对链表进行遍历，遍历的次数为 <em>n</em>。此时，<em>first</em> 和 <em>second</em> 之间间隔了 <em>n</em>−1 个节点，即 <em>first</em> 比 <em>second</em> 超前了 <em>n</em> 个节点。</p>
<p>在这之后，我们同时使用 <em>first</em> 和 <em>second</em> 对链表进行遍历。当 <em>first</em> 遍历到链表的末尾（即 <em>first</em> 为空指针）时，<em>second</em> 恰好指向倒数第 <em>n</em> 个节点。</p>
<p>根据方法一和方法二，如果我们能够得到的是倒数第 <em>n</em> 个节点的前驱节点而不是倒数第 <em>n</em> 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 <em>second</em> 指向哑节点，其余的操作步骤不变。这样一来，当 <em>first</em> 遍历到链表的末尾时，<em>second</em> 的<strong>下一个节点</strong>就是我们需要删除的节点。</p>
<p><strong>图解：</strong></p>
<p><img src="./assets/image-20240702113405821.png" alt="image-20240702113405821"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//虚设头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个指针，两个指针之间相差n结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="literal">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始移除</span></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-递归"><a href="#3-2-2-递归" class="headerlink" title="3.2.2 递归"></a>3.2.2 递归</h3><p><strong>思路：</strong></p>
<ul>
<li>上面介绍过一种方法，利用栈来存储元素，迭代到链表的尾部，再从栈顶弹出n个结点就是倒数第n个结点</li>
<li>然而递归的本质也是栈，所以我们也可以尝试使用递归的方式，递归到链表的尾部，再从后往前处理</li>
<li>代码如下，代码本身比较简洁，如果对代码的逻辑不理解的可以结合着下面的动态图来理解</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定单层递归逻辑</span></span><br><span class="line">        <span class="comment">//递归到最后一个元素</span></span><br><span class="line">        head.next = removeNthFromEnd(head.next,n);</span><br><span class="line">        <span class="comment">//开始回溯</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解：</strong></p>
<p><img src="./assets/3_2-1719906985418-3.gif" alt="3_2"></p>
<h1 id="4-707-设计链表"><a href="#4-707-设计链表" class="headerlink" title="4.707. 设计链表"></a>4.<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h1><h2 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h2><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;MyLinkedList&quot;</span>, <span class="string">&quot;addAtHead&quot;</span>, <span class="string">&quot;addAtTail&quot;</span>, <span class="string">&quot;addAtIndex&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;deleteAtIndex&quot;</span>, <span class="string">&quot;get&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br><span class="line">输出</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="keyword">null</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = <span class="keyword">new</span> MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(<span class="number">1</span>);</span><br><span class="line">myLinkedList.addAtTail(<span class="number">3</span>);</span><br><span class="line">myLinkedList.addAtIndex(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// 链表变为 1-&gt;2-&gt;3</span></span><br><span class="line">myLinkedList.<span class="keyword">get</span>(<span class="number">1</span>);              <span class="comment">// 返回 2</span></span><br><span class="line">myLinkedList.deleteAtIndex(<span class="number">1</span>);    <span class="comment">// 现在，链表变为 1-&gt;3</span></span><br><span class="line">myLinkedList.<span class="keyword">get</span>(<span class="number">1</span>);              <span class="comment">// 返回 3</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= index, val &lt;= 1000</code></li>
<li>请不要使用内置的 LinkedList 库。</li>
<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>
</ul>
<h2 id="4-2-题解"><a href="#4-2-题解" class="headerlink" title="4.2 题解"></a>4.2 题解</h2><ul>
<li>这个题目是对单链表和双链表的基本操作的考察</li>
</ul>
<h3 id="4-2-1-单链表"><a href="#4-2-1-单链表" class="headerlink" title="4.2.1 单链表"></a>4.2.1 单链表</h3><h4 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//定义变量存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//定义虚拟头节点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化链表实现类</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化要插入的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="comment">//开始执行插入操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        node.next = temp;</span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化要插入的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.size;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接把新节点插入作为最后一个节点的next</span></span><br><span class="line">        cur.next = node;</span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; <span class="built_in">this</span>.size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="built_in">this</span>.size)&#123;</span><br><span class="line">            <span class="comment">//要插入的位置正好是在链表的尾部</span></span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义要插入的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="comment">//开始执行插入操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        node.next = temp;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//判断删除的下标是否有效</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">//如果是删除第一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="comment">//迭代到当前要删除的下标的前面一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="写法1优化"><a href="#写法1优化" class="headerlink" title="写法1优化"></a>写法1优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//定义变量存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//定义虚拟头节点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化链表实现类</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化虚拟头节点</span></span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况:不正确的index</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="built_in">this</span>.size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index大于链表的长度，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在第index个节点之前插入一个新节点，如果index=0，哪个插入的新节点的为链表的新头节点</span></span><br><span class="line">        <span class="comment">//如果index等于链表的长度，则说明新插入的节点要插入链表的尾部</span></span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">        <span class="comment">//找到要插入的节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要插入的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="comment">//插入操作</span></span><br><span class="line">        node.next = pre.next;</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//判断删除的下标是否有效</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        size--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是删除第一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="comment">//迭代到当前要删除的下标的前面一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-双链表"><a href="#4-2-2-双链表" class="headerlink" title="4.2.2 双链表"></a>4.2.2 双链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode pre;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//定义变量存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//定义虚拟头节点</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="comment">//定义虚拟尾节点</span></span><br><span class="line">    ListNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化链表实现类</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化虚拟头节点</span></span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊情况:不正确的index</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义迭代的当前节点</span></span><br><span class="line">        ListNode cur;</span><br><span class="line">        <span class="comment">//判断从前迭代还是从后迭代</span></span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt;= size - index) &#123;</span><br><span class="line">            cur = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = <span class="built_in">this</span>.tail;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">                cur = cur.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="built_in">this</span>.size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index大于链表的长度，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">        index = Math.max(<span class="number">0</span>,index);</span><br><span class="line">        <span class="comment">//在第index个节点之前插入一个新节点，如果index=0，哪个插入的新节点的为链表的新头节点</span></span><br><span class="line">        <span class="comment">//如果index等于链表的长度，则说明新插入的节点要插入链表的尾部</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义要插入的节点的前驱和后继</span></span><br><span class="line">        ListNode pre,post;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; size - index)&#123;</span><br><span class="line">            pre = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            post = pre.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            post = <span class="built_in">this</span>.tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++)&#123;</span><br><span class="line">                post = post.pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = post.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要插入的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="comment">//插入操作</span></span><br><span class="line">        node.pre = pre;</span><br><span class="line">        node.next = post;</span><br><span class="line">        pre.next = node;</span><br><span class="line">        post.pre = node;</span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//判断删除的下标是否有效</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义要插入的节点的前驱和后继</span></span><br><span class="line">        ListNode pre,post;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; size - index)&#123;</span><br><span class="line">            pre = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            post = pre.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            post = <span class="built_in">this</span>.tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - index -<span class="number">1</span>; i++)&#123;</span><br><span class="line">                post = post.pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = post.pre.pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行删除操作</span></span><br><span class="line">        pre.next = post;</span><br><span class="line">        post.pre = pre;</span><br><span class="line">        <span class="comment">//更新链表存储的元素</span></span><br><span class="line">        <span class="built_in">this</span>.size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="5-206-反转链表"><a href="#5-206-反转链表" class="headerlink" title="5.206. 反转链表"></a>5.<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><blockquote>
<p>LeetCode标签：<font color="green"><b>简单</b></font></p>
</blockquote>
<h2 id="5-1-题目描述"><a href="#5-1-题目描述" class="headerlink" title="5.1 题目描述"></a>5.1 题目描述</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h2 id="5-2-题解"><a href="#5-2-题解" class="headerlink" title="5.2 题解"></a>5.2 题解</h2><ul>
<li>这个题目毛毛张还是从迭代和递归的角度分享解法</li>
</ul>
<h3 id="5-2-1-迭代"><a href="#5-2-1-迭代" class="headerlink" title="5.2.1 迭代"></a>5.2.1 迭代</h3><ul>
<li>迭代法的思路就是在迭代原始链表的元素的过程中，用头插法创建一个新的链表就可以实现反转的目的</li>
</ul>
<h4 id="写法1-1"><a href="#写法1-1" class="headerlink" title="写法1"></a>写法1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//创建反转链表的头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//获取当前插入结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//获取当前结点的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.val;</span><br><span class="line">            <span class="comment">//新建插入结点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            <span class="keyword">if</span>(newHead == <span class="literal">null</span>)&#123;</span><br><span class="line">                newHead = node;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//头插法创建新链表</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> newHead;</span><br><span class="line">                node.next = temp;</span><br><span class="line">                newHead = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//迭代</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//创建反转链表的头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//获取当前插入结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录当前结点的后面的结点，以防后面节点被污染</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//头插法建立链表</span></span><br><span class="line">            cur.next = newHead;</span><br><span class="line">            newHead = cur;</span><br><span class="line">            <span class="comment">//迭代 即 cur = cur.temp;</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解：</strong></p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="img"></p>
<h3 id="5-2-2-递归"><a href="#5-2-2-递归" class="headerlink" title="5.2.2 递归"></a>5.2.2 递归</h3><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单层递归逻辑</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        ListNode newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>,head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从前向后翻转相邻两个节点的指针指向</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre,ListNode cur)</span>&#123;</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单层递归逻辑</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-24-两两交换链表中的节点"><a href="#6-24-两两交换链表中的节点" class="headerlink" title="6.24. 两两交换链表中的节点"></a>6.<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><blockquote>
<p>LeetCode标签：<font color="orange"><b>中等</b></font></p>
</blockquote>
<h2 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1 题目描述"></a>6.1 题目描述</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：[<span class="number">2,1,4,3</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="6-2-题解"><a href="#6-2-题解" class="headerlink" title="6.2 题解"></a>6.2 题解</h2><h3 id="6-2-1-迭代"><a href="#6-2-1-迭代" class="headerlink" title="6.2.1 迭代"></a>6.2.1 迭代</h3><p><strong>图解：</strong></p>
<p><img src="./assets/6_1.gif" alt="6_1"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//创建新的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="comment">//创建指针用于记录要交换的两个结点的前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="comment">//记录临时结点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp2</span> <span class="operator">=</span> pre.next.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始交换</span></span><br><span class="line">            <span class="comment">//步骤1</span></span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            <span class="comment">//步骤2</span></span><br><span class="line">            pre.next.next = temp1;</span><br><span class="line">            <span class="comment">//步骤3</span></span><br><span class="line">            temp1.next = temp2;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新迭代指针</span></span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-递归"><a href="#6-2-2-递归" class="headerlink" title="6.2.2 递归"></a>6.2.2 递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归法 三步走</span></span><br><span class="line">    <span class="comment">//确定形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定单层递归逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//步骤1 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//步骤2  进行递归</span></span><br><span class="line">        head.next = swapPairs(newHead.next);</span><br><span class="line">        <span class="comment">//步骤3 </span></span><br><span class="line">        newHead.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-160-相交链表"><a href="#7-160-相交链表" class="headerlink" title="7.160. 相交链表"></a>7.<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><blockquote>
<p>LeetCode标签：<font color="green"><b>简答</b></font></p>
</blockquote>
<h2 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4,1,8,4</span>,<span class="number">5</span>], listB = [<span class="number">5,6,1,8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">8</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 <span class="keyword">A</span> 为 [<span class="number">4,1,8,4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5,6,1,8</span>,<span class="number">4</span>,<span class="number">5</span>]。</span><br><span class="line">在 <span class="keyword">A</span> 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br><span class="line">— 请注意相交节点的值不为 <span class="number">1</span>，因为在链表 <span class="keyword">A</span> 和链表 B 之中值为 <span class="number">1</span> 的节点 (<span class="keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="keyword">A</span> 和链表 B 中值为 <span class="number">8</span> 的节点 (<span class="keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">2</span>, listA = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：<span class="symbol">Intersected</span> at <span class="string">&#x27;2&#x27;</span></span><br><span class="line">解释：相交节点的值为 <span class="number">2</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 <span class="symbol">A</span> 为 [<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 <span class="symbol">B</span> 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。</span><br><span class="line">在 <span class="symbol">A</span> 中，相交节点前有 <span class="number">3</span> 个节点；在 <span class="symbol">B</span> 中，相交节点前有 <span class="number">1</span> 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">null</span></span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。</span><br><span class="line">由于这两个链表不相交，所以 <span class="built_in">int</span>ersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h2 id="7-2-题解"><a href="#7-2-题解" class="headerlink" title="7.2 题解"></a>7.2 题解</h2><ul>
<li>此题的方法都是迭代法</li>
</ul>
<h3 id="7-2-1-方法1-哈希表"><a href="#7-2-1-方法1-哈希表" class="headerlink" title="7.2.1 方法1 - 哈希表"></a>7.2.1 方法1 - 哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">//借助集合</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//迭代链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur)) <span class="keyword">return</span> cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-2-方法2-双指针"><a href="#7-2-2-方法2-双指针" class="headerlink" title="7.2.2 方法2 - 双指针"></a>7.2.2 方法2 - 双指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">//创建变量用于记录两个链表的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始计算链表长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = headB;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将长的链表迭代到和短的链表的长度一样结点位置</span></span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lenA-lenB;i++)&#123;</span><br><span class="line">                headA = headA.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lenB-lenA;i++)&#123;</span><br><span class="line">                headB = headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建变量用于记录答案</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//开始判断后面的序列是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA == headB)&#123;</span><br><span class="line">                node = headA;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-方法3"><a href="#7-2-3-方法3" class="headerlink" title="7.2.3 方法3"></a>7.2.3 方法3</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">		<span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">			<span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">            p1 = p1 == <span class="literal">null</span> ? headB : p1.next;</span><br><span class="line">            <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">            p2 = p2 == <span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>算法逻辑：如果两个链表相交，那么相交点之后的长度是相同的，我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。为此，我们必须消除两个链表的长度差</strong></p>
<ol>
<li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li>
<li>如果 pA 到了末尾，则 pA = headB 继续遍历</li>
<li>如果 pB 到了末尾，则 pB = headA 继续遍历</li>
<li>比较长的链表指针指向较短链表head时，长度差就消除了</li>
<li>如此，只需要将最短链表遍历两次即可找到位置</li>
</ol>
</li>
<li><p>看完上面的文字和代码，看到这个代码的时候可能你也和毛毛张一样惊讶这么简单！但是你看完之后可能还是不是很理解，下面就来结合图示来看一下吧！</p>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" alt="相交链表.png"></p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong> $O(m+n)$，其中$m$和$n$分别是链表$headA$和$headB$的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次</li>
<li><strong>空间复杂度：</strong> $O(1)$</li>
</ul>
<h1 id="8-141-环形链表"><a href="#8-141-环形链表" class="headerlink" title="8.141. 环形链表"></a>8.<a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h1><blockquote>
<p>LeetCode标签：<font color="green"><b>简单</b></font></p>
</blockquote>
<h2 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<h2 id="8-2-题解"><a href="#8-2-题解" class="headerlink" title="8.2 题解"></a>8.2 题解</h2><h3 id="方法1-哈希表"><a href="#方法1-哈希表" class="headerlink" title="方法1 - 哈希表"></a>方法1 - 哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历的过程中记录遍历过的结点</span></span><br><span class="line">        <span class="comment">//如果出现相等的结点，就可以判定链表中存在环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2-迭代-快慢指针"><a href="#方法2-迭代-快慢指针" class="headerlink" title="方法2 - 迭代 - 快慢指针"></a>方法2 - 迭代 - 快慢指针</h3><ul>
<li>这种解法的逻辑是小时候的追及与相遇问题的逻辑，假设兔子的速度永远大于乌龟的速度，且兔子不会停，那么在一段笔直的路上，兔子和乌龟永远不会相遇</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//快指针走两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">//慢指针走一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//如果两个指针相遇则说明有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应三种情况：</span></span><br><span class="line">        <span class="comment">//1.链表为空</span></span><br><span class="line">        <span class="comment">//2.链表只有一个结点</span></span><br><span class="line">        <span class="comment">//3.链表没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-142-环形链表-II"><a href="#9-142-环形链表-II" class="headerlink" title="9.142. 环形链表 II"></a>9.<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><blockquote>
<p>LeetCode标签：<font color="orange"><b>中等</b></font></p>
</blockquote>
<h2 id="9-2-题目描述"><a href="#9-2-题目描述" class="headerlink" title="9.2 题目描述"></a>9.2 题目描述</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="9-2-题解"><a href="#9-2-题解" class="headerlink" title="9.2 题解"></a>9.2 题解</h2><h3 id="方法1-哈希表-1"><a href="#方法1-哈希表-1" class="headerlink" title="方法1 - 哈希表"></a>方法1 - 哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历的过程中记录遍历过的结点</span></span><br><span class="line">        <span class="comment">//如果出现相等的结点，就可以判定链表中存在环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2-迭代-快慢指针-1"><a href="#方法2-迭代-快慢指针-1" class="headerlink" title="方法2 - 迭代 - 快慢指针"></a>方法2 - 迭代 - 快慢指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始迭代</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//快指针走两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">//慢指针走一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//如果两个指针相遇则说明有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">//两指针，从头节点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应三种情况：</span></span><br><span class="line">        <span class="comment">//1.链表为空</span></span><br><span class="line">        <span class="comment">//2.链表只有一个结点</span></span><br><span class="line">        <span class="comment">//3.链表没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h1><ul>
<li>链表应该是我们接触数据结构的第一种比较复杂的数据结构，上面毛毛张分享了关于链表的8道题目，并且都尽量从迭代法和递归法的角度分享的解法</li>
<li><strong>关键点：</strong><ul>
<li>如果在关于链表的删除和增加操作中，<strong>如果使用迭代法</strong>，经常使用到双指针，找到要删除的结点的前面一个结点比较关键</li>
<li><strong>如果使用递归法</strong>，通常是递归到链表的底部，从链表的底部执行操作，大家可以仔细体会一下第3道、第4道题目</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>LeetCode官网</li>
<li>代码随想录官网</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>LeetCode | 162 | 寻找峰值 | 二分查找</title>
    <url>/2024/08/01/algorithm/leetcode/%E6%95%B0%E7%BB%84/162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧！</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,2,3,1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,2,1,3,5,6,4]</span></span><br><span class="line">输出：<span class="number">1</span> 或 <span class="number">5</span> </span><br><span class="line">解释：你的函数可以返回索引 <span class="number">1</span>，其峰值元素为 <span class="number">2</span>；</span><br><span class="line">     或者返回索引 <span class="number">5</span>， 其峰值元素为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li>$-2^{31} &lt;= nums[i] &lt;= 2^{31} - 1$</li>
<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 441 | 排列硬币</title>
    <url>/2024/07/28/algorithm/leetcode/%E6%95%B0%E7%BB%84/441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<blockquote>
<p><b>这是LeetCode中一道标签为<font color="green">简单</font>的算法题，点击“阅读全文”即可查看题解！</b></p>
</blockquote>
<span id="more"></span>
<center>
    <b><font color=darkorange face="楷体" size=4 >🙋大家好！我是毛毛张! </font></b>
    <hr>
    <b>
    LeetCode链接：<a href="https://leetcode.cn/problems/arranging-coins/">441. 排列硬币</a>
    </b>
</center>

<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>你总共有 <code>n</code> 枚硬币，并计划将它们按阶梯状排列。对于一个由 <code>k</code> 行组成的阶梯，其第 <code>i</code> 行必须正好有 <code>i</code> 枚硬币。阶梯的最后一行 <strong>可能</strong> 是不完整的。</p>
<p>给你一个数字 <code>n</code> ，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg" alt="img"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：因为第三行不完整，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg" alt="img"></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：因为第四行不完整，所以返回 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n &lt;= 2^{31} - 1$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">long</span> <span class="variable">coins</span> <span class="operator">=</span> (<span class="type">long</span>) i * (<span class="number">1</span> + i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (coins &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-二分查找"><a href="#2-2-二分查找" class="headerlink" title="2.2 二分查找"></a>2.2 二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">long</span>) mid * (<span class="number">1</span> + mid) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和-LeetCode梦开始的地方 | LeetCode-1 | 四种方法</title>
    <url>/2024/08/01/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<center>
    <font color="orange"><b>LeetCode梦开始的地方-两数之和</b></font>
</center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br><span class="line">解释：因为 nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> == 9 ，返回 <span class="comment">[0, 1]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,3]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于$O(n^2)$的算法吗？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-直接法-暴力解法"><a href="#2-1-直接法-暴力解法" class="headerlink" title="2.1 直接法-暴力解法"></a>2.1 直接法-暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 暴力解法：遍历数组中的每一对元素，寻找和为目标值的两个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层循环遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 内层循环从当前外层元素的下一个元素开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 检查当前两个元素之和是否等于目标值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="comment">// 如果找到满足条件的两个元素，返回它们的索引</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到满足条件的两个元素，返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-哈希集合"><a href="#2-2-哈希集合" class="headerlink" title="2.2 哈希集合"></a>2.2 哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希映射来存储数组中已经遍历过的数字及其对应的索引</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算目标值与当前元素之间的差值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查差值是否已经存在于哈希映射中</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">                <span class="comment">// 如果存在，说明找到了两个数的和为目标值</span></span><br><span class="line">                <span class="comment">// 获取差值在数组中的索引</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(diff);</span><br><span class="line">                <span class="comment">// 返回这两个数的索引</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; index, i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果差值不存在于哈希映射中，则将当前元素及其索引加入哈希映射</span></span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有找到满足条件的两个数，则返回 &#123;-1, -1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-双指针-二分查找"><a href="#2-3-双指针-二分查找" class="headerlink" title="2.3 双指针 | 二分查找"></a>2.3 双指针 | 二分查找</h2><ul>
<li>如果要使用双指针和二分查找需要基于该数组是有序数组</li>
<li>具体的解法可以参见这道题目的相关另一道题目：<ul>
<li><strong>LeetCode链接：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></strong></li>
<li>毛毛张解题记录：</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>哈希集合</tag>
        <tag>哈希数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 167 | 两数之和2-输入有序数组 | 二分法 | 双指针</title>
    <url>/2024/08/02/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>
<p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p>
<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>
<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：numbers = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 <span class="comment">[1, 2]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：numbers = <span class="comment">[2,3,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,3]</span></span><br><span class="line">解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 <span class="comment">[1, 3]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：numbers = [<span class="string">-1</span>,0], target = <span class="string">-1</span></span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：<span class="string">-1</span> 与 0 之和等于目标数 <span class="string">-1</span> 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$2 &lt;= numbers.length &lt;= 3 * 10^4$</li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li><strong>仅存在一个有效答案</strong></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li>这道题目是<a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>的变体，其解题方法均可以用在该方法上，但是并没有利用这道题目的特性：数组为 <strong>非递减顺序排列</strong> </li>
<li>二分查找的时间复杂度$O(nlog(n))$</li>
<li>双指针的时间复杂度$O(n)$</li>
</ul>
<h2 id="2-1-二分查找"><a href="#2-1-二分查找" class="headerlink" title="2.1 二分查找"></a>2.1 二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算新的目标值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newTarget</span> <span class="operator">=</span> target - numbers[i];</span><br><span class="line">            <span class="comment">// 二分查找初始化</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用二分查找寻找新的目标值</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == newTarget) &#123;</span><br><span class="line">                    <span class="comment">// 找到目标值，返回结果</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, mid + <span class="number">1</span> &#125;; <span class="comment">// 索引从1开始</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; newTarget) &#123;</span><br><span class="line">                    <span class="comment">// 中间值小于新目标值，向右移动左边界</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 中间值大于新目标值，向左移动右边界</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到结果，返回 [-1, -1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 初始化左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双指针法寻找两个数的和等于目标值</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 计算当前左右指针所指向元素的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[left] + numbers[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果和大于目标值，右指针左移</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">// 如果和小于目标值，左指针右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">// 如果和等于目标值，返回结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; left + <span class="number">1</span>, right + <span class="number">1</span> &#125;; <span class="comment">// 注意返回的索引从1开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到满足条件的两个数，返回 [-1, -1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>二分法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和与四数之和 | LeetCode-15 | LeetCode-18 | 双指针 | 降维 | 哈希集合</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E4%B8%8E%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<center><b>去重是这道题的关键！</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/3sum/">15. 三数之和<a/></b>
</center>

<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/4sum/">18. 四数之和<a/></b>
</center>

<hr>
<h1 id="题目1：三数之和"><a href="#题目1：三数之和" class="headerlink" title="题目1：三数之和"></a>题目1：三数之和</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[-1,0,1,2,-1,-4]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[-1,-1,2]</span>,<span class="comment">[-1,0,1]</span>]</span></span><br><span class="line">解释：</span><br><span class="line">nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> + nums<span class="comment">[2]</span> = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums<span class="comment">[1]</span> + nums<span class="comment">[2]</span> + nums<span class="comment">[4]</span> = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums<span class="comment">[0]</span> + nums<span class="comment">[3]</span> + nums<span class="comment">[4]</span> = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 <span class="comment">[-1,0,1]</span> 和 <span class="comment">[-1,-1,2]</span> 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[0,1,1]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[0,0,0]]</span></span><br><span class="line">解释：唯一可能的三元组和为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li>$-10^5 &lt;= nums[i] &lt;= 10^5$</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-双指针"><a href="#2-1-双指针" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组进行排序，方便后续使用双指针方法寻找满足条件的三元组</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 用于存放所有满足条件的三元组结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一层循环，选择第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n - <span class="number">2</span>; first++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于0，则不可能有三元组和为0，因为数组已排序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[first] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 跳过重复的数字以避免添加重复的三元组</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 定义双指针，second 从 first+1 开始，third 从数组末尾开始</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>, third = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 双指针查找当前first对应的所有满足条件的三元组</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third) &#123;</span><br><span class="line">                <span class="comment">// 计算三数之和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[first] + nums[second] + nums[third];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果和为0，找到一个满足条件的三元组</span></span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(nums[first]);</span><br><span class="line">                    list.add(nums[second]);</span><br><span class="line">                    list.add(nums[third]);</span><br><span class="line">                    resultList.add(list);</span><br><span class="line">                    <span class="comment">//resultList.add(Arrays.asList(nums[first], nums[second], nums[third]));</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 去重：移动second和third指针以跳过重复的数字</span></span><br><span class="line">                    <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] == nums[second + <span class="number">1</span>]) second++;</span><br><span class="line">                    <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[third] == nums[third - <span class="number">1</span>]) third--;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 移动指针，继续寻找其他可能的三元组</span></span><br><span class="line">                    second++;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于0，说明third指向的值太大，移动third指针减小总和</span></span><br><span class="line">                    third--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于0，说明second指向的值太小，移动second指针增加总和</span></span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回所有找到的三元组列表</span></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：四数之和"><a href="#题目2：四数之和" class="headerlink" title="题目2：四数之和"></a>题目2：四数之和</h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,<span class="string">-1</span>,0,<span class="string">-2</span>,2], target = 0</span><br><span class="line">输出：[[<span class="string">-2</span>,<span class="string">-1</span>,1,2],[<span class="string">-2</span>,0,0,2],[<span class="string">-1</span>,0,0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], target = <span class="number">8</span></span><br><span class="line">输出：<span class="string">[[2,2,2,2]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li>
<li>$-10^9 &lt;= target &lt;= 10^9$</li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-双指针-1"><a href="#2-1-双指针-1" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组进行排序，方便后续使用双指针方法寻找满足条件的四元组</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 用于存放所有满足条件的四元组结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一层循环，选择第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n - <span class="number">3</span>; first++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的数字以避免添加重复的四元组</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 第二层循环，选择第二个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n - <span class="number">2</span>; second++) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复的数字以避免添加重复的四元组</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 定义双指针，third 从 second+1 开始，fourth 从数组末尾开始</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> second + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">fourth</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 双指针查找当前first和second对应的所有满足条件的四元组</span></span><br><span class="line">                <span class="keyword">while</span> (third &lt; fourth) &#123;</span><br><span class="line">                    <span class="comment">// 计算四数之和，使用long以防止整数溢出</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[first] + nums[second] + nums[third] + nums[fourth];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果和等于目标值，找到一个满足条件的四元组</span></span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        list.add(nums[first]);</span><br><span class="line">                        list.add(nums[second]);</span><br><span class="line">                        list.add(nums[third]);</span><br><span class="line">                        list.add(nums[fourth]);</span><br><span class="line">                        resultList.add(list);</span><br><span class="line">                        </span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重：移动third和fourth指针以跳过重复的数字</span></span><br><span class="line">                        <span class="keyword">while</span> (third &lt; fourth &amp;&amp; nums[third] == nums[third + <span class="number">1</span>]) third++;</span><br><span class="line">                        <span class="keyword">while</span> (third &lt; fourth &amp;&amp; nums[fourth] == nums[fourth - <span class="number">1</span>]) fourth--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 移动指针，继续寻找其他可能的四元组</span></span><br><span class="line">                        third++;</span><br><span class="line">                        fourth--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        <span class="comment">// 如果和大于目标值，说明fourth指向的值太大，移动fourth指针减小总和</span></span><br><span class="line">                        fourth--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果和小于目标值，说明third指向的值太小，移动third指针增加总和</span></span><br><span class="line">                        third++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有找到的四元组列表</span></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组进行排序，方便后续使用双指针方法寻找满足条件的四元组</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 用于存放所有满足条件的四元组结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一层循环，选择第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n - <span class="number">3</span>; first++) &#123;</span><br><span class="line">            <span class="comment">// 1级剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span>(nums[first] &gt; target &amp;&amp; nums[first] &gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 跳过重复的数字以避免添加重复的四元组</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 第二层循环，选择第二个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n - <span class="number">2</span>; second++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[first] + nums[second] &gt; target &amp;&amp; nums[first] + nums[second] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 跳过重复的数字以避免添加重复的四元组</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 定义双指针，third 从 second+1 开始，fourth 从数组末尾开始</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> second + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">fourth</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 双指针查找当前first和second对应的所有满足条件的四元组</span></span><br><span class="line">                <span class="keyword">while</span> (third &lt; fourth) &#123;</span><br><span class="line">                    <span class="comment">// 计算四数之和，使用long以防止整数溢出</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[first] + nums[second] + nums[third] + nums[fourth];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果和等于目标值，找到一个满足条件的四元组</span></span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        resultList.add(Arrays.asList(nums[first], nums[second], nums[third], nums[fourth]));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重：移动third和fourth指针以跳过重复的数字</span></span><br><span class="line">                        <span class="keyword">while</span> (third &lt; fourth &amp;&amp; nums[third] == nums[third + <span class="number">1</span>]) third++;</span><br><span class="line">                        <span class="keyword">while</span> (third &lt; fourth &amp;&amp; nums[fourth] == nums[fourth - <span class="number">1</span>]) fourth--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 移动指针，继续寻找其他可能的四元组</span></span><br><span class="line">                        third++;</span><br><span class="line">                        fourth--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        <span class="comment">// 如果和大于目标值，说明fourth指向的值太大，移动fourth指针减小总和</span></span><br><span class="line">                        fourth--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果和小于目标值，说明third指向的值太小，移动third指针增加总和</span></span><br><span class="line">                        third++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有找到的四元组列表</span></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法，LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>哈希集合</tag>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title>区间内查询数字的频率 | LeetCode-2080 | 二分查找</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-2080-%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E7%9A%84%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<center><b>二分查找你学废了吗？快来看看这道题如何使用二分查找解决吧!</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/range-frequency-queries/">2080. 区间内查询数字的频率<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong> 。</p>
<p>子数组中一个值的 <strong>频率</strong> 指的是这个子数组中这个值的出现次数。</p>
<p>请你实现 <code>RangeFreqQuery</code> 类：</p>
<ul>
<li><code>RangeFreqQuery(int[] arr)</code> 用下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 构造一个类的实例。</li>
<li><code>int query(int left, int right, int value)</code> 返回子数组 <code>arr[left...right]</code> 中 <code>value</code> 的 <strong>频率</strong> 。</li>
</ul>
<p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code> 指的是 <code>nums</code> 中包含下标 <code>left</code> 和 <code>right</code> <strong>在内</strong> 的中间一段连续元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;RangeFreqQuery&quot;</span>, <span class="string">&quot;query&quot;</span>, <span class="string">&quot;query&quot;</span>]</span><br><span class="line">[[[<span class="number">12</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="symbol">RangeFreqQuery</span> rangeFreqQuery = new <span class="symbol">RangeFreqQuery</span>([<span class="number">12</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]);</span><br><span class="line">rangeFreqQuery.query(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>); // 返回 <span class="number">1</span> 。<span class="number">4</span> 在子数组 [<span class="number">33</span>, <span class="number">4</span>] 中出现 <span class="number">1</span> 次。</span><br><span class="line">rangeFreqQuery.query(<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>); // 返回 <span class="number">2</span> 。<span class="number">33</span> 在整个子数组中出现 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= arr.length &lt;= 10^5$</li>
<li>$1 &lt;= arr[i], value &lt;= 10^4$</li>
<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
<li>调用 <code>query</code> 不超过 $10^5$ 次。</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-哈希集合-二分查找"><a href="#2-1-哈希集合-二分查找" class="headerlink" title="2.1 哈希集合+二分查找"></a>2.1 哈希集合+二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeFreqQuery</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个映射，用于存储每个数字在数组中的出现位置</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，用于初始化对象并构建map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RangeFreqQuery</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，记录每个数字出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="comment">// 如果map中没有该数字，初始化一个新的列表</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num)) map.put(num,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">            map.get(num).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询函数，返回值为目标数字在指定范围内的出现次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(value)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 如果map中没有目标数字，直接返回0</span></span><br><span class="line">        List&lt;Integer&gt; list = map.get(value);<span class="comment">// 获取目标数字的所有出现位置列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用二分查找找到左边界和右边界对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> binarySearch(list, left, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> binarySearch(list, right, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算并返回目标数字在指定范围内的出现次数</span></span><br><span class="line">        <span class="keyword">return</span> rightIndex - leftIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找辅助函数，用于查找目标值的左边界或右边界索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;Integer&gt; list, <span class="type">int</span> target, <span class="type">boolean</span> findFirst)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> min + (max - min) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 根据标志位选择合适的边界，继续缩小查找范围</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; list.get(mid) || (findFirst &amp;&amp; target &lt;= list.get(mid))) &#123;</span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左边界或右边界对应的索引</span></span><br><span class="line">        <span class="keyword">return</span> findFirst ? min : min - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>二分法</tag>
        <tag>哈希集合</tag>
      </tags>
  </entry>
  <entry>
    <title>长度最小的子数组 | LeetCode-209 | 双指针+滑动窗口 | 前缀和+二分查找</title>
    <url>/2024/08/09/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<center><b>滑动窗口入门题 前缀和入门题</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>子数组</strong><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = <span class="comment">[2,3,1,2,4,3]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 <span class="comment">[4,3]</span> 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：target = <span class="number">11</span>, nums = [<span class="number">1,1,1,1</span>,<span class="number">1,1,1,1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= target &lt;= 10^9$</li>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$1 &lt;= nums[i] &lt;= 10^5$</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li>方法2的时间复杂度$O(n)$</li>
<li>方法3的时间复杂度$O(nlog(n))$</li>
</ul>
<h2 id="2-1-暴力解法-超出时间限制"><a href="#2-1-暴力解法-超出时间限制" class="headerlink" title="2.1 暴力解法-超出时间限制"></a>2.1 暴力解法-超出时间限制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化结果为一个较大的数，用于记录找到的最小子数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 外层循环：从数组的每一个元素作为起点开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化当前子数组的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 内层循环：从当前起点向右扩展子数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 累加当前子数组的和</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果当前子数组的和大于等于目标值</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    <span class="comment">// 更新最小长度</span></span><br><span class="line">                    ans = Math.min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 找到一个满足条件的子数组后，立即停止内层循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有找到满足条件的子数组，返回0，否则返回找到的最小长度</span></span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针-滑动窗口"><a href="#2-2-双指针-滑动窗口" class="headerlink" title="2.2 双指针+滑动窗口"></a>2.2 双指针+滑动窗口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化滑动窗口的和为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化左指针，右指针将通过循环向右移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right;</span><br><span class="line">        <span class="comment">// 初始化最小长度为数组长度+1，这是一个不可能的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> nums.length + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过右指针遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素加入滑动窗口的和</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当滑动窗口内的和大于等于目标值时，尝试缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="comment">// 更新最小长度为当前窗口的长度</span></span><br><span class="line">                minLen = Math.min(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 缩小窗口，即将左指针指向的值移出窗口</span></span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到符合条件的子数组，返回0，否则返回最小长度</span></span><br><span class="line">        <span class="keyword">return</span> minLen == nums.length + <span class="number">1</span> ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-前缀和-二分查找"><a href="#2-3-前缀和-二分查找" class="headerlink" title="2.3 前缀和+二分查找"></a>2.3 前缀和+二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化结果变量，记录最小的子数组长度，初始值设为最大整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并初始化前缀和数组</span></span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算新的目标值，这个值表示需要找到的子数组的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newTarget</span> <span class="operator">=</span> target + sums[i - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 二分查找，寻找大于等于newTarget的最小索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i, right = sums.length;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (sums[mid] &lt; newTarget) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查找到的索引是否在有效范围内，并更新最小长度</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; sums.length) &#123;</span><br><span class="line">                minLen = Math.min(minLen, left - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到满足条件的子数组，则返回0，否则返回最小长度</span></span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>二分法</tag>
        <tag>滑动窗口</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>删除有序数组中的重复项 | LeetCode-26 | 双指针</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<center><b>双指针也有简单题！</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int[] nums <span class="operator">=</span> [...]<span class="comment">; // 输入数组</span></span><br><span class="line">int[] expectedNums <span class="operator">=</span> [...]<span class="comment">; // 长度正确的期望答案</span></span><br><span class="line"></span><br><span class="line">int k <span class="operator">=</span> removeDuplicates(nums)<span class="comment">; // 调用</span></span><br><span class="line"></span><br><span class="line">assert k <span class="operator">=</span><span class="operator">=</span> expectedNums.length<span class="comment">;</span></span><br><span class="line">for (int i <span class="operator">=</span> <span class="number">0</span><span class="comment">; i &lt; k; i++) &#123;</span></span><br><span class="line">    assert nums[i] <span class="operator">=</span><span class="operator">=</span> expectedNums[i]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：2, nums = <span class="comment">[1,2,_]</span></span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,0,1,1</span>,<span class="number">1,2,2,3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0,1,2,3</span>,<span class="number">4</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 3 * 10^4$</li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
<li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-双指针"><a href="#2-1-双指针" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化左指针left，指向数组的第二个位置，表示下一个可以填充新元素的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素与前一个元素不同，说明找到了一个新元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[right] != nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                 <span class="comment">// 将新元素放置到左指针位置，并移动左指针</span></span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回去重后数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化左指针left，指向数组的第二个位置，表示下一个可以填充新元素的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素与前一个元素不同，说明找到了一个新元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[right] != nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左指针小于右指针，说明有重复元素被跳过，需要将新元素填充到左指针位置</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移动左指针，准备下一个可以填充新元素的位置</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回去重后数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>原地移除元素</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 27 | 移除元素 | 双指针</title>
    <url>/2024/08/01/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<center><b>原地移除元素1</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code>。</li>
</ul>
<p><strong>用户评测：</strong></p>
<p>评测机将使用以下代码测试您的解决方案：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span><span class="literal">[]</span> nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">val</span> = ...; <span class="comment">// 要移除的值</span></span><br><span class="line"><span class="built_in">int</span><span class="literal">[]</span> expectedNums = [...]; <span class="comment">// 长度正确的预期答案。</span></span><br><span class="line">                            <span class="comment">// 它以不等于 val 的值排序。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> k = removeElement(nums, <span class="keyword">val</span>); <span class="comment">// 调用你的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> k<span class="operator"> == </span>expectedNums.length;</span><br><span class="line">sort(nums, <span class="number">0</span>, k); <span class="comment">// 排序 nums 的前 k 个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; actualLength; i++) &#123;</span><br><span class="line">    <span class="keyword">assert</span> nums[i]<span class="operator"> == </span>expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="literal">_</span>,<span class="literal">_</span>]</span><br><span class="line">解释：你的函数函数应该返回 k = <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,1,2,2</span>,<span class="number">3,0,4,2</span>], val = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0,1,4,0</span>,<span class="number">3</span>,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = <span class="number">5</span>，并且 nums 中的前五个元素为 <span class="number">0,0,1,3</span>,<span class="number">4</span>。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-双指针"><a href="#2-1-双指针" class="headerlink" title="2.1 双指针"></a>2.1 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化左指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素不等于要移除的值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                <span class="comment">// 将当前元素赋值给左指针位置，并将左指针右移</span></span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的数组长度，即左指针的位置</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针优化"><a href="#2-2-双指针优化" class="headerlink" title="2.2 双指针优化"></a>2.2 双指针优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化左指针为数组的起始位置，右指针为数组的末尾位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左指针小于或等于右指针时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 如果左指针位置的元素等于要移除的值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">                <span class="comment">// 将右指针位置的元素赋值给左指针位置</span></span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                <span class="comment">// 右指针左移一位</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果左指针位置的元素不等于要移除的值，左指针右移一位</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的数组长度，即左指针的位置</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>原地移除元素</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 283 | 移动零 | 双指针</title>
    <url>/2024/08/04/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<center><b>原地移除元素1</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="string">[0,1,0,3,12]</span></span><br><span class="line">输出: <span class="string">[1,3,12,0,0]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="comment">[0]</span></span><br><span class="line">输出: <span class="comment">[0]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>:</p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li>$-2^{31} &lt;= nums[i] &lt;= 2^{31} - 1$</li>
</ul>
<p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li>注意这道题目需要保证非零元素的相对顺序，而这道题目的相对顺序可以改变：<a href="https://zzxrepository.github.io/2024/08/01/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">27.移除元素</a></li>
</ul>
<h2 id="2-1-双指针-一次遍历-操作次数多"><a href="#2-1-双指针-一次遍历-操作次数多" class="headerlink" title="2.1 双指针 | 一次遍历 | 操作次数多"></a>2.1 双指针 | 一次遍历 | 操作次数多</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用双指针方法，一次遍历数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素不是0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 交换当前元素和左指针指向的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[right];</span><br><span class="line">                nums[right] = nums[left];</span><br><span class="line">                nums[left] = temp;</span><br><span class="line">                <span class="comment">// 左指针右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针-两次遍历-操作次数少"><a href="#2-2-双指针-两次遍历-操作次数少" class="headerlink" title="2.2  双指针 | 两次遍历 | 操作次数少"></a>2.2  双指针 | 两次遍历 | 操作次数少</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次遍历，使用 j 指针记录非零元素的个数</span></span><br><span class="line">        <span class="comment">// 只要是非零元素，就将其赋给 nums[j]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非零元素统计完了，剩下的元素都是零</span></span><br><span class="line">        <span class="comment">// 第二次遍历，将数组末尾的元素都赋值为零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>原地移除元素</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集 | LeetCode-349 | 哈希集合 | 哈希数组 | 双指针 | 四种解法</title>
    <url>/2024/08/02/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<center><b>再说一遍，能用哈希集合做的，哈希数组也有可能做出来！</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的</em> 交集。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2,2,1]</span>, nums2 = <span class="comment">[2,2]</span></span><br><span class="line">输出：<span class="comment">[2]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[4,9,5]</span>, nums2 = <span class="comment">[9,4,9,8,4]</span></span><br><span class="line">输出：<span class="comment">[9,4]</span></span><br><span class="line">解释：<span class="comment">[4,9]</span> 也是可通过的</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-直接法-暴力解法-哈希集合"><a href="#2-1-直接法-暴力解法-哈希集合" class="headerlink" title="2.1 直接法(暴力解法)-哈希集合"></a>2.1 直接法(暴力解法)-哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 创建两个 HashSet，用于存储 nums1 和 nums2 中的所有元素</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 nums1 中的所有元素添加到 set1 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 nums2 中的所有元素添加到 set2 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 set1 和 set2 的交集，并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个集合的交集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getIntersection(Set&lt;Integer&gt; set1, Set&lt;Integer&gt; set2) &#123;</span><br><span class="line">        <span class="comment">// 如果 set1 的大小大于 set2，交换它们的位置以减少遍历次数</span></span><br><span class="line">        <span class="keyword">if</span> (set1.size() &gt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 HashSet 存储交集元素</span></span><br><span class="line">        Set&lt;Integer&gt; intersectionSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 set1，将同时存在于 set1 和 set2 中的元素添加到 intersectionSet 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.contains(num)) &#123;</span><br><span class="line">                intersectionSet.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将交集集合转换为数组</span></span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[intersectionSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : intersectionSet) &#123;</span><br><span class="line">            intersection[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-哈希集合优化"><a href="#2-2-哈希集合优化" class="headerlink" title="2.2 哈希集合优化"></a>2.2 哈希集合优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 HashSet 存储 nums1 中的所有元素，以去除重复并快速查找</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 nums1 中的每个元素添加到 HashSet 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            set.add(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 HashSet 存储结果，记录 nums2 中与 nums1 交集的元素</span></span><br><span class="line">        Set&lt;Integer&gt; resultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums2 的当前元素在 nums1 的集合中存在，则添加到结果集合中</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums2[i])) resultSet.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 将 resultSet 集合转换为数组</span></span><br><span class="line">        <span class="comment">// 方式1：手动遍历 resultSet 将其转换为数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[resultSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : resultSet) &#123;</span><br><span class="line">            result[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式2：使用 Stream API 将 resultSet 转换为数组</span></span><br><span class="line">        <span class="comment">// result = resultSet.stream().mapToInt(Integer::intValue).toArray();</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-哈希数组"><a href="#2-3-哈希数组" class="headerlink" title="2.3 哈希数组"></a>2.3 哈希数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 创建两个大小为 1001 的数组，用于记录 nums1 和 nums2 中元素的出现情况</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 nums1，记录每个元素的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            arr1[nums1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录交集元素的个数</span></span><br><span class="line">        <span class="comment">// 遍历 nums2，检查元素是否存在于 nums1 中且未被记录到 arr2 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[nums2[i]] != <span class="number">0</span> &amp;&amp; arr2[nums2[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++; <span class="comment">// 找到一个交集元素，计数器加 1</span></span><br><span class="line">                arr2[nums2[i]]++; <span class="comment">// 标记该元素已被记录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组用于存储交集结果</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历 arr2，将交集元素添加到结果数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr2[i] != <span class="number">0</span>) result[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-排序-双指针"><a href="#2-4-排序-双指针" class="headerlink" title="2.4 排序+双指针"></a>2.4 排序+双指针</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] <span class="built_in">int</span>ersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 首先对两个数组进行排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取两个数组的长度</span></span><br><span class="line">        <span class="built_in">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个数组，用于存储交集元素，大小为两个数组长度之和（确保有足够空间）</span></span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">int</span>ersection = new <span class="built_in">int</span>[length1 + length2];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用于跟踪结果数组的当前位置</span></span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用于遍历 nums1 和 nums2 的索引</span></span><br><span class="line">        <span class="built_in">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当两个数组都没有遍历完时，执行以下操作</span></span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="comment">// 取出当前 index1 和 index2 所指向的元素</span></span><br><span class="line">            <span class="built_in">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果两个元素相等，说明找到了一个交集元素</span></span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证交集数组中元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || num1 != <span class="built_in">int</span>ersection[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">int</span>ersection[index++] = num1; <span class="comment">// 将元素添加到交集数组中</span></span><br><span class="line">                &#125;</span><br><span class="line">                index1++; <span class="comment">// 移动 nums1 的指针</span></span><br><span class="line">                index2++; <span class="comment">// 移动 nums2 的指针</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 num1 小于 num2，则移动 nums1 的指针</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 num1 大于 num2，则移动 nums2 的指针</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将交集数组的有效部分复制到一个新的数组中并返回</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(<span class="built_in">int</span>ersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-JS语法糖"><a href="#2-5-JS语法糖" class="headerlink" title="2.5 JS语法糖"></a>2.5 JS语法糖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">var</span> <span class="variable">intersection</span> <span class="operator">=</span> function(nums1, nums2) &#123;</span><br><span class="line">    <span class="comment">// 将两个数组转换为 Set 集合，自动去重</span></span><br><span class="line">    <span class="type">let</span> <span class="variable">set1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Set</span>(nums1);</span><br><span class="line">    <span class="type">let</span> <span class="variable">set2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Set</span>(nums2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Array.from 和 filter 结合来获取两个 Set 集合的交集</span></span><br><span class="line">    <span class="keyword">return</span> [...set1].filter(num =&gt; set2.has(num));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>哈希集合</tag>
        <tag>哈希数组</tag>
      </tags>
  </entry>
  <entry>
    <title>四数相加2 | LeetCode-454 | 哈希集合</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/</url>
    <content><![CDATA[<center><b>四数相加 => 两数相加</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">-2</span>,<span class="number">-1</span>], <span class="symbol">nums3</span> = [<span class="number">-1</span>,<span class="number">2</span>], <span class="symbol">nums4</span> = [<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line"><span class="number">1.</span> <span class="comment">(0, 0, 0, 1)</span> -&gt; <span class="symbol">nums1</span>[<span class="number">0</span>] + <span class="symbol">nums2</span>[<span class="number">0</span>] + <span class="symbol">nums3</span>[<span class="number">0</span>] + <span class="symbol">nums4</span>[<span class="number">1</span>] = <span class="number">1</span> + <span class="comment">(-2)</span> + <span class="comment">(-1)</span> + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span> <span class="comment">(1, 1, 0, 0)</span> -&gt; <span class="symbol">nums1</span>[<span class="number">1</span>] + <span class="symbol">nums2</span>[<span class="number">1</span>] + <span class="symbol">nums3</span>[<span class="number">0</span>] + <span class="symbol">nums4</span>[<span class="number">0</span>] = <span class="number">2</span> + <span class="comment">(-1)</span> + <span class="comment">(-1)</span> + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">0</span>], <span class="symbol">nums2</span> = [<span class="number">0</span>], <span class="symbol">nums3</span> = [<span class="number">0</span>], <span class="symbol">nums4</span> = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>n == nums3.length</code></li>
<li><code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li>$-2^{28} &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^{28}$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-分组-哈希集合"><a href="#2-1-分组-哈希集合" class="headerlink" title="2.1 分组+哈希集合"></a>2.1 分组+哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="comment">// 创建一个 HashMap 来存储两个数组（nums1 和 nums2）元素之和出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化计数器 count，用于存储符合条件的四元组数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双重循环遍历 nums1 和 nums2 数组中的所有元素组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算 nums1[i] 和 nums2[j] 的和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 sum 作为键存储在 map 中，值为这个和出现的次数</span></span><br><span class="line">                <span class="comment">// 如果 sum 已经存在于 map 中，则将对应的值加 1，否则将其初始化为 1</span></span><br><span class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次使用双重循环遍历 nums3 和 nums4 数组中的所有元素组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算目标差值 diff，即 0 - (nums3[i] + nums4[j])</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span> - nums3[i] - nums4[j];</span><br><span class="line">                <span class="comment">// 如果 map 中存在这个 diff，则说明存在一个四元组使得四个数组的元素之和为 0</span></span><br><span class="line">                <span class="comment">// 计数器 count 增加 map.get(diff) 次，因为 map.get(diff) 表示 nums1 和 nums2 中和为 diff 的次数</span></span><br><span class="line">                count += map.getOrDefault(diff, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终计数器的值，即符合条件的四元组数量</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>哈希集合</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间 | LeetCode-56</title>
    <url>/2024/09/15/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<center><b>分类不好，这道题就做不出来！</b></center>

<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间<a/></b></p>
<center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,4],[4,5]]</span></span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= intervals.length &lt;= 10^4$</li>
<li><code>intervals[i].length == 2</code></li>
<li>$0 &lt;= start_i &lt;= end_i &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 如果区间数组为空，直接返回空数组</span></span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将区间数组按每个区间的起始位置进行排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] intervals1, <span class="type">int</span>[] intervals2)</span> &#123;</span><br><span class="line">                <span class="comment">// 按照区间的起始值升序排列</span></span><br><span class="line">                <span class="keyword">return</span> intervals1[<span class="number">0</span>] - intervals2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来保存合并后的区间</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前区间的左边界 L 和右边界 R</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 result 为空，或者 result 中最后一个区间的右边界小于当前区间的左边界</span></span><br><span class="line">            <span class="comment">// 说明当前区间与前一个区间没有重叠，直接添加当前区间</span></span><br><span class="line">            <span class="keyword">if</span>(result.size() == <span class="number">0</span> || result.get(result.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，说明当前区间和前一个区间有重叠</span></span><br><span class="line">                <span class="comment">// 将最后一个区间的右边界更新为两个区间中较大的右边界，合并区间</span></span><br><span class="line">                resultList.get(result.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(result.get(result.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果列表转换为二维数组形式并返回</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵 | LeetCode-59 | LeetCode-54 | 分类讨论</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52/</url>
    <content><![CDATA[<center><b>分类不好，这道题就做不出来！</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II<a/></b>
    <br>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵<a/></b>
</center>


<hr>
<h1 id="题目1：螺旋矩阵II"><a href="#题目1：螺旋矩阵II" class="headerlink" title="题目1：螺旋矩阵II"></a>题目1：螺旋矩阵II</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[[1,2,3],[8,9,4],[7,6,5]]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-直接法-分类讨论"><a href="#2-1-直接法-分类讨论" class="headerlink" title="2.1 直接法-分类讨论"></a>2.1 直接法-分类讨论</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 n x n 的矩阵，用于存放螺旋顺序的数字</span></span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 计算需要填充螺旋圈的数量（当 n 为偶数时，正好填满；当 n 为奇数时，中间会剩余一个元素）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 初始化数字计数器，从 1 开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 定义四个边界：上、下、左、右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环处理每一层的螺旋圈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 从左到右填充当前顶部的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) result[top][j] = count++;</span><br><span class="line">            <span class="comment">// 从上到下填充当前右边的一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> top; j &lt; bottom; j++) result[j][right] = count++;</span><br><span class="line">            <span class="comment">// 从右到左填充当前底部的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right; j &gt; left; j--) result[bottom][j] = count++;</span><br><span class="line">            <span class="comment">// 从下到上填充当前左边的一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bottom; j &gt; top; j--) result[j][left] = count++;</span><br><span class="line">            <span class="comment">// 缩小边界，进入下一层螺旋圈</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 n 是奇数，填充矩阵中心的最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            result[left][top] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回填充好的螺旋矩阵</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-方法二-解决中心值忘记赋值问题"><a href="#2-2-方法二-解决中心值忘记赋值问题" class="headerlink" title="2.2 方法二-解决中心值忘记赋值问题"></a>2.2 方法二-解决中心值忘记赋值问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 n x n 的矩阵，用于存放螺旋顺序的数字</span></span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化数字计数器，从 1 开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 目标值，表示填充到矩阵中的最大数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="comment">// 定义四个边界：上、下、左、右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始填充矩阵，直到填满目标值</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= target) &#123;</span><br><span class="line">            <span class="comment">// 从左到右填充当前顶部的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) result[top][i] = count++;</span><br><span class="line">            <span class="comment">// 填充完一行后，移动上边界下移一行</span></span><br><span class="line">            top++;</span><br><span class="line">            <span class="comment">// 从上到下填充当前右边的一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) result[i][right] = count++;</span><br><span class="line">            <span class="comment">// 填充完一列后，移动右边界左移一列</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 从右到左填充当前底部的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) result[bottom][i] = count++;</span><br><span class="line">            <span class="comment">// 填充完一行后，移动下边界上移一行</span></span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="comment">// 从下到上填充当前左边的一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) result[i][left] = count++;</span><br><span class="line">            <span class="comment">// 填充完一列后，移动左边界右移一列</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回填充好的螺旋矩阵</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-方法3-通解"><a href="#2-3-方法3-通解" class="headerlink" title="2.3 方法3-通解"></a>2.3 方法3-通解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 n x n 的矩阵用于存储结果</span></span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化从 1 开始的计数器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 目标计数为 n*n，表示矩阵中应有的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="comment">// 定义四个边界：上(top)、下(bottom)、左(left)、右(right)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环继续，直到所有的边界都相交</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 从左到右填充矩阵的上边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) result[top][i] = count++;</span><br><span class="line">            <span class="comment">// 从上到下填充矩阵的右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top + <span class="number">1</span>; i &lt;= bottom; i++) result[i][right] = count++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确保矩阵中至少有两行两列，然后填充底边和左边</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="comment">// 从右到左填充矩阵的下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt; left; i--) result[bottom][i] = count++;</span><br><span class="line">                <span class="comment">// 从下到上填充矩阵的左边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt; top; i--) result[i][left] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调整边界，以缩小矩阵范围</span></span><br><span class="line">            bottom--;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回生成的螺旋矩阵</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：螺旋矩阵"><a href="#题目2：螺旋矩阵" class="headerlink" title="题目2：螺旋矩阵"></a>题目2：螺旋矩阵</h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,3,6,9,8,7,4,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1,2,3,4</span>],[<span class="number">5,6,7,8</span>],[<span class="number">9,10,11,12</span>]]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>,<span class="number">8,12,11,10</span>,<span class="number">9,5,6,7</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-方法1-通解"><a href="#2-1-方法1-通解" class="headerlink" title="2.1 方法1-通解"></a>2.1 方法1-通解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个列表用于存储结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 定义四个边界：左(left)、右(right)、上(top)、下(bottom)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 循环执行，直到所有边界重合</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 从左到右填充矩阵的上边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) result.add(matrix[top][i]);</span><br><span class="line">            <span class="comment">// 从上到下填充矩阵的右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top + <span class="number">1</span>; i &lt;= bottom; i++) result.add(matrix[i][right]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确保矩阵中至少有两行两列，然后填充底边和左边</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="comment">// 从右到左填充矩阵的下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt; left; i--) result.add(matrix[bottom][i]);</span><br><span class="line">                <span class="comment">// 从下到上填充矩阵的左边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt; top; i--) result.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调整边界，以缩小矩阵范围</span></span><br><span class="line">            bottom--;  <span class="comment">// 下边界上移</span></span><br><span class="line">            right--;   <span class="comment">// 右边界左移</span></span><br><span class="line">            top++;     <span class="comment">// 上边界下移</span></span><br><span class="line">            left++;    <span class="comment">// 左边界右移</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终的结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-方法2"><a href="#2-2-方法2" class="headerlink" title="2.2 方法2"></a>2.2 方法2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个列表用于存储结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义四个边界：左(left)、右(right)、上(top)、下(bottom)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环执行</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 从左到右遍历矩阵的上边界，并将元素加入结果列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) result.add(matrix[top][i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将上边界下移，如果上边界超过下边界，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (++top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下遍历矩阵的右边界，并将元素加入结果列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) result.add(matrix[i][right]);</span><br><span class="line">            <span class="comment">// 将右边界左移，如果左边界超过右边界，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; --right) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右到左遍历矩阵的下边界，并将元素加入结果列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) result.add(matrix[bottom][i]);</span><br><span class="line">            <span class="comment">// 将下边界上移，如果上边界超过下边界，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (top &gt; --bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从下到上遍历矩阵的左边界，并将元素加入结果列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) result.add(matrix[i][left]);     </span><br><span class="line">            <span class="comment">// 将左边界右移，如果左边界超过右边界，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终的结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>数组</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode | 643 | 子数组最大平均数 | 双指针 | 滑动窗口</title>
    <url>/2024/08/02/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/</url>
    <content><![CDATA[<center><b>双指针在一定条件下可以转化成滑动窗口，这道题就是个很好的例子</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong> 的连续子数组，并输出该最大平均数。</p>
<p>任何误差小于 <code>10-5</code> 的答案都将被视为正确答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,12,<span class="string">-5</span>,<span class="string">-6</span>,50,3], k = 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12<span class="string">-5</span><span class="string">-6</span><span class="string">+50</span>)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5.00000</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li>$1 &lt;= k &lt;= n &lt;= 10^5$</li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法（超出时间限制）"><a href="#2-1-暴力解法（超出时间限制）" class="headerlink" title="2.1 暴力解法（超出时间限制）"></a>2.1 暴力解法（超出时间限制）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化最大平均值为负无穷</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">maxAverage</span> <span class="operator">=</span> Double.NEGATIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中的所有可能的长度为 k 的连续子数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length - k; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前子数组的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; i + k; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前子数组的平均值</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> (<span class="type">double</span>) sum / k;</span><br><span class="line">            <span class="comment">// 更新最大平均值</span></span><br><span class="line">            maxAverage = average &gt; maxAverage ? average : maxAverage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最大平均值</span></span><br><span class="line">        <span class="keyword">return</span> maxAverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h2><ul>
<li>由于每次都要计算平均值，所以在这里做一个处理，先求出长度为<code>k</code>的区间和的最大值，返回时再求平均</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化最大和为最小整数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 左右指针初始化</span></span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="comment">// 当前窗口的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素加入窗口和</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前窗口大小等于 k，更新最大和</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> == k) &#123;</span><br><span class="line">                maxSum = Math.max(maxSum, sum);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当窗口大小大于等于 k 时，移动左指针</span></span><br><span class="line">            <span class="keyword">while</span> (right - left + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                <span class="comment">// 将窗口左边界的元素移出和</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                <span class="comment">// 移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最大和对应的平均值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) maxSum / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-双指针优化-gt-滑动窗口"><a href="#2-3-双指针优化-gt-滑动窗口" class="headerlink" title="2.3 双指针优化=&gt;滑动窗口"></a>2.3 双指针优化=&gt;滑动窗口</h2><ul>
<li>由于所求的窗口的长度是固定的，因此首先计算出数组前<code>k</code>个区间的和，然后再向后滑动区间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算第一个长度为 k 的子数组的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            maxSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前子数组的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> maxSum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用滑动窗口遍历数组中的其他可能的长度为 k 的连续子数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新当前子数组的和</span></span><br><span class="line">            currentSum = currentSum - nums[i - k] + nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大和</span></span><br><span class="line">            <span class="keyword">if</span> (currentSum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = currentSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最大平均值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) maxSum / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组 | LeetCode-88 |</title>
    <url>/2024/09/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>双指针进阶练习，在做这道题目之前大家可以先做一道这道题目，从这道题目中找思路：</p>
</blockquote>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="comment">[2,5,6]</span>, n = 3</span><br><span class="line">输出：<span class="comment">[1,2,2,3,5,6]</span></span><br><span class="line">解释：需要合并 <span class="comment">[1,2,3]</span> 和 <span class="comment">[2,5,6]</span> 。</span><br><span class="line">合并结果是 <span class="comment">[1,2,2,3,5,6]</span> ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1]</span>, m = 1, nums2 = <span class="comment">[]</span>, n = 0</span><br><span class="line">输出：<span class="comment">[1]</span></span><br><span class="line">解释：需要合并 <span class="comment">[1]</span> 和 <span class="comment">[]</span> 。</span><br><span class="line">合并结果是 <span class="comment">[1]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[0]</span>, m = 0, nums2 = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br><span class="line">解释：需要合并的数组是 <span class="comment">[]</span> 和 <span class="comment">[1]</span> 。</span><br><span class="line">合并结果是 <span class="comment">[1]</span> 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li>$-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9$</li>
</ul>
<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力解法：直接合并,然后排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums1[m+i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1：使用内置函数</span></span><br><span class="line">        <span class="comment">//Arrays.sort(nums1);</span></span><br><span class="line">        <span class="comment">//方式2：冒泡排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums1.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums1[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums1[j];</span><br><span class="line">                    nums1[j] = nums1[i];</span><br><span class="line">                    nums1[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针，i 指向 nums1 的第一个元素，j 指向 nums2 的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建一个临时数组 result，用于存储合并后的有序数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">        <span class="type">int</span> cur;  <span class="comment">// 当前需要填入 result 的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i 或 j 不越界时，进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1 的所有有效元素已经处理完毕，将 nums2 的剩余元素直接放入 result</span></span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                cur = nums2[j++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果 nums2 的所有元素已经处理完毕，将 nums1 的剩余元素放入 result</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                cur = nums1[i++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果 nums1 当前元素小于 nums2 当前元素，将 nums1 的当前元素放入 result</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                cur = nums1[i++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 否则将 nums2 当前元素放入 result</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前值填入 result 的相应位置</span></span><br><span class="line">            result[i + j - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 result 数组中的元素复制回 nums1 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums1.length; l++) &#123;</span><br><span class="line">            nums1[l] = result[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-逆向双指针"><a href="#2-3-逆向双指针" class="headerlink" title="2.3 逆向双指针"></a>2.3 逆向双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针，i 指向 nums1 有效部分的最后一个元素，j 指向 nums2 的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m + n - <span class="number">1</span>;<span class="comment">// tail 指向 nums1 的最后一个位置，作为填充的位置</span></span><br><span class="line">        <span class="type">int</span> cur;  <span class="comment">// 当前需要填入 nums1 的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i 或 j 不越界时，进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;<span class="comment">// 如果 nums1 已经全部填完了，则将 nums2 中剩下的元素直接填入 nums1</span></span><br><span class="line">                cur = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;<span class="comment">// 如果 nums2 已经全部填完了，则将 nums1 中剩下的元素留在原地</span></span><br><span class="line">                cur = nums1[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;<span class="comment">// 比较 nums1 和 nums2 的当前元素，将较大值填入 nums1 的尾部</span></span><br><span class="line">                cur = nums1[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前值填入 nums1 的尾部</span></span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>水果成篮 | LeetCode-904 | 双指针  | 哈希集合 | 哈希数组</title>
    <url>/2024/08/09/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
    <content><![CDATA[<center><b>能用哈希哈希集合解决的问题，大概率也可以使用哈希集合</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：fruits </span>=<span class="string"> [1,2,1]</span></span><br><span class="line"><span class="string">输出：3</span></span><br><span class="line"><span class="string">解释：可以采摘全部 3 棵树。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：fruits = <span class="comment">[0,1,2,2]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 <span class="comment">[1,2,2]</span> 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 <span class="comment">[0,1]</span> 这两棵树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：fruits = <span class="comment">[1,2,3,2,2]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 <span class="comment">[2,3,2,2]</span> 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 <span class="comment">[1,2]</span> 这两棵树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：fruits = [<span class="number">3,3,3,1</span>,<span class="number">2,1,1,2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以采摘 [<span class="number">1,2,1,1</span>,<span class="number">2</span>] 这五棵树。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= fruits.length &lt;= 10^5$</li>
<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-哈希集合"><a href="#2-1-哈希集合" class="headerlink" title="2.1 哈希集合"></a>2.1 哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用哈希表记录每种水果的数量</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 左指针（滑动窗口的左边界）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于存储当前可以收集到的最大水果数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右指针（滑动窗口的右边界）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; fruits.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 将当前水果加入哈希表，并增加其数量</span></span><br><span class="line">            map.put(fruits[right], map.getOrDefault(fruits[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果哈希表中的水果种类超过了两种，则移动左指针收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 减少左边水果的数量</span></span><br><span class="line">                map.put(fruits[left], map.get(fruits[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如果某种水果的数量减少到0，则将其从哈希表中移除</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左指针右移，缩小窗口</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大收集水果数量，窗口的大小为 right - left + 1</span></span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大可以收集的水果数量</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-哈希数组"><a href="#2-2-哈希数组" class="headerlink" title="2.2 哈希数组"></a>2.2 哈希数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于记录每种水果在当前窗口中的数量</span></span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[fruits.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxFruits</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 存储最大连续水果数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">types</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 记录当前窗口内的水果种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历水果数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; fruits.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前水果种类第一次出现，增加种类数</span></span><br><span class="line">            <span class="keyword">if</span> (map[fruits[right]] == <span class="number">0</span>) types++;</span><br><span class="line">            map[fruits[right]]++;</span><br><span class="line">            <span class="comment">// 如果水果种类超过2种，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> (types &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                map[fruits[left]]--;</span><br><span class="line">                <span class="comment">// 如果一种水果的数量减少到0，则减少种类数</span></span><br><span class="line">                <span class="keyword">if</span> (map[fruits[left]] == <span class="number">0</span>) types--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前窗口的最大水果数量</span></span><br><span class="line">            maxFruits = Math.max(maxFruits, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxFruits;  <span class="comment">// 返回最大连续水果数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>精简版：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于记录每种水果的数量</span></span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[fruits.length];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxFruits</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 存储最大连续水果数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">types</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 记录当前的水果种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line">        <span class="comment">// 遍历所有水果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; fruits.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前水果种类第一次出现，增加种类数</span></span><br><span class="line">            <span class="keyword">if</span> (map[fruits[right]]++ == <span class="number">0</span>) types++;</span><br><span class="line">            <span class="comment">// 如果水果种类超过2种，收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> (types &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--map[fruits[left++]] == <span class="number">0</span>) types--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前窗口的最大水果数量</span></span><br><span class="line">            maxFruits = Math.max(maxFruits, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxFruits;  <span class="comment">// 返回最大连续水果数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>双指针</tag>
        <tag>哈希集合</tag>
        <tag>哈希数组</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组的平方 | LeetCode-977 | 双指针</title>
    <url>/2024/08/01/algorithm/leetcode/%E6%95%B0%E7%BB%84/LeetCode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<center><b>这是一道一看就会，一做就错的题目！</b></center>

<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1,0,3,10</span>]</span><br><span class="line">输出：[<span class="number">0,1,9,16</span>,<span class="number">100</span>]</span><br><span class="line">解释：平方后，数组变为 [<span class="number">16,1,0,9</span>,<span class="number">100</span>]</span><br><span class="line">排序后，数组变为 [<span class="number">0,1,9,16</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">7</span>,-<span class="number">3,2,3,11</span>]</span><br><span class="line">输出：[<span class="number">4,9,9,49</span>,<span class="number">121</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//暴力解法</span></span><br><span class="line">        <span class="comment">//创建结果返回数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//给数组赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            result[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//方式1：调用库函数</span></span><br><span class="line">        <span class="comment">//Arrays.sort(result);</span></span><br><span class="line">        <span class="comment">//方式2:冒泡排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;result.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(result[i]&gt;result[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> result[j];</span><br><span class="line">                    result[j] = result[i];</span><br><span class="line">                    result[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针"><a href="#2-2-双指针" class="headerlink" title="2.2 双指针"></a>2.2 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 创建一个用于存储结果的数组，大小与输入数组相同</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化双指针，一个指向数组的开头，另一个指向数组的结尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化返回数组的索引，从最后一个位置开始填充</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newIndex</span> <span class="operator">=</span> result.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历直到左指针超过右指针</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 比较左右指针对应元素的平方值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;</span><br><span class="line">                <span class="comment">// 如果左指针对应元素的平方大于右指针的平方值</span></span><br><span class="line">                <span class="comment">// 将左指针的平方值放入返回数组的当前位置</span></span><br><span class="line">                result[newIndex--] = nums[left] * nums[left];</span><br><span class="line">                <span class="comment">// 左指针右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，将右指针的平方值放入返回数组的当前位置</span></span><br><span class="line">                result[newIndex--] = nums[right] * nums[right];</span><br><span class="line">                <span class="comment">// 右指针左移</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回排序后的平方值数组</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>K次取反之后的最大化的数组 | LeetCode-1005 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>
</ul>
<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>
<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[4,2,3]</span>, k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为 <span class="comment">[4,-2,3]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,-1,0,2]</span>, k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 (1, 2, 2) ，nums 变为 <span class="comment">[3,1,0,2]</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,<span class="string">-3</span>,<span class="string">-1</span>,5,<span class="string">-4</span>], k = 2</span><br><span class="line">输出：13</span><br><span class="line">解释：选择下标 (1, 4) ，nums 变为 [2,3,<span class="string">-1</span>,5,4] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
<li>$1 &lt;= k &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组按绝对值进行排序，使用自定义比较器</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 尝试将负数变为正数，直到用完k次操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = -nums[i]; <span class="comment">// 变为正数</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还有剩余的k，并且是奇数，则将数组中绝对值最小的元素变为负数</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            nums[<span class="number">0</span>] *= -<span class="number">1</span>; <span class="comment">// 变为负数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) sum += num;<span class="comment">// 计算数组元素的总和</span></span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">// 返回最大的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h2>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>全网超全的二分查找细节总结！ | 二分查找</title>
    <url>/2024/08/10/algorithm/leetcode/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<blockquote>
<p><strong>老子说：天下大事必作于细；天下难事必作于易，如果不知道这些细节，你就没用学明白二分查找！</strong></p>
</blockquote>
<h1 id="1-基础版二分查找细节"><a href="#1-基础版二分查找细节" class="headerlink" title="1.基础版二分查找细节"></a>1.基础版二分查找细节</h1><ul>
<li>今天毛毛张要分享的是LeetCode中最简单的一道题目：二分查找，二分查找算法虽然简单但却是非常难写，里面隐藏着很多细节需要注意，否则一旦变更一下要求就会出错</li>
<li>下面我们首先来看一下二分查找的题目：<strong>LeetCode链表：<a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></strong></li>
<li><strong>注意事项1：这道题目的前提条件是，数组中的元素按照严格升序的顺序进行排序</strong></li>
</ul>
<h2 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。<br><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [-1,0,3,5,9,12], target = 9</span></span><br><span class="line"><span class="section">输出: 4</span></span><br><span class="line"><span class="section">解释: 9 出现在 nums 中并且下标为 4</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [-1,0,3,5,9,12], target = 2</span></span><br><span class="line"><span class="section">输出: -1</span></span><br><span class="line"><span class="section">解释: 2 不存在 nums 中因此返回 -1</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h2 id="1-2-题解"><a href="#1-2-题解" class="headerlink" title="1.2 题解"></a>1.2 题解</h2><ul>
<li><p><strong>由于这个算法比较容易，毛毛张在这里不在这里详细介绍这个算法的思路，再下面介绍两种常见写法，这两种常见的写法是根据搜索区间的开闭情况来进行发分类：</strong></p>
<ul>
<li><p><strong>写法模板1：搜索区间为左闭右闭$[left,right]$</strong>   </p>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/algorithm/704-1.png" alt="704-1" style="zoom: 25%;" /></p>
</li>
<li><p><strong>写法模板2：搜索区间为左闭右开$[left,right)$</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/algorithm/704-2.png" alt="704-2" style="zoom:25%;" /></p>
</li>
</ul>
<h3 id="1-2-1-写法模板1"><a href="#1-2-1-写法模板1" class="headerlink" title="1.2.1 写法模板1"></a>1.2.1 写法模板1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 左边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始二分查找逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="comment">// 获取中间值，并进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-写法模板2"><a href="#1-2-2-写法模板2" class="headerlink" title="1.2.2 写法模板2"></a>1.2.2 写法模板2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 左边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始二分查找逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="comment">// 获取中间值，并进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-注意事项"><a href="#1-3-注意事项" class="headerlink" title="1.3 注意事项"></a>1.3 注意事项</h2><h3 id="1-3-1-写法转换细节"><a href="#1-3-1-写法转换细节" class="headerlink" title="1.3.1 写法转换细节"></a>1.3.1 写法转换细节</h3><ul>
<li><p><strong>两种写法模板大体相似，但是如果两种写法在进行转换的时候需要修改三处地方，这个一定要注意，漏了一处就会出错</strong></p>
</li>
<li><p><strong>修改地方1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写法模板<span class="number">1</span>：<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">写法模板<span class="number">2</span>：<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改地方2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写法模板<span class="number">1</span>：<span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">写法模板<span class="number">2</span>：<span class="keyword">while</span> (left &lt; right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改地方3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写法模板<span class="number">1</span>：right = mid - <span class="number">1</span>;</span><br><span class="line">写法模板<span class="number">2</span>：right = mid;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-2-取中点环节-left-right-2"><a href="#1-3-2-取中点环节-left-right-2" class="headerlink" title="1.3.2 取中点环节(left + right)/2"></a>1.3.2 取中点环节<code>(left + right)/2</code></h3><h4 id="1-left-right-2"><a href="#1-left-right-2" class="headerlink" title="1. (left + right) / 2"></a>1. <code>(left + right) / 2</code></h4><p>这个表达式直接将 <code>left</code> 和 <code>right</code> 相加，然后除以 2。主要的问题是，如果 <code>left</code> 和 <code>right</code> 的值很大，那么 <code>left + right</code> 的结果可能会超过 <code>int</code> 类型的最大值（即 <code>Integer.right_VALUE</code>），导致 <strong>整数溢出</strong>。在发生溢出时，计算结果会不正确。</p>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.right_VALUE - <span class="number">1</span>;  <span class="comment">// 2147483646</span></span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.right_VALUE;     <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;        <span class="comment">// 溢出，结果错误</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>left + right</code> 会溢出为负数，导致 <code>mid</code> 计算出错误的结果。</p>
<h4 id="2-left-right-left-2-推荐"><a href="#2-left-right-left-2-推荐" class="headerlink" title="2. left + (right - left) / 2 (推荐)"></a>2. <code>left + (right - left) / 2</code> (推荐)</h4><p>这个表达式通过先计算 <code>right - left</code> 的差值，再除以 2，并加上 <code>left</code>。这种方法避免了直接相加导致的溢出问题，因为 <code>right - left</code> 是一个相对较小的值，<code>left + (right - left) / 2</code> 不会溢出。</p>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.right_VALUE - <span class="number">1</span>; <span class="comment">// 2147483646</span></span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.right_VALUE;     <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 正确的结果，不会溢出</span></span><br></pre></td></tr></table></figure>
<h4 id="3-left-right-gt-gt-gt-1（推荐）"><a href="#3-left-right-gt-gt-gt-1（推荐）" class="headerlink" title="3.(left+ right)&gt;&gt;&gt;1（推荐）"></a>3.<code>(left+ right)&gt;&gt;&gt;1</code>（推荐）</h4><ul>
<li><p>将 <code>left + right</code> 的结果右移一位（相当于除以 2），使用无符号右移操作符 <code>&gt;&gt;&gt;</code> 来计算中间值。</p>
</li>
<li><p><strong>避免溢出</strong>: 虽然 <code>left + right</code> 可能溢出，但右移操作可以处理溢出的情况，得到正确的结果。</p>
</li>
<li><strong>效率高</strong>: 位运算通常比算术运算更快，因此这种方法在某些情况下性能更好。</li>
</ul>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.right_VALUE - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.right_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 结果为 2147483646，正确且不溢出</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-left与right"><a href="#1-3-3-left与right" class="headerlink" title="1.3.3 left与right"></a>1.3.3 <code>left</code>与<code>right</code></h3><h4 id="写法模板1"><a href="#写法模板1" class="headerlink" title="写法模板1"></a>写法模板1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 左边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始二分查找逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="comment">// 获取中间值，并进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在写法模板1中有如下结论：</strong><ul>
<li><strong>如果目标值在数组中：</strong> 正常返回索引<code>mid</code>，且此时的<code>left</code>与<code>right</code>不一定等于<code>mid</code>，没有什么关系</li>
<li><strong>如果目标值不在数组中：</strong> <ul>
<li><strong>结论1：退出循环时的条件为<code>left=right+1</code></strong></li>
<li><strong>结论2：此时的<code>left</code>表征的是按照升序排序要插入在数组中的索引的位置，即插入点的位置；另一种说法，此时<code>left</code>的索引上的元素大于目标值<code>target</code>（在题目开始说过了，数组中的元素按照严格升序进行排序，如果不是则不一定）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="写法模板2"><a href="#写法模板2" class="headerlink" title="写法模板2"></a>写法模板2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 左边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右边索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始二分查找逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="comment">// 获取中间值，并进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>注意事项2：这种写法，如果退出循环的条件写成<code>while(left &lt;= right)</code>，如果目标值不存在， 则会进入死循环</strong></p>
</li>
<li><p><strong>在写法模板2中有如下结论：</strong></p>
<ul>
<li><strong>如果目标值在数组中：</strong> 正常返回索引<code>mid</code>，且此时的<code>left</code>与<code>right</code>不一定等于<code>mid</code>，没有什么关系</li>
<li><strong>如果目标值不在数组中：</strong> <ul>
<li><strong>结论1：退出循环时的条件为<code>left=right</code></strong></li>
<li><strong>结论2：此时的<code>left</code>表征的是按照升序排序要插入在数组中的索引的位置，即插入点的位置；另一种说法，此时<code>left</code>的索引上的元素大于目标值<code>target</code>（在题目开始说过了，数组中的元素按照严格升序进行排序，如果不是则不一定）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>在Java底层类库源码中，正式利用了二分查找在找不到的元素的时候索引<code>left</code>的特征对代码进行了优化</strong></p>
</blockquote>
<h2 id="1-4-Java源码解读"><a href="#1-4-Java源码解读" class="headerlink" title="1.4 Java源码解读"></a>1.4 Java源码解读</h2><ul>
<li><p>二分查找算法已经被封装在<code>Arrays</code>类中，该类位于<code>java.util.Arrays</code>中，如果需要使用，可以直接导包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Arrays.binarySearchint[] a, <span class="type">int</span> froleftdex, <span class="type">int</span> toIndex, <span class="type">int</span> key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the sort(int[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Params:a – the array to be searched </span></span><br><span class="line"><span class="comment">	   froleftdex – the index of the first element (inclusive) to be searched </span></span><br><span class="line"><span class="comment">	   toIndex – the index of the last element (exclusive) to be searched </span></span><br><span class="line"><span class="comment">	   key – the value to be searched for</span></span><br><span class="line"><span class="comment">	   </span></span><br><span class="line"><span class="comment">Returns:index of the search key, if it is contained in the array within the specified range; otherwise, (-(insertion     point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or toIndex if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Throws:IllegalArgumentException – if froleftdex &gt; toIndex</span></span><br><span class="line"><span class="comment">       ArrayIndexOutOfBoundsException – if froleftdex &lt; 0 or toIndex &gt; a. length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> froleftdex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        rangeCheck(a.length, froleftdex, toIndex);</span><br><span class="line">        <span class="keyword">return</span> binarySearch0(a, froleftdex, toIndex, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> froleftdex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> froleftdex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>源码解读：</strong></p>
<ul>
<li>Java中的二分查找的源码为使用的是写法模板1的形势来进行查找的</li>
<li><strong>二分查找返回值：</strong><ul>
<li>如果能找到目标值，则返回的是目标值的索引</li>
<li>如果找不到，返回值的是要插入位置的索引加1的相反数，例如：要插入的索引是<code>5</code>，则返回<code>-6 = -(5+1)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2-进阶版二分查找细节"><a href="#2-进阶版二分查找细节" class="headerlink" title="2.进阶版二分查找细节"></a>2.进阶版二分查找细节</h1><ul>
<li>上面的基础班的二分查找中，数组中元素的顺序是按照严格升序排序的顺序，也就是说没用重复元素，而下面介绍的进阶版就是，数组中存在相同的元素。</li>
<li><strong>LeetCode链接：</strong><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
</ul>
<h2 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[5,7,7,8,8,8,10]</span>, target = 8</span><br><span class="line">输出：<span class="comment">[3,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[5,7,7,8,8,10]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[-1,-1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[]</span>, target = 0</span><br><span class="line">输出：<span class="comment">[-1,-1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$0 &lt;= nums.length &lt;= 10^5$</li>
<li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li>
<li><code>nums</code> 是一个非递减数组</li>
<li>$-10^9 &lt;= target &lt;= 10^9$</li>
</ul>
<h2 id="2-2-题解"><a href="#2-2-题解" class="headerlink" title="2.2 题解"></a>2.2 题解</h2><ul>
<li><p>基础版的二分查找，只能返回找到目标值时的索引，无法找到目标值存在多个时的开始索引和结束索引</p>
</li>
<li><p>下面毛毛张将来介绍一下如何改动基础的二分查找实现找到目标值的开始索引和结束索引，<strong>以写法模板1为例</strong></p>
</li>
<li>我们只需要新设置一个变量，用来表征返回索引的候选值即可，不断更新这个索引，<strong>先以找开始索引为例</strong></li>
</ul>
<h3 id="2-2-1-找开始索引"><a href="#2-2-1-找开始索引" class="headerlink" title="2.2.1 找开始索引"></a>2.2.1 找开始索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Leftmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            candidate = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于<code>target == nums[mid]</code>和<code>target &lt; nums[mid]</code>这两种情况下收缩区间的方式是一样的，因此我们可以优化一下代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Leftmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>索引<code>left</code>含义：在前面说过，这种情况下退出循环的条件是<code>left = right+1</code>，所以就没必要说<code>right</code>的含义了</strong><ul>
<li><strong>如果目标值存在，<code>left</code>就是目标值的最左边的索引，也就是开始索引。</strong></li>
<li><strong>如果目标值不存在，就是目标值要插入的位置的索引；另一种说法，<code>left</code>索引大于目标值的最靠左的元素的索引</strong></li>
<li>综上所述，上面代码中索引<code>left</code>的含义是：<strong>大于等于target的最靠左的元素的索引</strong></li>
</ul>
</li>
<li><strong>索引<code>right</code>：无论目标值是否存在，<code>right</code>表征的是小于目标值最靠右的元素的索引</strong></li>
</ul>
<h3 id="2-2-2-找结束索引"><a href="#2-2-2-找结束索引" class="headerlink" title="2.2.2 找结束索引"></a>2.2.2 找结束索引</h3><ul>
<li><strong>现在来说找结束索引</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rightmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">            candidate = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于<code>target == nums[mid]</code>和<code>target &gt; nums[mid]</code>这两种情况下收缩区间的方式是一样的，因此我们可以优化一下代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rightmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target == nums[left - <span class="number">1</span>] ? left - <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>索引<code>left-1=right</code>含义：在前面说过，这种情况下退出循环的条件是<code>left = right+1</code>，所以就没必要说<code>right</code>的含义了</strong><ul>
<li><strong>如果目标值存在，<code>left-1</code>就是目标值的元素最左边的索引，也就是开始索引</strong></li>
<li><strong><code>left-1</code>索引表征的是小于目标值的最靠右的元素的索引</strong></li>
<li>综上所述，上面代码中索引<code>left-1</code>的含义是：<strong>小于等于target的最靠右的元素的索引</strong></li>
</ul>
</li>
</ul>
<h3 id="2-2-3-题解"><a href="#2-2-3-题解" class="headerlink" title="2.2.3 题解"></a>2.2.3 题解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        result[<span class="number">0</span>] = Leftmost(nums, target);</span><br><span class="line">        result[<span class="number">1</span>] = Rightmost(nums, target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找目标值的最左边界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">Leftmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 left 进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找目标值的最右边界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">Rightmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 right 进行判断</span></span><br><span class="line">        <span class="keyword">if</span> ((left -<span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; nums[(left -<span class="number">1</span>)] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> (left -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-再探进阶版二分查找细节"><a href="#3-再探进阶版二分查找细节" class="headerlink" title="3.再探进阶版二分查找细节"></a>3.再探进阶版二分查找细节</h1><ul>
<li><p><strong>在进阶版二分查找细节中，毛毛张使用的是写法模板1，但是写法模板2的的含义是否是一样的呢？</strong></p>
<ul>
<li>毛毛张在这里告诉你肯定的答案：<strong>用写法模板2，索引<code>left</code>和<code>left-1</code>的含义和写法模板1中的对应的返回值的含义是一摸一样的</strong></li>
</ul>
</li>
<li><p>在上面一题中二分查找的写法是适配题目的，在返回的时候增加了一些判断，下面毛毛张介绍一下纯净版的进阶二分查找代码模板</p>
</li>
</ul>
<h2 id="3-1-纯净版进阶二分查找写法"><a href="#3-1-纯净版进阶二分查找写法" class="headerlink" title="3.1 纯净版进阶二分查找写法"></a>3.1 纯净版进阶二分查找写法</h2><h3 id="3-1-1-写法模板1"><a href="#3-1-1-写法模板1" class="headerlink" title="3.1.1 写法模板1"></a>3.1.1 写法模板1</h3><h4 id="1-找开始索引"><a href="#1-找开始索引" class="headerlink" title="1.找开始索引"></a>1.找开始索引</h4><ul>
<li><p><strong>结论1：返回值<code>left</code>为大于等于目标值的最靠左的元素的索引</strong>（此时<code>left = right + 1</code>）</p>
<ul>
<li>如果目标值存在，返回值<code>left</code>就是等于目标值的最靠左的索引</li>
<li>如果目标值不存在，返回值<code>left</code>就是大于目标值的最靠左的元素的索引</li>
</ul>
</li>
<li><p><strong>结论2：</strong> <code>right</code>无论目标值是否存在，都表征的是小于目标值最靠右的元素的索引<strong>（不要硬记，记住第一个结论，会推出这个结论）</strong></p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Leftmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-找结束索引"><a href="#2-找结束索引" class="headerlink" title="2.找结束索引"></a>2.找结束索引</h4><ul>
<li><p><strong>结论1：返回值<code>left-1=right</code>为小于等于目标值的最靠右的元素的索引</strong></p>
<ul>
<li>如果目标值存在，返回值<code>left-1</code>就是等于目标值的最靠右的索引</li>
<li>如果目标值不存在，返回值<code>left-1</code>就是小于目标值的最靠右的元素的索引</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Rightmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-1-2-写法模板2"><a href="#3-1-2-写法模板2" class="headerlink" title="3.1.2 写法模板2"></a>3.1.2 写法模板2</h3><ul>
<li><strong>如果用写法模板2来写进阶版二分查找，返回值的结论一模一样</strong></li>
</ul>
<h4 id="1-找开始索引-1"><a href="#1-找开始索引-1" class="headerlink" title="1.找开始索引"></a>1.找开始索引</h4><ul>
<li><p>结论1：返回值<code>left</code>为大于等于目标值的最靠左的元素的索引（此时<code>left = right</code>）</p>
<ul>
<li>如果目标值存在，返回值<code>left</code>就是等于目标值的最靠左的索引</li>
<li>如果目标值不存在，返回值<code>left</code>就是大于目标值的最靠左的元素的索引</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Leftmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-找结束索引-1"><a href="#2-找结束索引-1" class="headerlink" title="2.找结束索引"></a>2.找结束索引</h4><ul>
<li><p>结论1：返回值<code>left-1</code>为小于等于目标值的最靠右的元素的索引（此时<code>left = right</code>）</p>
<ul>
<li>如果目标值存在，返回值<code>left-1</code>就是等于目标值的最靠右的索引</li>
<li>如果目标值不存在，返回值<code>left-1</code>就是小于目标值的最靠右的元素的索引</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Rightmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-2-应用"><a href="#3-2-应用" class="headerlink" title="3.2 应用"></a>3.2 应用</h2><ul>
<li>我们把找开始开始索引的函数用<code>Leftmost</code>函数表示，找结束索引的函数用法<code>Rightmost</code>函数表示，根据上面我们可以得到如下结论：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/algorithm/image-20240811193844596.png" alt="image-20240811193844596"></p>
<ul>
<li>上面两个函数的应用，我们可以结合下面这个图来理解：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/algorithm/image-20240811194455802.png" alt="image-20240811194455802"></p>
<ul>
<li><p>作用1：求排名，求在非递减顺序排列的整数数组，目标元素在数组中的排名</p>
<ul>
<li>举例：目标值是5，排名计算公式：<code>Leftmost(5)+1 = 5 + 1</code>（数组中索引是0从开始的，排名是从1开始的）</li>
</ul>
</li>
<li><p>作用2：求前任的索引</p>
<ul>
<li>举例：目标值是5，求5的前任，计算公式：<code>Leftmost(5) - 1</code> (求索引是从0开始的)</li>
</ul>
</li>
<li><p>作用3：求后任的索引</p>
<ul>
<li>举例：目标值时5，求5的后任，计算公式：<code>Rightmost(5) + 1</code></li>
</ul>
</li>
<li><p>作用4：求区间</p>
<ul>
<li>举例1：小于4的区间索引区间表示：<code>[0,Leftmost(4) - 1]</code></li>
<li>举例2：小于等于4的区间索引区间表示：<code>[0,Leftmost(4)]</code></li>
<li>举例3：大于4的区间索引区间表示：<code>[Rightmost(4)+1,无穷大]</code></li>
<li>举例4：大于等于4的区间索引区间表示：<code>[Leftmost(4),无穷大]</code></li>
<li>举例5：大于等于4，小于等于7的区间索引：<code>[Leftmost(4),Rightmost(7)]</code></li>
<li>举例6：大于4，小于7的区间索引：<code>[Rightmost(4)+1,Leftmost(7)-1]</code></li>
</ul>
</li>
</ul>
<h2 id="3-3-优化"><a href="#3-3-优化" class="headerlink" title="3.3 优化"></a>3.3 优化</h2><ul>
<li>上面的找开始索引和结束索引的地方存在大量的代码相似的地方，只在<code>target &lt; num[mid]</code>和<code>target &lt;= num[mid]</code>存在区别，于是我们可以增设一个标志位来对代码进行优化，使得代码更加简洁</li>
</ul>
<h3 id="3-3-1-写法模板1优化"><a href="#3-3-1-写法模板1优化" class="headerlink" title="3.3.1 写法模板1优化"></a>3.3.1 写法模板1优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binaySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid] || (flag &amp;&amp; target &lt;= nums[mid])) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="literal">true</span> ? left : left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-写法模板2优化"><a href="#3-3-2-写法模板2优化" class="headerlink" title="3.3.2 写法模板2优化"></a>3.3.2 写法模板2优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binaySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid] || (flag &amp;&amp; target &lt;= nums[mid])) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="literal">true</span> ? left : left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-练习题"><a href="#4-练习题" class="headerlink" title="4.练习题"></a>4.练习题</h1><ul>
<li><a href=""></a></li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/79553968">https://zhuanlan.zhihu.com/p/79553968</a></li>
<li><a href="https://blog.csdn.net/Sunnyside_/article/details/114700193">https://blog.csdn.net/Sunnyside_/article/details/114700193</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>加油站 | LeetCode-134 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/gas-station/">134. 加油站<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从<span class="number"> 3 </span>号加油站(索引为<span class="number"> 3 </span>处)出发，可获得<span class="number"> 4 </span>升汽油。此时油箱有 =<span class="number"> 0 </span>+<span class="number"> 4 </span>=<span class="number"> 4 </span>升汽油</span><br><span class="line">开往<span class="number"> 4 </span>号加油站，此时油箱有<span class="number"> 4 </span>-<span class="number"> 1 </span>+<span class="number"> 5 </span>=<span class="number"> 8 </span>升汽油</span><br><span class="line">开往<span class="number"> 0 </span>号加油站，此时油箱有<span class="number"> 8 </span>-<span class="number"> 2 </span>+<span class="number"> 1 </span>=<span class="number"> 7 </span>升汽油</span><br><span class="line">开往<span class="number"> 1 </span>号加油站，此时油箱有<span class="number"> 7 </span>-<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 6 </span>升汽油</span><br><span class="line">开往<span class="number"> 2 </span>号加油站，此时油箱有<span class="number"> 6 </span>-<span class="number"> 4 </span>+<span class="number"> 3 </span>=<span class="number"> 5 </span>升汽油</span><br><span class="line">开往<span class="number"> 3 </span>号加油站，你需要消耗<span class="number"> 5 </span>升汽油，正好足够你返回到<span class="number"> 3 </span>号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从<span class="number"> 0 </span>号或<span class="number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从<span class="number"> 2 </span>号加油站出发，可以获得<span class="number"> 4 </span>升汽油。 此时油箱有 =<span class="number"> 0 </span>+<span class="number"> 4 </span>=<span class="number"> 4 </span>升汽油</span><br><span class="line">开往<span class="number"> 0 </span>号加油站，此时油箱有<span class="number"> 4 </span>-<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 3 </span>升汽油</span><br><span class="line">开往<span class="number"> 1 </span>号加油站，此时油箱有<span class="number"> 3 </span>-<span class="number"> 3 </span>+<span class="number"> 3 </span>=<span class="number"> 3 </span>升汽油</span><br><span class="line">你无法返回<span class="number"> 2 </span>号加油站，因为返程需要消耗<span class="number"> 4 </span>升汽油，但是你的油箱只有<span class="number"> 3 </span>升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li>$1 &lt;= n &lt;= 10^5$</li>
<li>$0 &lt;= gas[i], cost[i] &lt;= 10^4$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历每个加油站作为起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前加油站加油后剩余的油量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">remainGas</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            <span class="comment">// 下一个加油站的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (i + <span class="number">1</span>) % cost.length;</span><br><span class="line">            <span class="comment">// 尝试从当前加油站出发，直到回到起点或油量不足</span></span><br><span class="line">            <span class="keyword">while</span> (remainGas &gt; <span class="number">0</span> &amp;&amp; index != i) &#123;</span><br><span class="line">                <span class="comment">// 更新剩余油量</span></span><br><span class="line">                remainGas += gas[index] - cost[index];</span><br><span class="line">                <span class="comment">// 移动到下一个加油站</span></span><br><span class="line">                index = (index + <span class="number">1</span>) % cost.length; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果能够回到起点，返回起点索引</span></span><br><span class="line">            <span class="keyword">if</span> (remainGas &gt;= <span class="number">0</span> &amp;&amp; index == i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有合适的起点，返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-贪心算法-写法1"><a href="#2-2-贪心算法-写法1" class="headerlink" title="2.2 贪心算法-写法1"></a>2.2 贪心算法-写法1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 总油量与总消耗的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 当前油量与消耗的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录潜在的起点</span></span><br><span class="line">        <span class="comment">// 遍历每个加油站</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新当前差值和总差值</span></span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前差值小于0，重置起点为下一个加油站</span></span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">// 下一个加油站可能为新的起点</span></span><br><span class="line">                curSum = <span class="number">0</span>; <span class="comment">// 重置当前差值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果总差值小于0，说明无法完成一圈，返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> start;<span class="comment">// 返回能够完成一圈的起点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-贪心算法-写法2"><a href="#2-3-贪心算法-写法2" class="headerlink" title="2.3 贪心算法-写法2"></a>2.3 贪心算法-写法2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">// 剩余油量的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">restSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录最低剩余油量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个加油站，计算剩余油量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            restSum += rest; <span class="comment">// 更新总剩余油量</span></span><br><span class="line">            <span class="comment">// 更新最低剩余油量</span></span><br><span class="line">            <span class="keyword">if</span> (restSum &lt; min) &#123;</span><br><span class="line">                min = restSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果总剩余油量小于0，无法完成一圈，返回 -1（情况1）</span></span><br><span class="line">        <span class="keyword">if</span> (restSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果最低剩余油量非负，说明可以从第一个加油站出发，返回 0（情况2）</span></span><br><span class="line">        <span class="keyword">if</span> (min &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况3：从后往前遍历，寻找能够完成一圈的起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cost.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            min += rest; <span class="comment">// 更新最低剩余油量</span></span><br><span class="line">            <span class="comment">// 如果当前最低剩余油量非负，返回当前索引</span></span><br><span class="line">            <span class="keyword">if</span> (min &gt;= <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到合适的起点，返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-贪心算法-写法3"><a href="#2-4-贪心算法-写法3" class="headerlink" title="2.4 贪心算法-写法3"></a>2.4 贪心算法-写法3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">restSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 剩余油量的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">// 记录最低剩余油量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录潜在的起点</span></span><br><span class="line">        <span class="comment">// 遍历每个加油站，计算剩余油量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            restSum += rest; <span class="comment">// 更新总剩余油量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最低剩余油量和起点</span></span><br><span class="line">            <span class="keyword">if</span> (restSum &lt; min) &#123;</span><br><span class="line">                min = restSum;</span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">// 下一个加油站可能为新的起点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果总剩余油量小于0，无法完成一圈，返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> (restSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果最低剩余油量非负，返回潜在的起点</span></span><br><span class="line">        <span class="keyword">return</span> start % cost.length; <span class="comment">// 确保起点在有效范围内</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分发糖果 | LeetCode-135 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/candy/">135. 分发糖果<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：ratings </span>=<span class="string"> [1,0,2]</span></span><br><span class="line"><span class="string">输出：5</span></span><br><span class="line"><span class="string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：ratings </span>=<span class="string"> [1,2,2]</span></span><br><span class="line"><span class="string">输出：4</span></span><br><span class="line"><span class="string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span></span><br><span class="line"><span class="string">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>n == ratings.length</code></p>
</li>
<li><p>$1 &lt;= n &lt;= 2 * 10^4$</p>
<p>$0 &lt;= ratings[i] &lt;= 2 * 10^4$</p>
</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-两次遍历"><a href="#2-1-两次遍历" class="headerlink" title="2.1 两次遍历"></a>2.1 两次遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">// 用于记录从左向右分配的糖果数</span></span><br><span class="line">        <span class="comment">// 从左到右遍历，根据评分分配糖果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) </span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;<span class="comment">// 如果当前评分大于前一个，当前糖果数比前一个多1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[i] = <span class="number">1</span>; <span class="comment">// 否则，至少分配1个糖果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右向左遍历时所需的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从右到左遍历，根据评分分配糖果并累加结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果当前评分大于下一个，右侧糖果数增加1</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>]) </span><br><span class="line">                right++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = <span class="number">1</span>; <span class="comment">// 否则，至少分配1个糖果</span></span><br><span class="line">            <span class="comment">// 取左侧和右侧的较大值，并累加到结果中</span></span><br><span class="line">            result += Math.max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回最少的糖果总数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-双指针-常数空间遍历"><a href="#2-2-双指针-常数空间遍历" class="headerlink" title="2.2 双指针-常数空间遍历"></a>2.2 双指针-常数空间遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="comment">// 结果变量初始化为1，因为至少需要分配1个糖果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录连续递增、递减的糖果数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左到右遍历每个孩子的评分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt;= ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 当前评分大于或等于前一个评分，递增序列</span></span><br><span class="line">                dec = <span class="number">0</span>; <span class="comment">// 重置递减序列计数</span></span><br><span class="line">                <span class="comment">// 如果评分相等，分配1个糖果，否则增加1个</span></span><br><span class="line">                pre = ratings[i] == ratings[i - <span class="number">1</span>] ? <span class="number">1</span> : pre + <span class="number">1</span>;</span><br><span class="line">                result += pre; <span class="comment">// 将当前糖果数加入总数</span></span><br><span class="line">                inc = pre; <span class="comment">// 更新递增序列的糖果数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前评分小于前一个评分，递减序列</span></span><br><span class="line">                dec++; <span class="comment">// 增加递减计数</span></span><br><span class="line">                <span class="keyword">if</span> (dec == inc) &#123;</span><br><span class="line">                    <span class="comment">// 如果递减长度达到递增的长度，需要多加一个糖果</span></span><br><span class="line">                    dec++;</span><br><span class="line">                &#125;</span><br><span class="line">                result += dec; <span class="comment">// 将当前糖果数加入总数</span></span><br><span class="line">                pre = <span class="number">1</span>; <span class="comment">// 递减序列时重置当前糖果数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回最少糖果总数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>摆动序列 | LeetCode-376 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="string">-3</span>, 5, <span class="string">-7</span>, 3) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="string">-7</span>, 3, <span class="string">-3</span>, 6, <span class="string">-8</span>) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,2,3,4</span>,<span class="number">5,6,7,8</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果数组为空或长度为 0，则直接返回数组长度</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录摆动子序列的长度，初始值为 1（至少包含第一个元素）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前元素与前一个元素的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前一个差值，初始化为 0 表示还未开始摆动</span></span><br><span class="line">        <span class="comment">// 遍历数组，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前元素与前一个元素的差值</span></span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前差值与前一个差值符号相反，则形成摆动</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++; <span class="comment">// 摆动子序列的长度加 1</span></span><br><span class="line">                preDiff = curDiff; <span class="comment">// 更新前一个差值为当前差值</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回摆动子序列的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h2>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>根据身高重建队伍 | LeetCode-406 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E4%BC%8D/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：people = <span class="comment">[<span class="comment">[7,0]</span>,<span class="comment">[4,4]</span>,<span class="comment">[7,1]</span>,<span class="comment">[5,0]</span>,<span class="comment">[6,1]</span>,<span class="comment">[5,2]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[5,0]</span>,<span class="comment">[7,0]</span>,<span class="comment">[5,2]</span>,<span class="comment">[6,1]</span>,<span class="comment">[4,4]</span>,<span class="comment">[7,1]</span>]</span></span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 <span class="comment">[<span class="comment">[5,0]</span>,<span class="comment">[7,0]</span>,<span class="comment">[5,2]</span>,<span class="comment">[6,1]</span>,<span class="comment">[4,4]</span>,<span class="comment">[7,1]</span>]</span> 是重新构造后的队列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong> </p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：people = <span class="comment">[<span class="comment">[6,0]</span>,<span class="comment">[5,0]</span>,<span class="comment">[4,0]</span>,<span class="comment">[3,2]</span>,<span class="comment">[2,2]</span>,<span class="comment">[1,4]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[4,0]</span>,<span class="comment">[5,0]</span>,<span class="comment">[2,2]</span>,<span class="comment">[3,2]</span>,<span class="comment">[1,4]</span>,<span class="comment">[6,0]</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= people.length &lt;= 2000</code></li>
<li>$0 &lt;= hi &lt;= 10^6$</li>
<li><code>0 &lt;= ki &lt; people.length</code></li>
<li>题目数据确保队列可以被重建</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">// 首先，对输入的数组people进行排序</span></span><br><span class="line">        <span class="comment">// 排序规则：</span></span><br><span class="line">        <span class="comment">// 1. 按照身高（people[i][0]）从大到小排序（即身高高的人排在前面）</span></span><br><span class="line">        <span class="comment">// 2. 如果身高相同，则按照k值（people[i][1]）从小到大排序</span></span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果身高相同，按照k值升序排序</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 身高不同，按照身高降序排序</span></span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个链表，用于按照规则重新构建队列</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历排序后的数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] person : people)&#123;</span><br><span class="line">            <span class="comment">// 将每个人插入到链表的指定位置</span></span><br><span class="line">            <span class="comment">// person[1]表示这个人前面应该有的身高≥他的人数</span></span><br><span class="line">            <span class="comment">// 我们在队列中的第person[1]个位置插入当前的人</span></span><br><span class="line">            queue.add(person[<span class="number">1</span>], person);</span><br><span class="line">            <span class="comment">// 由于已经按身高降序排序，所以插入时可以保证前面的人身高≥当前的人</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将链表转换为二维数组并返回</span></span><br><span class="line">        <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分发饼干 | LeetCode- | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干<a/></b></p>
<h2 id="lt-center-gt"><a href="#lt-center-gt" class="headerlink" title="&lt;/center&gt;"></a>&lt;/center&gt;</h2><h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: g = [1,2,3], s = [1,1]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: </span></span><br><span class="line">你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。</span><br><span class="line">所以你应该输出 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: g = [1,2], s = [1,2,3]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br><span class="line"><span class="section">解释: </span></span><br><span class="line">你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出 2。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= g.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li>
</ul>
<p><strong>注意：</strong>本题与 <a href="https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/">2410. 运动员和训练师的最大匹配数</a> 题相同。</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心-写法1"><a href="#2-1-贪心-写法1" class="headerlink" title="2.1 贪心-写法1"></a>2.1 贪心-写法1</h2><ol>
<li><strong>排序</strong>: 首先对孩子的胃口和饼干的大小进行排序，以便从最大的开始分配。</li>
<li><strong>双指针方法</strong>: 使用两个指针，一个指向孩子的胃口数组，另一个指向饼干数组。</li>
<li><strong>贪心算法</strong>: 尝试使用最大的饼干去满足胃口最大的孩子，如果能够满足，就将孩子的数量加一，并移动到下一个饼干。</li>
<li><strong>返回结果</strong>: 最后返回可以满足的孩子数量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);<span class="comment">// 对孩子的胃口数组进行排序</span></span><br><span class="line">        Arrays.sort(s);<span class="comment">// 对饼干的大小数组进行排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录可以满足的孩子的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length - <span class="number">1</span>; <span class="comment">// 指向饼干数组的最后一个元素</span></span><br><span class="line">        <span class="comment">// 从胃口数组的最后一个元素开始遍历（从大到小）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果当前饼干能够满足当前孩子的胃口</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] &gt;= g[i]) &#123;</span><br><span class="line">                j--; <span class="comment">// 使用这个饼干，移动到下一个饼干</span></span><br><span class="line">                count++; <span class="comment">// 满足的孩子数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;<span class="comment">// 返回满足的孩子的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-贪心-写法2"><a href="#2-2-贪心-写法2" class="headerlink" title="2.2 贪心-写法2"></a>2.2 贪心-写法2</h2><ol>
<li><strong>排序</strong>: 首先对孩子的胃口数组 (<code>g</code>) 和饼干的大小数组 (<code>s</code>) 进行排序，以便从小到大进行比较。</li>
<li><strong>双指针方法</strong>: 使用两个指针，<code>i</code> 指向饼干数组，<code>j</code> 指向孩子的胃口数组。</li>
<li><strong>贪心算法:</strong>  遍历饼干数组，检查当前饼干是否能够满足当前孩子的胃口：<ul>
<li>如果可以满足，移动到下一个孩子并增加满足的孩子数量。</li>
</ul>
</li>
<li><strong>返回结果</strong>: 最后返回可以满足的孩子数量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g); <span class="comment">// 对孩子的胃口数组进行排序</span></span><br><span class="line">        Arrays.sort(s); <span class="comment">// 对饼干的大小数组进行排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录可以满足的孩子的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指向孩子胃口数组的索引</span></span><br><span class="line">        <span class="comment">// 遍历饼干数组，直到遍历完所有饼干或所有孩子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length &amp;&amp; j &lt; g.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前饼干的大小能够满足当前孩子的胃口</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= g[j]) &#123;</span><br><span class="line">                j++; <span class="comment">// 移动到下一个孩子</span></span><br><span class="line">                count++; <span class="comment">// 满足的孩子数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count; <span class="comment">// 返回满足的孩子的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子数组和 | LeetCode-53 | 贪心算法 | 动态规划</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,<span class="string">-1</span>,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：nums <span class="operator">=</span> [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[5,4,-1,7,8]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前连续子数组的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 用于记录最大的子数组和，初始化为最小整数值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i]; <span class="comment">// 将当前元素加入到当前子数组的和中</span></span><br><span class="line">            result = Math.max(result, sum); <span class="comment">// 更新最大子数组和</span></span><br><span class="line">            sum = Math.max(sum, <span class="number">0</span>); <span class="comment">// 如果当前子数组和为负数，则将其重置为 0，开始新的子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回最大子数组和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">// dp[i] 表示从第 0 到第 i 个元素范围内的最大子数组和</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 初始化 dp[0] 为第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>]; <span class="comment">// 记录最大子数组和，初始化为第一个元素的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移：比较包含当前元素的子数组和与当前元素的值，取较大者</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="comment">// 更新最大子数组和</span></span><br><span class="line">            result = Math.max(dp[i], result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回最大子数组和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-分治法"><a href="#2-3-分治法" class="headerlink" title="2.3 分治法"></a>2.3 分治法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getMaxSubSum(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxSubSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxSum</span> <span class="operator">=</span> getMaxSubSum(nums, left, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxSum</span> <span class="operator">=</span> getMaxSubSum(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">crossingMaxSum</span> <span class="operator">=</span> getCrossingMaxSum(nums, mid, left, right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftMaxSum, rightMaxSum), crossingMaxSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getCrossingMaxSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> mid, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxSum</span> <span class="operator">=</span> nums[mid];</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSum</span> <span class="operator">=</span> nums[mid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">            tempSum += nums[i];</span><br><span class="line">            leftMaxSum = Math.max(leftMaxSum, tempSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxSum</span> <span class="operator">=</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">        tempSum = nums[mid + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid + <span class="number">2</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            tempSum += nums[i];</span><br><span class="line">            rightMaxSum = Math.max(rightMaxSum, tempSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftMaxSum + rightMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏 | LeetCode-55 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<h1 id="题目1：55-跳跃游戏"><a href="#题目1：55-跳跃游戏" class="headerlink" title="题目1：55. 跳跃游戏"></a>题目1：<a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳<span class="number"> 1 </span>步，从下标<span class="number"> 0 </span>到达下标 1, 然后再从下标<span class="number"> 1 </span>跳<span class="number"> 3 </span>步到达最后一个下标。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为<span class="number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="number"> 0 </span>， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li>$0 &lt;= nums[i] &lt;= 10^5$</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前可以到达的最远位置</span></span><br><span class="line">        <span class="comment">// 遍历数组，直到当前索引超过 cover</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新可以到达的最远位置</span></span><br><span class="line">            cover = Math.max(i + nums[i], cover);</span><br><span class="line">            <span class="comment">// 如果可以到达或超过最后一个位置，直接返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完后仍然无法到达最后位置，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="题目2：45-跳跃游戏-II"><a href="#题目2：45-跳跃游戏-II" class="headerlink" title="题目2：45. 跳跃游戏 II"></a>题目2：<a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为<span class="number"> 0 </span>跳到下标为<span class="number"> 1 </span>的位置，跳<span class="number"> 1 </span>步，然后跳<span class="number"> 3 </span>步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>题目保证可以到达 <code>nums[n-1]</code></li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-贪心算法-写法1"><a href="#2-1-贪心算法-写法1" class="headerlink" title="2.1 贪心算法-写法1"></a>2.1 贪心算法-写法1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度为 1，已经在最后一个位置，无需跳跃，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前跳跃覆盖的最远距离下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextDistance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 下一跳能覆盖的最远距离下标</span></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新下一跳能覆盖的最远距离</span></span><br><span class="line">            nextDistance = Math.max(i + nums[i], nextDistance);</span><br><span class="line">            <span class="comment">// 如果遍历到当前跳跃覆盖的最远距离</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;</span><br><span class="line">                count++; <span class="comment">// 增加跳跃次数</span></span><br><span class="line">                curDistance = nextDistance; <span class="comment">// 更新当前跳跃覆盖的最远距离</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果下一跳覆盖的最远距离已经达到或超过最后一个位置，直接跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (nextDistance &gt;= nums.length - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count; <span class="comment">// 返回跳跃次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-贪心算法-写法2"><a href="#2-2-贪心算法-写法2" class="headerlink" title="2.2 贪心算法-写法2"></a>2.2 贪心算法-写法2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解题类：用于计算从数组的起点跳跃到终点所需的最少跳跃次数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化跳跃次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前跳跃范围的最远距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 下一跳的最大范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组（不包括最后一个元素，因为跳跃到最后一个元素即结束）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新下一跳的最远距离</span></span><br><span class="line">            nextDistance = Math.max(i + nums[i], nextDistance);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当到达当前跳跃的最远距离时，需要进行跳跃</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;</span><br><span class="line">                result++;               <span class="comment">// 增加跳跃次数</span></span><br><span class="line">                curDistance = nextDistance;  <span class="comment">// 更新当前跳跃的最远距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最少跳跃次数</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单调递增的数字 | LeetCode-738 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: n = 10</span></span><br><span class="line"><span class="section">输出: 9</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: n = 1234</span></span><br><span class="line"><span class="section">输出: 1234</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: n = 332</span></span><br><span class="line"><span class="section">输出: 299</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>$0 &lt;= n &lt;= 10^9$</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h2><ul>
<li>思路：<ul>
<li>将输入整数 <code>n</code> 转换为字符串形式，并转换为字符数组，便于逐个字符操作。</li>
<li>从数组的右侧开始遍历，检查是否存在前一位数字大于后一位数字的情况，如果存在，将前一位数字减 1 并记录从哪里开始需要将数字置为 <code>9</code>。</li>
<li>在从 <code>start</code> 标记位置开始，将所有后续数字替换为 <code>9</code> 以保证结果是单调递增的。</li>
<li>最后将修改后的字符数组转换回整数并返回。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 将输入数字转换为字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组，方便操作每个数字</span></span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 初始化 start 变量，标记从哪个位置开始需要将字符置为 &#x27;9&#x27;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> chs.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从字符数组的倒数第二位开始遍历，向前检查</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chs.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个字符比当前字符大</span></span><br><span class="line">            <span class="keyword">if</span>(chs[i - <span class="number">1</span>] &gt; chs[i]) &#123;</span><br><span class="line">                <span class="comment">// 将前一个字符减 1</span></span><br><span class="line">                chs[i - <span class="number">1</span>]--;</span><br><span class="line">                <span class="comment">// 更新 start，标记需要置为 &#x27;9&#x27; 的起始位置</span></span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 start 位置及其之后的所有字符置为 &#x27;9&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; chs.length; i++) &#123;</span><br><span class="line">            chs[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(chs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>柠檬水找零 | LeetCode-860 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前<span class="number"> 3 </span>位顾客那里，我们按顺序收取<span class="number"> 3 </span>张<span class="number"> 5 </span>美元的钞票。</span><br><span class="line">第<span class="number"> 4 </span>位顾客那里，我们收取一张<span class="number"> 10 </span>美元的钞票，并返还<span class="number"> 5 </span>美元。</span><br><span class="line">第<span class="number"> 5 </span>位顾客那里，我们找还一张<span class="number"> 10 </span>美元的钞票和一张<span class="number"> 5 </span>美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前<span class="number"> 2 </span>位顾客那里，我们按顺序收取<span class="number"> 2 </span>张<span class="number"> 5 </span>美元的钞票。</span><br><span class="line">对于接下来的<span class="number"> 2 </span>位顾客，我们收取一张<span class="number"> 10 </span>美元的钞票，然后返还<span class="number"> 5 </span>美元。</span><br><span class="line">对于最后一位顾客，我们无法退回<span class="number"> 15 </span>美元，因为我们现在只有两张<span class="number"> 10 </span>美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= bills.length &lt;= 10^5$</li>
<li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code> </li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法（双指针）"><a href="#2-1-贪心算法（双指针）" class="headerlink" title="2.1 贪心算法（双指针）"></a>2.1 贪心算法（双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> bills.length;</span><br><span class="line">        <span class="comment">// 记录面值5和10的钞票数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fiveCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tenCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一笔交易</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 顾客支付5美元，不需要找零，直接增加5美元的数量</span></span><br><span class="line">                fiveCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 顾客支付10美元，需要找零5美元</span></span><br><span class="line">                tenCount++;</span><br><span class="line">                fiveCount--; <span class="comment">// 找零5美元</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">// 顾客支付20美元，优先找零10美元+5美元</span></span><br><span class="line">                <span class="keyword">if</span> (tenCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tenCount--; <span class="comment">// 使用一张10美元</span></span><br><span class="line">                    fiveCount--; <span class="comment">// 使用一张5美元</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有10美元时，找零3张5美元</span></span><br><span class="line">                    fiveCount -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查是否可以找零，若不足返回false</span></span><br><span class="line">            <span class="keyword">if</span> (fiveCount &lt; <span class="number">0</span> || tenCount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功处理所有交易，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>监控二叉树 | LeetCode-968 | 贪心算法</title>
    <url>/2024/10/27/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>贪心练习题</p>
</blockquote>
<span id="more"></span>
<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">null</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="img"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">null</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">null</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="literal">null</span><span class="punctuation">,</span><span class="literal">null</span><span class="punctuation">,</span><span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>
<li>每个节点的值都是 0。</li>
</ol>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-贪心算法"><a href="#2-1-贪心算法" class="headerlink" title="2.1 贪心算法"></a>2.1 贪心算法</h2><ul>
<li>思路：<ul>
<li><code>count</code> 变量用于统计所需的摄像头总数。</li>
<li>方法<code>traversal</code>用递归方式检查每个节点的状态：<ul>
<li>若节点为空，返回 <code>2</code>（视为已覆盖）。</li>
<li>左右子节点检查的结果用于决定当前节点的状态。</li>
</ul>
</li>
<li>三种主要情况：<ul>
<li>若左右子节点都已覆盖，则当前节点未覆盖，需要返回 <code>0</code>。</li>
<li>若左右子节点有任一未覆盖，则在当前节点放置摄像头，返回 <code>1</code> 并增加计数。</li>
<li>若左右子节点至少有一个有摄像头，则当前节点已覆盖，返回 <code>2</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 定义方法 minCameraCover，接收一个树的根节点 root，返回所需的最小摄像头数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化摄像头计数为 0</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果根节点未覆盖（返回 0），需要额外添加一个摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (traversal(root) == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="comment">// 返回总摄像头数量</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个辅助方法 traversal，接收当前节点 cur，返回节点状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">traversal</span><span class="params">(TreeNode cur)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，视为已覆盖状态</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> traversal(cur.left);<span class="comment">// 遍历左子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> traversal(cur.right);<span class="comment">// 遍历右子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前节点状态</span></span><br><span class="line">        <span class="comment">// 0：该节点未被覆盖</span></span><br><span class="line">        <span class="comment">// 1：当前节点有摄像头</span></span><br><span class="line">        <span class="comment">// 2：当前节点已被覆盖</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况1：如果左右子节点均为已覆盖状态（返回 2），则当前节点未被覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 情况2：如果左右子节点中有一个未被覆盖（返回 0），则当前节点需要安装摄像头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;  <span class="comment">// 安装摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 当前节点有摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况3：如果左右子节点中至少有一个节点有摄像头（返回 1），则当前节点已被覆盖</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 不应出现的情况，返回 -1（用于处理未知状态）</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>区间问题 | LeetCode-56</title>
    <url>/2024/09/15/algorithm/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LeetCode-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center><b>分类不好，这道题就做不出来！</b></center>





<h1 id="题目1：452-用最少数量的箭引爆气球"><a href="#题目1：452-用最少数量的箭引爆气球" class="headerlink" title="题目1：452. 用最少数量的箭引爆气球"></a>题目1：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：points = <span class="comment">[<span class="comment">[10,16]</span>,<span class="comment">[2,8]</span>,<span class="comment">[1,6]</span>,<span class="comment">[7,12]</span>]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球<span class="comment">[2,8]</span>和<span class="comment">[1,6]</span>。</span><br><span class="line">-在x = 11处发射箭，击破气球<span class="comment">[10,16]</span>和<span class="comment">[7,12]</span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：points = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[3,4]</span>,<span class="comment">[5,6]</span>,<span class="comment">[7,8]</span>]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：points = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[2,3]</span>,<span class="comment">[3,4]</span>,<span class="comment">[4,5]</span>]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处发射箭，击破气球<span class="comment">[1,2]</span>和<span class="comment">[2,3]</span>。</span><br><span class="line">- 在x = 4处射出箭，击破气球<span class="comment">[3,4]</span>和<span class="comment">[4,5]</span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>$1 &lt;= points.length &lt;= 10^5$</li>
<li><code>points[i].length == 2</code></li>
<li>$-2^{31} &lt;= x<em>{start} &lt; x</em>{end} &lt;= 2^{31} - 1$</li>
</ul>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决方案类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据气球直径的开始坐标从小到大排序</span></span><br><span class="line">        <span class="comment">// 使用Integer内置的比较方法，以避免整数溢出问题</span></span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化箭的数量为1，因为至少需要一支箭</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历气球数组，从第二个气球开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 检查当前气球的起始坐标是否大于上一个气球的结束坐标</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 当前气球不重叠，需要新的箭</span></span><br><span class="line">                result++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前气球与上一个气球重叠，更新当前气球的结束坐标为两者中较小的值</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i][<span class="number">1</span>], points[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最少的箭数量</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目2：435-无重叠区间"><a href="#题目2：435-无重叠区间" class="headerlink" title="题目2：435. 无重叠区间"></a>题目2：<a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>
<p><strong>注意</strong> 只在一点上接触的区间是 <strong>不重叠的</strong>。例如 <code>[1, 2]</code> 和 <code>[2, 3]</code> 是不重叠的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: intervals = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[2,3]</span>,<span class="comment">[3,4]</span>,<span class="comment">[1,3]</span>]</span></span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 <span class="comment">[1,3]</span> 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: intervals = <span class="comment">[ <span class="comment">[1,2]</span>, <span class="comment">[1,2]</span>, <span class="comment">[1,2]</span> ]</span></span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 <span class="comment">[1,2]</span> 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: intervals = <span class="comment">[ <span class="comment">[1,2]</span>, <span class="comment">[2,3]</span> ]</span></span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>$1 &lt;= intervals.length &lt;= 10^5$</li>
<li><code>intervals[i].length == 2</code></li>
<li>$-5 <em> 10^4 &lt;= start_i &lt; end_i &lt;= 5 </em> 10^4$</li>
</ul>
<h2 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h2><h3 id="2-1-贪心算法-写法1"><a href="#2-1-贪心算法-写法1" class="headerlink" title="2.1 贪心算法-写法1"></a>2.1 贪心算法-写法1</h3><ul>
<li><code>count</code>记录非交叉区间的个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">// 将区间数组按每个区间的起始位置进行排序</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]; <span class="comment">// 比较两个区间的起始位置，按升序排列</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 计数器初始化为1，用于统计不重叠的区间数量</span></span><br><span class="line">        <span class="comment">// 遍历区间数组，从第二个区间开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前区间与前一个区间不重叠</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i-<span class="number">1</span>][<span class="number">1</span>] &lt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">// 增加计数器</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前区间与前一个区间重叠，更新当前区间的右边界为两者右边界的较小值</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;<span class="comment">// 返回需要移除的重叠区间数量，即总区间数减去不重叠区间的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-贪心算法-写法2"><a href="#2-2-贪心算法-写法2" class="headerlink" title="2.2 贪心算法-写法2"></a>2.2 贪心算法-写法2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">// 将区间数组按每个区间的起始位置进行排序</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 比较两个区间的起始位置，按升序排列</span></span><br><span class="line">            <span class="keyword">return</span> Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录需要移除的重叠区间数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remove</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化前一个区间的右边界为第一个区间的右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preR</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历区间数组，从第二个区间开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前区间的起始位置不小于前一个区间的右边界（无重叠）</span></span><br><span class="line">            <span class="keyword">if</span> (preR &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 更新前一个区间的右边界为当前区间的右边界</span></span><br><span class="line">                preR = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前区间与前一个区间重叠，增加需要移除的区间计数</span></span><br><span class="line">                remove++;</span><br><span class="line">                <span class="comment">// 更新前一个区间的右边界为两者右边界的较小值，以减少后续重叠</span></span><br><span class="line">                preR = Math.min(preR, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回需要移除的重叠区间数量</span></span><br><span class="line">        <span class="keyword">return</span> remove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目3：763-划分字母区间"><a href="#题目3：763-划分字母区间" class="headerlink" title="题目3：763. 划分字母区间"></a>题目3：<a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h1><h2 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>、<span class="string">&quot;defegde&quot;</span>、<span class="string">&quot;hijhklij&quot;</span> 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;eccbbbbdec&quot;</span></span><br><span class="line">输出：[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h2><ul>
<li>思路：<ul>
<li>统计每一个字符最后出现的位置</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个方法 partitionLabels，接收一个字符串 s，返回一个整数列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度为26的数组 edge，用于存储每个字符最后出现的位置</span></span><br><span class="line">        <span class="type">int</span>[] edge = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 遍历字符串，记录每个字符的最右边界索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) edge[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        <span class="comment">// 创建一个结果列表，用于存储每个分区的长度</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化两个指针，left 表示分区的起始位置，right 表示当前分区的结束位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 更新当前分区的最右边界</span></span><br><span class="line">            right = Math.max(right, edge[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前位置 i 等于当前分区的最右边界</span></span><br><span class="line">            <span class="keyword">if</span>(right == i) &#123;</span><br><span class="line">                <span class="comment">// 将当前分区的长度添加到结果列表中</span></span><br><span class="line">                result.add(right - left + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 更新左边界为下一个分区的起始位置</span></span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目4：56-合并区间"><a href="#题目4：56-合并区间" class="headerlink" title="题目4：56. 合并区间"></a>题目4：<a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h1><h2 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,4],[4,5]]</span></span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= intervals.length &lt;= 10^4$</li>
<li><code>intervals[i].length == 2</code></li>
<li>$0 &lt;= start_i &lt;= end_i &lt;= 10^4$</li>
</ul>
<h2 id="2-题解-3"><a href="#2-题解-3" class="headerlink" title="2.题解"></a>2.题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 如果区间数组为空，直接返回空数组</span></span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将区间数组按每个区间的起始位置进行排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] intervals1, <span class="type">int</span>[] intervals2)</span> &#123;</span><br><span class="line">                <span class="comment">// 按照区间的起始值升序排列</span></span><br><span class="line">                <span class="keyword">return</span> intervals1[<span class="number">0</span>] - intervals2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来保存合并后的区间</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前区间的左边界 L 和右边界 R</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 result 为空，或者 result 中最后一个区间的右边界小于当前区间的左边界</span></span><br><span class="line">            <span class="comment">// 说明当前区间与前一个区间没有重叠，直接添加当前区间</span></span><br><span class="line">            <span class="keyword">if</span>(result.size() == <span class="number">0</span> || result.get(result.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，说明当前区间和前一个区间有重叠</span></span><br><span class="line">                <span class="comment">// 将最后一个区间的右边界更新为两个区间中较大的右边界，合并区间</span></span><br><span class="line">                result.get(result.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(result.get(result.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果列表转换为二维数组形式并返回</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树前序遍历、中序遍历、后序遍历和层序遍历 | 递归法 | 迭代法 | 统一迭代法 | 深度优先搜索 | 广度优先搜索</title>
    <url>/2024/07/28/algorithm/leetcode/%E6%A0%91/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%931-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>今天毛毛张要分享的内容是LeetCode的刷题笔记，主要介绍的二叉树前序遍历、中序遍历、后序遍历和层序遍历思想和多种代码实现，二叉树的遍历对于二叉树后面的题目的实现具有很重要的意义</strong></p>
</blockquote>
<span id="more"></span>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><ul>
<li><p>LeetCode题目链接：</p>
<ul>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145.二叉树的后序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></li>
</ul>
</li>
<li><p>二叉树的遍历方式有多种，毛毛张今天在这里结合<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">代码随想录</a>的教程来分享一下二叉树的多种遍历方式及代码实现</p>
</li>
<li>二叉树主要有两种遍历方式：<strong>深度优先遍历和广度优先遍历</strong></li>
<li><p><strong>深度优先遍历：</strong> 树是图的一种特例(连通无环的图就是树)，主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li><p><strong>广度优先遍历：</strong>一层一层的去遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点</p>
<ul>
<li>层次遍历（递归法，迭代法）</li>
</ul>
</li>
<li><p>在深度优先遍历中：有三个顺序，前中后序遍历。<strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式：</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
</li>
<li><p>大家可以对着如下图，看看自己理解的前后中序有没有问题：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/leetcode/image-20240509083740511-1716081374132-1.png" alt="image-20240509083740511"></p>
</li>
<li><p><strong>在做二叉树的相关题目的时候，在使用深度优先遍历的时候一般会使用递归方法来实现</strong></p>
</li>
<li><strong>而栈其实就是一种递归的一种实现结构，前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的，由此衍生出一种迭代法</strong></li>
<li><strong>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</strong></li>
<li>下面开始逐一介绍各种方法的代码实现，虽然方法名被概括为精炼的几个字，但是在具体的代码实现的时候，可能根据书写习惯的不同又会分成不同的实现方法，所以毛毛张在这里介绍几种常见的书写方法。</li>
</ul>
<h1 id="2-深度优先遍历：递归实现"><a href="#2-深度优先遍历：递归实现" class="headerlink" title="2.深度优先遍历：递归实现"></a>2.深度优先遍历：递归实现</h1><blockquote>
<p>深度优先遍历的递归实现比较简单，毛毛张在这里不做过多的赘述，只介绍一下代码随想录中的递归方法论，记住这个方法论有助于在解题的过程中不会漏掉特殊情况或者某一步骤。</p>
</blockquote>
<ul>
<li><strong>递归的方法论：</strong><ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
</li>
</ul>
<h2 id="2-1-前序遍历（递归法）"><a href="#2-1-前序遍历（递归法）" class="headerlink" title="2.1 前序遍历（递归法）"></a>2.1 前序遍历（递归法）</h2><h3 id="方法1：新建递归函数"><a href="#方法1：新建递归函数" class="headerlink" title="方法1：新建递归函数"></a>方法1：新建递归函数</h3><blockquote>
<p><strong>实现思路：</strong> 在力扣的模板中会默认给你提供一个前序遍历的函数体，该方法在书写的时候没有使用默认的函数体作为递归函数，因为这个函数已经给你规定好了递归函数的形参和返回值，不利于理解，毛毛张在这里是单独新建一个递归函数供其调用，这种方式更加容易理解。</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建List用来存放返回值</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始前序遍历</span></span><br><span class="line">        preOrder(root,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的实现方式</span></span><br><span class="line">    <span class="comment">//方法论：</span></span><br><span class="line">    <span class="comment">//1.首先确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node,List list)</span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preOrder(node.left,list);</span><br><span class="line">        preOrder(node.right,list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：使用默认递归函数"><a href="#方法2：使用默认递归函数" class="headerlink" title="方法2：使用默认递归函数"></a>方法2：使用默认递归函数</h3><blockquote>
<p>为了完整性，毛毛张当然也要在这里给出使用提供的默认函数作为递归函数的代码啦！</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归的实现方式</span></span><br><span class="line">    <span class="comment">//方法论：</span></span><br><span class="line">    <span class="comment">//1.首先确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="comment">//这里直接使用题目帮你确定的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List用来存放返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = preorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt;  rightList = preorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>错解：</strong></p>
<blockquote>
<p>方法2这里直接使用题目帮你确定的形参和返回值</p>
<p>同时在确定终止条件的时候需要注意要返回一个空列表，不要写成<code>return  null</code></p>
<p>大家可用在leetcode中实战对比一下下面这写法</p>
</blockquote>
<p><strong>错解代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归的实现方式</span></span><br><span class="line">    <span class="comment">//方法论：</span></span><br><span class="line">    <span class="comment">//1.首先确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="comment">//这里直接使用题目帮你确定的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List用来存放返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = preorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt;  rightList = preorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-2-中序遍历（递归法）"><a href="#2-2-中序遍历（递归法）" class="headerlink" title="2.2 中序遍历（递归法）"></a>2.2 中序遍历（递归法）</h2><h3 id="方法1：新建递归函数-1"><a href="#方法1：新建递归函数-1" class="headerlink" title="方法1：新建递归函数"></a>方法1：新建递归函数</h3><blockquote>
<p><strong>实现思路：</strong> 在立扣的模板中会默认给你提供一个中序遍历的函数体，该方法在书写的时候没有使用默认的函数体作为递归函数，因为这个函数已经给你规定好了递归函数的形参和返回值，不利于理解，毛毛张在这里是单独新建一个递归函数供其调用，这种方式更加容易理解。</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建列表存储返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始中序遍历</span></span><br><span class="line">        inOrder(root,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法论：</span></span><br><span class="line">    <span class="comment">//1.确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        inOrder(node.left,list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inOrder(node.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：使用默认递归函数m"><a href="#方法2：使用默认递归函数m" class="headerlink" title="方法2：使用默认递归函数m"></a>方法2：使用默认递归函数m</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归方法论</span></span><br><span class="line">    <span class="comment">//1.直接使用题目帮你确定好的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//创建返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = inorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt; rightList = inorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-后序遍历（递归法）"><a href="#2-3-后序遍历（递归法）" class="headerlink" title="2.3 后序遍历（递归法）"></a>2.3 后序遍历（递归法）</h2><h3 id="方法1：新建递归函数-2"><a href="#方法1：新建递归函数-2" class="headerlink" title="方法1：新建递归函数"></a>方法1：新建递归函数</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建列表存储返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始后序遍历</span></span><br><span class="line">        postOrder(root,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法论：</span></span><br><span class="line">    <span class="comment">//1.确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        postOrder(node.left,list);</span><br><span class="line">        postOrder(node.right,list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：使用默认递归函数-1"><a href="#方法2：使用默认递归函数-1" class="headerlink" title="方法2：使用默认递归函数"></a>方法2：使用默认递归函数</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="comment">//方法论</span></span><br><span class="line">    <span class="comment">//1.这里直接使用题目帮你确定好的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建列表存储返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = postorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt; rightList = postorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-深度优先遍历：迭代法"><a href="#3-深度优先遍历：迭代法" class="headerlink" title="3.深度优先遍历：迭代法"></a>3.深度优先遍历：迭代法</h1><ul>
<li><p>迭代法的实现需要借助栈，下面首先介绍以下三种遍历的迭代法的算法原理，在分析原理的时候，均以下图为例：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/leetcode/image-20240518163915793-1716081533984-4.png" alt="image-20240518163915793"></p>
</li>
</ul>
<h2 id="3-1-原理分析"><a href="#3-1-原理分析" class="headerlink" title="3.1 原理分析"></a>3.1 原理分析</h2><h3 id="3-1-1-前序遍历与中序遍历"><a href="#3-1-1-前序遍历与中序遍历" class="headerlink" title="3.1.1 前序遍历与中序遍历"></a>3.1.1 前序遍历与中序遍历</h3><ul>
<li><p><strong>前序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面，但是前序遍历的逻辑不是很好叙述，大家可以看完中序遍历的逻辑，在结合中序遍历和前序遍历的代码来体会前序遍历的这句话</strong></p>
</li>
<li><p><strong>分析：</strong>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了和前序遍历的处理顺序和访问顺序是不一致的</p>
</li>
<li><p>中序遍历的访问过程：</p>
<ul>
<li><p>第1步：沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点，此时栈内元素依次为ABD；</p>
</li>
<li><p>第2步：栈顶元素出栈并访问：若其右孩子为空，继续执行第2步；若其右孩子不空，将右子树转执行第1步。</p>
</li>
</ul>
</li>
<li>整个过程：<ul>
<li>栈顶D出栈并访问，它是中序序列的第一个结点，</li>
<li>D右孩子为空，栈顶B出栈并访问；（第2步）</li>
<li>B右孩子不空，将其右孩子E入栈；（第1步）</li>
<li>E左孩子为空，栈顶E出栈并访问；（第2步）</li>
<li>E右孩子为空，栈顶A出栈并访问；（第2步）</li>
<li>A右孩子不空，将其右孩子C入栈；（第1步）</li>
<li>C左孩子为空，栈顶C出栈并访问；（第2步）</li>
<li>由此得到中序遍历结果：DBEAC</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-后序遍历"><a href="#3-1-2-后序遍历" class="headerlink" title="3.1.2 后序遍历"></a>3.1.2 后序遍历</h3><ul>
<li>后序遍历的非递归实现是三种遍历方法中最难的，因为在后序遍历中，要保证左孩了和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。</li>
<li><p><strong>算法思想：后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点</strong></p>
<ul>
<li><strong>第1步：沿着根的左孩子，依次入栈，直到左孩子为空，此时栈内元素依次为ABD</strong></li>
<li><strong>第2步：读栈顶元素，若其右孩子不空且未被访问过，将右子树转执行第1步；否则，栈顶元素出栈并访问</strong></li>
</ul>
</li>
<li><p><strong>代码实现细节：在上述思想的第2步中，必须分清返回时是从左子树返回的还是从右子树返回的，因此设定一个辅助指针r，指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问</strong></p>
</li>
<li><p><strong>实例过程分析：</strong></p>
<ul>
<li>栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；</li>
<li>栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；</li>
<li>栈顶B的右孩子不空但已被访问，B出栈并访问；</li>
<li>栈项A的右孩子不空且未被访问过，C入栈，栈项C的左右孩子均为空，出栈并访问；</li>
<li>栈顶A的右孩子不空但已被访问，A出栈并访问，由此得到后序序列DEBCA</li>
</ul>
</li>
<li><p><strong>我们再来分析后序遍历的第二种实现方式：要实现前面的这个逻辑还是比较复杂的，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转结果数组，输出的结果顺序就是左右中了</strong></p>
<ul>
<li>图解：</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/leetcode/image-20240518161314423.png" alt="image-20240518161314423"></p>
<h2 id="3-2-前序遍历（迭代法）"><a href="#3-2-前序遍历（迭代法）" class="headerlink" title="3.2 前序遍历（迭代法）"></a>3.2 前序遍历（迭代法）</h2><ul>
<li><strong>分析：</strong>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子<ul>
<li>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</li>
</ul>
</li>
</ul>
<h3 id="方法1：单层循环"><a href="#方法1：单层循环" class="headerlink" title="方法1：单层循环"></a>方法1：单层循环</h3><blockquote>
<p>单层循环和双层循环有细微的差别，大家可以自己看代码，根据自己的习惯来写</p>
</blockquote>
<p><strong>实现１：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();       </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="comment">//如果左孩子不为空，会一直执行if语句体</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//每次访问左孩子的同时就是在访问中间结点</span></span><br><span class="line">                <span class="comment">//前序遍历需要把中间结果进行输出</span></span><br><span class="line">                <span class="comment">//因此每次判断把中间结果进行保存</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">                <span class="comment">//就需要访问当前结点的右孩子的左孩子</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现２：</strong></p>
<blockquote>
<p>只有前序遍历能这样实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代法 借助栈</span></span><br><span class="line">        <span class="comment">//创建对返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建栈存放中间节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span>  stack.pop();</span><br><span class="line">            <span class="comment">//根节点入栈</span></span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="comment">//右节点先入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：双层循环"><a href="#方法2：双层循环" class="headerlink" title="方法2：双层循环"></a>方法2：双层循环</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问中间结点</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">            <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-中序遍历（迭代法）"><a href="#3-3-中序遍历（迭代法）" class="headerlink" title="3.3 中序遍历（迭代法）"></a>3.3 中序遍历（迭代法）</h2><blockquote>
<p>单层循环和双层循环有细微的差别，大家可以自己看代码，根据自己的习惯来写</p>
</blockquote>
<h3 id="方法1：单层循环-1"><a href="#方法1：单层循环-1" class="headerlink" title="方法1：单层循环"></a>方法1：单层循环</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">                <span class="comment">//访问中间结点</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：双层循环-1"><a href="#方法2：双层循环-1" class="headerlink" title="方法2：双层循环"></a>方法2：双层循环</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">            <span class="comment">//访问中间结点</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-后序遍历（迭代法）"><a href="#3-4-后序遍历（迭代法）" class="headerlink" title="3.4 后序遍历（迭代法）"></a>3.4 后序遍历（迭代法）</h2><blockquote>
<p>单层循环和双层循环有细微的差别，大家可以自己看代码，根据自己的习惯来写</p>
</blockquote>
<h3 id="方法1：单层循环-2"><a href="#方法1：单层循环-2" class="headerlink" title="方法1：单层循环"></a>方法1：单层循环</h3><blockquote>
<p>这个代码是使用列表反转这个技巧的代码</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直到左孩子为空，说明已找到可以输出的结点</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                <span class="comment">//判断右孩子</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：双层循环（反转）"><a href="#方法2：双层循环（反转）" class="headerlink" title="方法2：双层循环（反转）"></a>方法2：双层循环（反转）</h3><blockquote>
<p>这个代码是使用列表反转这个技巧的代码</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问中间结点</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">            <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法3：双层循环（不反转）"><a href="#方法3：双层循环（不反转）" class="headerlink" title="方法3：双层循环（不反转）"></a>方法3：双层循环（不反转）</h3><blockquote>
<p>这个代码是后序遍历真实的逻辑代码，没有使用反转这个技巧</p>
</blockquote>
<p><strong>code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//非递归算法</span></span><br><span class="line">    <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取当前处理的节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">   	<span class="comment">//表示上一个处理的节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//3开始进行迭代</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="comment">//再来访问右节点，如果右节点没有，就访问并弹出栈顶元素，此时访问的就是中间节点</span></span><br><span class="line">        <span class="comment">//如果有右节点，先判断右节点是否访问过，如果访问过直接弹出</span></span><br><span class="line">        <span class="keyword">if</span>(cur.right == <span class="literal">null</span> || cur.right == prev) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ret.add(cur.val);</span><br><span class="line">            prev = cur; <span class="comment">// 最近一次访问的节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-深度优先遍历：统一迭代法"><a href="#4-深度优先遍历：统一迭代法" class="headerlink" title="4.深度优先遍历：统一迭代法"></a>4.深度优先遍历：统一迭代法</h1><ul>
<li><p><strong>利用栈的后入先出特性，按照逆序添加到栈中，然后出栈。同时用一个变量来标记某个节点是否被访问过。栈中的元素是元组，即（节点是否被访问过，节点）</strong></p>
<ul>
<li>具体来说，当栈不为空时，循环处理最后一个元素：</li>
<li><p>如果节点为空，则跳过。</p>
</li>
<li><p>如果某个节点没被访问过，则左子节点、右子节点、自己这三个点按照遍历的<strong>逆序入栈</strong>，并且自己标记为访问过，其他两个子节点标记未访问。</p>
</li>
<li><p>如果某个节点被访问过，则记录它的值。</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-1-前序遍历"><a href="#4-1-前序遍历" class="headerlink" title="4.1 前序遍历"></a>4.1 前序遍历</h2><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//统一迭代法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.根节点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判断栈顶元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为了保证中间结点在左右子树之前先出栈，弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                <span class="comment">//中</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//并同时给要处理的结点之前添加一个标识</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在处理之前弹出栈顶的null</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//获取处理的结点</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                <span class="comment">//添加中间结点</span></span><br><span class="line">                list.add(node.val);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-中序遍历"><a href="#4-2-中序遍历" class="headerlink" title="4.2 中序遍历"></a>4.2 中序遍历</h2><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//统一迭代法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.根节点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判断栈顶元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为了保证中间结点在左子树之前先出栈，弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                <span class="comment">//中</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//并同时给要处理的结点之前添加一个标识</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.left);              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在处理之前天弹出栈顶的null</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//获取处理的结点</span></span><br><span class="line">                node = stack.pop();      </span><br><span class="line">                <span class="comment">//添加中间结点</span></span><br><span class="line">                list.add(node.val);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-后序遍历"><a href="#4-3-后序遍历" class="headerlink" title="4.3 后序遍历"></a>4.3 后序遍历</h2><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//统一迭代法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.根节点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判断栈顶元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为了保证中间结点在左子树之前先出栈，弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//中</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//并同时给要处理的结点之前添加一个标识</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.right);              </span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.left);              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在处理之前天弹出栈顶的null</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//获取处理的结点</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                <span class="comment">//添加中间结点</span></span><br><span class="line">                list.add(node.val);              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-广度优先遍历"><a href="#5-广度优先遍历" class="headerlink" title="5.广度优先遍历"></a>5.广度优先遍历</h1><ul>
<li>二叉树的广度优先遍历也叫做层序遍历。</li>
<li>层序遍历一个二叉树，就是从左到右一层一层的去遍历二叉树。</li>
<li>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></li>
</ul>
<h2 id="5-1-自顶向下的层序遍历"><a href="#5-1-自顶向下的层序遍历" class="headerlink" title="5.1 自顶向下的层序遍历"></a>5.1 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">自顶向下的层序遍历</a></h2><h3 id="方法1：递归法"><a href="#方法1：递归法" class="headerlink" title="方法1：递归法"></a>方法1：递归法</h3><blockquote>
<p>该方法使用的是递归</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="comment">//1.创建存放结果的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//2.开始递归</span></span><br><span class="line">        <span class="comment">//递归方法论：</span></span><br><span class="line">        <span class="comment">//明确方法形参和返回值</span></span><br><span class="line">        levelOrderTraverse(root,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraverse</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//确定单层递归逻辑</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span>(result.size() &lt; depth)&#123;</span><br><span class="line">            <span class="comment">//当层增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(depth - <span class="number">1</span>).add(node.val);</span><br><span class="line">        levelOrderTraverse(node.left,depth);</span><br><span class="line">        levelOrderTraverse(node.right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：迭代法"><a href="#方法2：迭代法" class="headerlink" title="方法2：迭代法"></a>方法2：迭代法</h3><blockquote>
<p>该方法使用的迭代法，需要借助队列来实现</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代方法</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//借助队列实现</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//创建每一层的列表</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">//获取每一层的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= currentLevelSize; ++i)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将每一层列表添加到结果中</span></span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-自底向上的层序遍历"><a href="#5-2-自底向上的层序遍历" class="headerlink" title="5.2 自底向上的层序遍历"></a>5.2 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">自底向上的层序遍历</a></h2><h3 id="方法1：递归法-1"><a href="#方法1：递归法-1" class="headerlink" title="方法1：递归法"></a>方法1：递归法</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="comment">//1.创建存放结果的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//2.开始递归</span></span><br><span class="line">        <span class="comment">//递归方法论：</span></span><br><span class="line">        <span class="comment">//明确方法形参和返回值</span></span><br><span class="line">        levelOrderTraverse(root,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraverse</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//确定单层递归逻辑</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span>(result.size() &lt; depth)&#123;</span><br><span class="line">            <span class="comment">//当层增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(depth - <span class="number">1</span>).add(node.val);</span><br><span class="line">        levelOrderTraverse(node.left,depth);</span><br><span class="line">        levelOrderTraverse(node.right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：迭代法-1"><a href="#方法2：迭代法-1" class="headerlink" title="方法2：迭代法"></a>方法2：迭代法</h3><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代方法</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//借助队列实现</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//创建每一层的列表</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">//获取每一层的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; currentLevelSize;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将每一层列表添加到结果中</span></span><br><span class="line">            ret.add(level);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果不反转就充分利用add函数的性质</span></span><br><span class="line">            <span class="comment">//头插法</span></span><br><span class="line">            <span class="comment">//ret.add(0, level);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-和层序遍历相关的十一道题目"><a href="#5-3-和层序遍历相关的十一道题目" class="headerlink" title="5.3 和层序遍历相关的十一道题目"></a>5.3 和层序遍历相关的十一道题目</h2><ul>
<li><p>大家做完层序遍历，可以使用层序遍历的方式去做下面的这十一个题目，都与层序bian’li</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117.填充每个节点的下一个右侧节点指针II(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值</a></p>
</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/692543960">https://zhuanlan.zhihu.com/p/692543960</a></p>
<p><a href="https://www.51cto.com/article/614590.html">https://www.51cto.com/article/614590.html</a></p>
<p><a href="https://blog.csdn.net/weixin_44027397/article/details/113735310?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86java&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-113735310.142^v100^control&amp;spm=1018.2226.3001.4187">2</a></p>
<p><a href="https://blog.csdn.net/qq_64257622/article/details/131112998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171517933116800222816298%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171517933116800222816298&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131112998-null-null.142^v100^control&amp;utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86java&amp;spm=1018.2226.3001.4187">3</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>迭代法</tag>
        <tag>递归法</tag>
        <tag>广度优先遍历</tag>
        <tag>深度优先遍历</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树前序遍历、中序遍历、后序遍历和层序遍历 | 递归法 | 迭代法 | 统一迭代法 | 深度优先搜索 | 广度优先搜索</title>
    <url>/2024/07/28/algorithm/leetcode/%E6%A0%91/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<blockquote>
<p><strong>今天毛毛张要分享的内容是LeetCode的刷题笔记，主要介绍的二叉树前序遍历、中序遍历、后序遍历和层序遍历思想和多种代码实现，二叉树的遍历对于二叉树后面的题目的实现具有很重要的意义</strong></p>
</blockquote>
<span id="more"></span>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><ul>
<li><p>LeetCode题目链接：</p>
<ul>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145.二叉树的后序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li>
<li>Problem: <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></li>
</ul>
</li>
<li><p>二叉树的遍历方式有多种，毛毛张今天在这里结合<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">代码随想录</a>的教程来分享一下二叉树的多种遍历方式及代码实现</p>
</li>
<li>二叉树主要有两种遍历方式：<strong>深度优先遍历和广度优先遍历</strong></li>
<li><strong>深度优先遍历：</strong> 树是图的一种特例(连通无环的图就是树)，主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走<ul>
<li>前序遍历（递归法，迭代法）<ul>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>广度优先遍历：</strong>一层一层的去遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点</p>
<ul>
<li>层次遍历（递归法，迭代法）</li>
</ul>
</li>
<li><p>在深度优先遍历中：有三个顺序，前中后序遍历。<strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式：</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
</li>
<li><p>大家可以对着如下图，看看自己理解的前后中序有没有问题：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/leetcode/image-20240509083740511-1716081374132-1.png" alt="image-20240509083740511"></p>
</li>
<li><p><strong>在做二叉树的相关题目的时候，在使用深度优先遍历的时候一般会使用递归方法来实现</strong></p>
</li>
<li><strong>而栈其实就是一种递归的一种实现结构，前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的，由此衍生出一种迭代法</strong></li>
<li><strong>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</strong></li>
<li>下面开始逐一介绍各种方法的代码实现，虽然方法名被概括为精炼的几个字，但是在具体的代码实现的时候，可能根据书写习惯的不同又会分成不同的实现方法，所以毛毛张在这里介绍几种常见的书写方法。</li>
</ul>
<h1 id="2-深度优先遍历：递归实现"><a href="#2-深度优先遍历：递归实现" class="headerlink" title="2.深度优先遍历：递归实现"></a>2.深度优先遍历：递归实现</h1><blockquote>
<p>深度优先遍历的递归实现比较简单，毛毛张在这里不做过多的赘述，只介绍一下代码随想录中的递归方法论，记住这个方法论有助于在解题的过程中不会漏掉特殊情况或者某一步骤。</p>
</blockquote>
<ul>
<li><strong>递归的方法论：</strong><ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
</li>
</ul>
<h2 id="2-1-前序遍历（递归法）"><a href="#2-1-前序遍历（递归法）" class="headerlink" title="2.1 前序遍历（递归法）"></a>2.1 前序遍历（递归法）</h2><h4 id="方法1：新建递归函数"><a href="#方法1：新建递归函数" class="headerlink" title="方法1：新建递归函数"></a>方法1：新建递归函数</h4><blockquote>
<p><strong>实现思路：</strong> 在力扣的模板中会默认给你提供一个前序遍历的函数体，该方法在书写的时候没有使用默认的函数体作为递归函数，因为这个函数已经给你规定好了递归函数的形参和返回值，不利于理解，毛毛张在这里是单独新建一个递归函数供其调用，这种方式更加容易理解。</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建List用来存放返回值</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始前序遍历</span></span><br><span class="line">        preOrder(root,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的实现方式</span></span><br><span class="line">    <span class="comment">//方法论：</span></span><br><span class="line">    <span class="comment">//1.首先确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node,List list)</span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preOrder(node.left,list);</span><br><span class="line">        preOrder(node.right,list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：使用默认递归函数"><a href="#方法2：使用默认递归函数" class="headerlink" title="方法2：使用默认递归函数"></a>方法2：使用默认递归函数</h4><blockquote>
<p>为了完整性，毛毛张当然也要在这里给出使用提供的默认函数作为递归函数的代码啦！</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归的实现方式</span></span><br><span class="line">    <span class="comment">//方法论：</span></span><br><span class="line">    <span class="comment">//1.首先确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="comment">//这里直接使用题目帮你确定的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List用来存放返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = preorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt;  rightList = preorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>错解：</strong></p>
<blockquote>
<p>方法2这里直接使用题目帮你确定的形参和返回值</p>
<p>同时在确定终止条件的时候需要注意要返回一个空列表，不要写成<code>return  null</code></p>
<p>大家可用在leetcode中实战对比一下下面这写法</p>
</blockquote>
<p><strong>错解代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归的实现方式</span></span><br><span class="line">    <span class="comment">//方法论：</span></span><br><span class="line">    <span class="comment">//1.首先确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="comment">//这里直接使用题目帮你确定的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List用来存放返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = preorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt;  rightList = preorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-2-中序遍历（递归法）"><a href="#2-2-中序遍历（递归法）" class="headerlink" title="2.2 中序遍历（递归法）"></a>2.2 中序遍历（递归法）</h2><h4 id="方法1：新建递归函数-1"><a href="#方法1：新建递归函数-1" class="headerlink" title="方法1：新建递归函数"></a>方法1：新建递归函数</h4><blockquote>
<p><strong>实现思路：</strong> 在立扣的模板中会默认给你提供一个中序遍历的函数体，该方法在书写的时候没有使用默认的函数体作为递归函数，因为这个函数已经给你规定好了递归函数的形参和返回值，不利于理解，毛毛张在这里是单独新建一个递归函数供其调用，这种方式更加容易理解。</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建列表存储返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始中序遍历</span></span><br><span class="line">        inOrder(root,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法论：</span></span><br><span class="line">    <span class="comment">//1.确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        inOrder(node.left,list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inOrder(node.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：使用默认递归函数-1"><a href="#方法2：使用默认递归函数-1" class="headerlink" title="方法2：使用默认递归函数"></a>方法2：使用默认递归函数</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归方法论</span></span><br><span class="line">    <span class="comment">//1.直接使用题目帮你确定好的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//创建返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = inorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt; rightList = inorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-后序遍历（递归法）"><a href="#2-3-后序遍历（递归法）" class="headerlink" title="2.3 后序遍历（递归法）"></a>2.3 后序遍历（递归法）</h2><h4 id="方法1：新建递归函数-2"><a href="#方法1：新建递归函数-2" class="headerlink" title="方法1：新建递归函数"></a>方法1：新建递归函数</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建列表存储返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始后序遍历</span></span><br><span class="line">        postOrder(root,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法论：</span></span><br><span class="line">    <span class="comment">//1.确定递归函数的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        postOrder(node.left,list);</span><br><span class="line">        postOrder(node.right,list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：使用默认递归函数-2"><a href="#方法2：使用默认递归函数-2" class="headerlink" title="方法2：使用默认递归函数"></a>方法2：使用默认递归函数</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="comment">//方法论</span></span><br><span class="line">    <span class="comment">//1.这里直接使用题目帮你确定好的形参和返回值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建列表存储返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.确定单层递归逻辑</span></span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        List&lt;Integer&gt; leftList = postorderTraversal(root.left);</span><br><span class="line">        list.addAll(leftList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        List&lt;Integer&gt; rightList = postorderTraversal(root.right);</span><br><span class="line">        list.addAll(rightList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-深度优先遍历：迭代法"><a href="#3-深度优先遍历：迭代法" class="headerlink" title="3.深度优先遍历：迭代法"></a>3.深度优先遍历：迭代法</h1><ul>
<li><p>迭代法的实现需要借助栈，下面首先介绍以下三种遍历的迭代法的算法原理，在分析原理的时候，均以下图为例：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/leetcode/image-20240518163915793-1716081533984-4.png" alt="image-20240518163915793"></p>
</li>
</ul>
<h2 id="3-1-原理分析"><a href="#3-1-原理分析" class="headerlink" title="3.1 原理分析"></a>3.1 原理分析</h2><h3 id="3-1-1-前序遍历与中序遍历"><a href="#3-1-1-前序遍历与中序遍历" class="headerlink" title="3.1.1 前序遍历与中序遍历"></a>3.1.1 前序遍历与中序遍历</h3><ul>
<li><p><strong>前序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面，但是前序遍历的逻辑不是很好叙述，大家可以看完中序遍历的逻辑，在结合中序遍历和前序遍历的代码来体会前序遍历的这句话</strong></p>
</li>
<li><p><strong>分析：</strong>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了和前序遍历的处理顺序和访问顺序是不一致的</p>
</li>
<li><p>中序遍历的访问过程：</p>
<ul>
<li><p>第1步：沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点，此时栈内元素依次为ABD；</p>
</li>
<li><p>第2步：栈顶元素出栈并访问：若其右孩子为空，继续执行第2步；若其右孩子不空，将右子树转执行第1步。</p>
</li>
</ul>
</li>
<li>整个过程：<ul>
<li>栈顶D出栈并访问，它是中序序列的第一个结点，</li>
<li>D右孩子为空，栈顶B出栈并访问；（第2步）</li>
<li>B右孩子不空，将其右孩子E入栈；（第1步）</li>
<li>E左孩子为空，栈顶E出栈并访问；（第2步）</li>
<li>E右孩子为空，栈顶A出栈并访问；（第2步）</li>
<li>A右孩子不空，将其右孩子C入栈；（第1步）</li>
<li>C左孩子为空，栈顶C出栈并访问；（第2步）</li>
<li>由此得到中序遍历结果：DBEAC</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-后序遍历"><a href="#3-1-2-后序遍历" class="headerlink" title="3.1.2 后序遍历"></a>3.1.2 后序遍历</h3><ul>
<li>后序遍历的非递归实现是三种遍历方法中最难的，因为在后序遍历中，要保证左孩了和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。</li>
<li><p><strong>算法思想：后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点</strong></p>
<ul>
<li><strong>第1步：沿着根的左孩子，依次入栈，直到左孩子为空，此时栈内元素依次为ABD</strong></li>
<li><strong>第2步：读栈顶元素，若其右孩子不空且未被访问过，将右子树转执行第1步；否则，栈顶元素出栈并访问</strong></li>
</ul>
</li>
<li><p><strong>代码实现细节：在上述思想的第2步中，必须分清返回时是从左子树返回的还是从右子树返回的，因此设定一个辅助指针r，指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问</strong></p>
</li>
<li><p><strong>实例过程分析：</strong></p>
<ul>
<li>栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；</li>
<li>栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；</li>
<li>栈顶B的右孩子不空但已被访问，B出栈并访问；</li>
<li>栈项A的右孩子不空且未被访问过，C入栈，栈项C的左右孩子均为空，出栈并访问；</li>
<li>栈顶A的右孩子不空但已被访问，A出栈并访问，由此得到后序序列DEBCA</li>
</ul>
</li>
<li><p><strong>我们再来分析后序遍历的第二种实现方式：要实现前面的这个逻辑还是比较复杂的，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转结果数组，输出的结果顺序就是左右中了</strong></p>
<ul>
<li>图解：</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zzxrepository/image_bed@master/leetcode/image-20240518161314423.png" alt="image-20240518161314423"></p>
<h2 id="3-2-前序遍历（迭代法）"><a href="#3-2-前序遍历（迭代法）" class="headerlink" title="3.2 前序遍历（迭代法）"></a>3.2 前序遍历（迭代法）</h2><ul>
<li><strong>分析：</strong>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子<ul>
<li>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</li>
</ul>
</li>
</ul>
<h4 id="方法1：单层循环"><a href="#方法1：单层循环" class="headerlink" title="方法1：单层循环"></a>方法1：单层循环</h4><blockquote>
<p>单层循环和双层循环有细微的差别，大家可以自己看代码，根据自己的习惯来写</p>
</blockquote>
<p><strong>实现１：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();       </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="comment">//如果左孩子不为空，会一直执行if语句体</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//每次访问左孩子的同时就是在访问中间结点</span></span><br><span class="line">                <span class="comment">//前序遍历需要把中间结果进行输出</span></span><br><span class="line">                <span class="comment">//因此每次判断把中间结果进行保存</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">                <span class="comment">//就需要访问当前结点的右孩子的左孩子</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现２：</strong></p>
<blockquote>
<p>只有前序遍历能这样实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代法 借助栈</span></span><br><span class="line">        <span class="comment">//创建对返回值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建栈存放中间节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span>  stack.pop();</span><br><span class="line">            <span class="comment">//根节点入栈</span></span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="comment">//右节点先入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：双层循环"><a href="#方法2：双层循环" class="headerlink" title="方法2：双层循环"></a>方法2：双层循环</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问中间结点</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">            <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-中序遍历（迭代法）"><a href="#3-3-中序遍历（迭代法）" class="headerlink" title="3.3 中序遍历（迭代法）"></a>3.3 中序遍历（迭代法）</h2><blockquote>
<p>单层循环和双层循环有细微的差别，大家可以自己看代码，根据自己的习惯来写</p>
</blockquote>
<h4 id="方法1：单层循环-1"><a href="#方法1：单层循环-1" class="headerlink" title="方法1：单层循环"></a>方法1：单层循环</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">                <span class="comment">//访问中间结点</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：双层循环-1"><a href="#方法2：双层循环-1" class="headerlink" title="方法2：双层循环"></a>方法2：双层循环</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">            <span class="comment">//访问中间结点</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-后序遍历（迭代法）"><a href="#3-4-后序遍历（迭代法）" class="headerlink" title="3.4 后序遍历（迭代法）"></a>3.4 后序遍历（迭代法）</h2><blockquote>
<p>单层循环和双层循环有细微的差别，大家可以自己看代码，根据自己的习惯来写</p>
</blockquote>
<h4 id="方法1：单层循环-2"><a href="#方法1：单层循环-2" class="headerlink" title="方法1：单层循环"></a>方法1：单层循环</h4><blockquote>
<p>这个代码是使用列表反转这个技巧的代码</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直到左孩子为空，说明已找到可以输出的结点</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                <span class="comment">//判断右孩子</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：双层循环（反转）"><a href="#方法2：双层循环（反转）" class="headerlink" title="方法2：双层循环（反转）"></a>方法2：双层循环（反转）</h4><blockquote>
<p>这个代码是使用列表反转这个技巧的代码</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//非递归算法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//注意，第一次进入循环的结果是判断根节点root是否为空！</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问中间结点</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">            <span class="comment">//就需要访问当前结点的右孩子</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法3：双层循环（不反转）"><a href="#方法3：双层循环（不反转）" class="headerlink" title="方法3：双层循环（不反转）"></a>方法3：双层循环（不反转）</h4><blockquote>
<p>这个代码是后序遍历真实的逻辑代码，没有使用反转这个技巧</p>
</blockquote>
<p><strong>code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//非递归算法</span></span><br><span class="line">    <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取当前处理的节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">   	<span class="comment">//表示上一个处理的节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//3开始进行迭代</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="comment">//沿着根的左孩子，依次入栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//直到左孩子为空，说明当前结点的左孩子已经没有了</span></span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="comment">//再来访问右节点，如果右节点没有，就访问并弹出栈顶元素，此时访问的就是中间节点</span></span><br><span class="line">        <span class="comment">//如果有右节点，先判断右节点是否访问过，如果访问过直接弹出</span></span><br><span class="line">        <span class="keyword">if</span>(cur.right == <span class="literal">null</span> || cur.right == prev) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ret.add(cur.val);</span><br><span class="line">            prev = cur; <span class="comment">// 最近一次访问的节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-深度优先遍历：统一迭代法"><a href="#4-深度优先遍历：统一迭代法" class="headerlink" title="4.深度优先遍历：统一迭代法"></a>4.深度优先遍历：统一迭代法</h1><ul>
<li><p><strong>利用栈的后入先出特性，按照逆序添加到栈中，然后出栈。同时用一个变量来标记某个节点是否被访问过。栈中的元素是元组，即（节点是否被访问过，节点）</strong></p>
<ul>
<li>具体来说，当栈不为空时，循环处理最后一个元素：</li>
<li><p>如果节点为空，则跳过。</p>
</li>
<li><p>如果某个节点没被访问过，则左子节点、右子节点、自己这三个点按照遍历的<strong>逆序入栈</strong>，并且自己标记为访问过，其他两个子节点标记未访问。</p>
</li>
<li><p>如果某个节点被访问过，则记录它的值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//统一迭代法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.根节点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判断栈顶元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为了保证中间结点在左右子树之前先出栈，弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                <span class="comment">//中</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//并同时给要处理的结点之前添加一个标识</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在处理之前弹出栈顶的null</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//获取处理的结点</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                <span class="comment">//添加中间结点</span></span><br><span class="line">                list.add(node.val);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//统一迭代法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.根节点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判断栈顶元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为了保证中间结点在左子树之前先出栈，弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                <span class="comment">//中</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//并同时给要处理的结点之前添加一个标识</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.left);              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在处理之前天弹出栈顶的null</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//获取处理的结点</span></span><br><span class="line">                node = stack.pop();      </span><br><span class="line">                <span class="comment">//添加中间结点</span></span><br><span class="line">                list.add(node.val);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//统一迭代法</span></span><br><span class="line">        <span class="comment">//1.创建列表返回结果</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建中间过程中间的存放结点的栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.根节点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判断栈顶元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为了保证中间结点在左子树之前先出栈，弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//中</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//并同时给要处理的结点之前添加一个标识</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.right);              </span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.push(node.left);              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在处理之前天弹出栈顶的null</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//获取处理的结点</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                <span class="comment">//添加中间结点</span></span><br><span class="line">                list.add(node.val);              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-广度优先遍历"><a href="#5-广度优先遍历" class="headerlink" title="5.广度优先遍历"></a>5.广度优先遍历</h1><ul>
<li>二叉树的广度优先遍历也叫做层序遍历。</li>
<li>层序遍历一个二叉树，就是从左到右一层一层的去遍历二叉树。</li>
<li>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></li>
</ul>
<h2 id="5-1-自顶向下的层序遍历"><a href="#5-1-自顶向下的层序遍历" class="headerlink" title="5.1 自顶向下的层序遍历"></a>5.1 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">自顶向下的层序遍历</a></h2><h4 id="方法1：递归法"><a href="#方法1：递归法" class="headerlink" title="方法1：递归法"></a>方法1：递归法</h4><blockquote>
<p>该方法使用的是递归</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="comment">//1.创建存放结果的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//2.开始递归</span></span><br><span class="line">        <span class="comment">//递归方法论：</span></span><br><span class="line">        <span class="comment">//明确方法形参和返回值</span></span><br><span class="line">        levelOrderTraverse(root,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraverse</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//确定单层递归逻辑</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span>(result.size() &lt; depth)&#123;</span><br><span class="line">            <span class="comment">//当层增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(depth - <span class="number">1</span>).add(node.val);</span><br><span class="line">        levelOrderTraverse(node.left,depth);</span><br><span class="line">        levelOrderTraverse(node.right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：迭代法"><a href="#方法2：迭代法" class="headerlink" title="方法2：迭代法"></a>方法2：迭代法</h4><blockquote>
<p>该方法使用的迭代法，需要借助队列来实现</p>
</blockquote>
<p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代方法</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//借助队列实现</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//创建每一层的列表</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">//获取每一层的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= currentLevelSize; ++i)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将每一层列表添加到结果中</span></span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-自底向上的层序遍历"><a href="#5-2-自底向上的层序遍历" class="headerlink" title="5.2 自底向上的层序遍历"></a>5.2 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">自底向上的层序遍历</a></h2><h4 id="方法1：递归法-1"><a href="#方法1：递归法-1" class="headerlink" title="方法1：递归法"></a>方法1：递归法</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="comment">//1.创建存放结果的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//2.开始递归</span></span><br><span class="line">        <span class="comment">//递归方法论：</span></span><br><span class="line">        <span class="comment">//明确方法形参和返回值</span></span><br><span class="line">        levelOrderTraverse(root,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraverse</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//确定单层递归逻辑</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span>(result.size() &lt; depth)&#123;</span><br><span class="line">            <span class="comment">//当层增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(depth - <span class="number">1</span>).add(node.val);</span><br><span class="line">        levelOrderTraverse(node.left,depth);</span><br><span class="line">        levelOrderTraverse(node.right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2：迭代法-1"><a href="#方法2：迭代法-1" class="headerlink" title="方法2：迭代法"></a>方法2：迭代法</h4><p><strong>Code：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代方法</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//借助队列实现</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//创建每一层的列表</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">//获取每一层的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; currentLevelSize;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将每一层列表添加到结果中</span></span><br><span class="line">            ret.add(level);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果不反转就充分利用add函数的性质</span></span><br><span class="line">            <span class="comment">//头插法</span></span><br><span class="line">            <span class="comment">//ret.add(0, level);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-和层序遍历相关的十一道题目"><a href="#5-3-和层序遍历相关的十一道题目" class="headerlink" title="5.3 和层序遍历相关的十一道题目"></a>5.3 和层序遍历相关的十一道题目</h2><ul>
<li><p>大家做完层序遍历，可以使用层序遍历的方式去做下面的这十一个题目，都与层序bian’li</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117.填充每个节点的下一个右侧节点指针II(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值</a></p>
</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/692543960">https://zhuanlan.zhihu.com/p/692543960</a></p>
<p><a href="https://www.51cto.com/article/614590.html">https://www.51cto.com/article/614590.html</a></p>
<p><a href="https://blog.csdn.net/weixin_44027397/article/details/113735310?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86java&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-113735310.142^v100^control&amp;spm=1018.2226.3001.4187">2</a></p>
<p><a href="https://blog.csdn.net/qq_64257622/article/details/131112998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171517933116800222816298%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171517933116800222816298&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131112998-null-null.142^v100^control&amp;utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86java&amp;spm=1018.2226.3001.4187">3</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>迭代法</tag>
        <tag>递归法</tag>
        <tag>广度优先遍历</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>删除字符串中的所有相邻重复项 | LeetCode-1047 | 栈与队列</title>
    <url>/2024/09/13/algorithm/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/LeetCode-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<center><b>栈与队列练习题</b></center>

<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给出由小写字母组成的字符串 <code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;abbaca&quot;</span></span><br><span class="line">输出：<span class="string">&quot;ca&quot;</span></span><br><span class="line">解释：</span><br><span class="line">例如，在 <span class="string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="string">&quot;aaca&quot;</span>，其中又只有 <span class="string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="string">&quot;ca&quot;</span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>$1 &lt;= s.length &lt;= 10^5$</li>
<li><code>s</code> 仅由小写英文字母组成。</li>
</ol>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-栈与队列"><a href="#2-1-栈与队列" class="headerlink" title="2.1 栈与队列"></a>2.1 栈与队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 LinkedList 来存储不重复的字符，作为栈使用</span></span><br><span class="line">        LinkedList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串中的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果列表不为空且当前字符与列表最后一个字符相同，则移除最后一个字符（即相邻的重复字符）</span></span><br><span class="line">            <span class="keyword">if</span> (!list.isEmpty() &amp;&amp; list.peekLast() == c) &#123;</span><br><span class="line">                list.pollLast();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则将当前字符加入列表的末尾</span></span><br><span class="line">                list.offer(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 StringBuilder 将最终结果拼接成字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 依次从列表中取出字符，拼接成结果字符串</span></span><br><span class="line">            sb.append(list.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回拼接好的字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-字符串当栈"><a href="#2-2-字符串当栈" class="headerlink" title="2.2 字符串当栈"></a>2.2 字符串当栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length()-<span class="number">1</span>) == c)&#123;</span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-双指针"><a href="#2-3-双指针" class="headerlink" title="2.3 双指针"></a>2.3 双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 左指针用于表示结果部分的末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符和结果末尾字符相同，左指针回退</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; chs[right] == chs[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chs[left] = chs[right];  <span class="comment">// 更新结果部分</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs, <span class="number">0</span>, left);  <span class="comment">// 只返回有效部分的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式求值 | LeetCode-150 | 栈与队列</title>
    <url>/2024/09/13/algorithm/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/LeetCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<center><b>栈与队列练习题</b></center>

<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值<a/></b>
</center>


<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">tokens</span> = [<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">tokens</span> = [<span class="string">&quot;4&quot;</span>,<span class="string">&quot;13&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;+&quot;</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>)) = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入：tokens = [<span class="string">&quot;10&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-11&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;17&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;+&quot;</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / -<span class="number">132</span>)) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span></span><br><span class="line">= <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= tokens.length &lt;= 10^4$</li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-栈与队列"><a href="#2-1-栈与队列" class="headerlink" title="2.1 栈与队列"></a>2.1 栈与队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用栈来存储计算过程中的操作数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有的输入 tokens</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前 token 是加号</span></span><br><span class="line">            <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶的两个操作数，进行相加，然后将结果压入栈中</span></span><br><span class="line">                <span class="comment">// 这里 pop() 两次是因为加法是二元操作，需要两个操作数</span></span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 token 是减号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶的两个操作数，先弹出的数为减数，后弹出的数为被减数</span></span><br><span class="line">                <span class="comment">// 计算后将结果压入栈中</span></span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 token 是乘号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶的两个操作数，进行相乘，然后将结果压入栈中</span></span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 token 是除号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶的两个操作数，注意除法的顺序：</span></span><br><span class="line">                <span class="comment">// 第一个弹出的数为除数 (num2)，第二个弹出的数为被除数 (num1)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="comment">// 进行除法计算后，将结果压入栈中</span></span><br><span class="line">                stack.push(num1 / num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 token 是数字</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将数字字符串转换为整数，并压入栈中</span></span><br><span class="line">                stack.push(Integer.parseInt(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最终栈中只剩下一个元素，即计算结果，弹出栈顶并返回</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号 | LeetCode-20 | 栈与队列</title>
    <url>/2024/09/13/algorithm/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<center><b>栈与队列练习题</b></center>

<hr>
<center>
    <b>LeetCode链接：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号<a/></b>
</center>

<hr>
<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>s = “()”</p>
<p><strong>输出：</strong>true</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>s = “()[]{}”</p>
<p><strong>输出：</strong>true</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>s = “(]”</p>
<p><strong>输出：</strong>false</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>s = “([])”</p>
<p><strong>输出：</strong>true</p>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^4$</li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><h2 id="2-1-栈与队列-哈希集合"><a href="#2-1-栈与队列-哈希集合" class="headerlink" title="2.1 栈与队列-哈希集合"></a>2.1 栈与队列-哈希集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化栈，用于存储需要匹配的右括号</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建哈希映射，将左括号与相应的右括号配对</span></span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果字符是左括号（即 map 的键），则将对应的右括号压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                stack.push(map.get(c));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果是右括号，检查栈顶元素是否与当前右括号匹配</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果栈非空，且栈顶的括号与当前字符匹配，则弹出栈顶元素</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不匹配或栈为空，返回 false，表示括号不合法</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();<span class="comment">// 最后检查栈是否为空，如果为空则表示所有括号匹配，否则返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-栈与队列-逻辑判断"><a href="#2-2-栈与队列-逻辑判断" class="headerlink" title="2.2 栈与队列-逻辑判断"></a>2.2 栈与队列-逻辑判断</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如何碰到的是键，就入栈</span></span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值 | LeetCode-239 | 栈与队列</title>
    <url>/2024/09/13/algorithm/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<center><b>栈与队列练习题</b></center>

<hr>
<p><center><br>    <b>LeetCode链接：<a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值<a/></b></p>
<h2 id="lt-center-gt"><a href="#lt-center-gt" class="headerlink" title="&lt;/center&gt;"></a>&lt;/center&gt;</h2><h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h1 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h1><ul>
<li>这道题目暴力解法超时，需要另寻良策</li>
</ul>
<h2 id="2-1-LinkedList双端队列实现单调队列"><a href="#2-1-LinkedList双端队列实现单调队列" class="headerlink" title="2.1 LinkedList双端队列实现单调队列"></a>2.1 LinkedList双端队列实现单调队列</h2><ul>
<li>图解：<a href="https://leetcode.cn/problems/sliding-window-maximum/solutions/2361228/239-hua-dong-chuang-kou-zui-da-zhi-dan-d-u6h0/">https://leetcode.cn/problems/sliding-window-maximum/solutions/2361228/239-hua-dong-chuang-kou-zui-da-zhi-dan-d-u6h0/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定义一个双端队列，用来存储滑动窗口中可能的最大值的下标</span></span><br><span class="line">        LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 结果数组，用来存储每个滑动窗口的最大值</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 结果数组的下标，用于记录结果的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 保证队列头节点在当前滑动窗口的范围内</span></span><br><span class="line">            <span class="comment">// 如果队列头部元素的下标小于滑动窗口的起始下标（i - k + 1），</span></span><br><span class="line">            <span class="comment">// 说明该下标已经滑出窗口范围，需要将其移除队列</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 保证队列中元素按从大到小排列</span></span><br><span class="line">            <span class="comment">// 如果当前元素 nums[i] 大于队列末尾元素对应的值，说明队列末尾元素不可能成为窗口的最大值，</span></span><br><span class="line">            <span class="comment">// 需要将其从队列中移除，直到找到一个比当前元素大的元素或队列为空</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前元素下标加入队列，保持队列的单调性（从大到小）</span></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当窗口大小达到 k（即 i &gt;= k - 1 时），可以确定此时的窗口内最大值</span></span><br><span class="line">            <span class="comment">// 最大值就是队列头部的元素所对应的数组值，将其加入结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将 “未形成窗口” 和 “形成窗口后” 两个阶段拆分到两个循环里实现。代码虽变长，但减少了冗余的判断操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 未形成窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="comment">// 形成窗口后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(deque.peekFirst() == nums[i - k])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            res[i - k + <span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>栈与队列</tag>
      </tags>
  </entry>
</search>
